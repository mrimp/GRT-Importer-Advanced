
<!DOCTYPE html>
<!--
GRT Importer Advanced v0.89 ‚Äî Release
Build date: 2025-12-19

Release highlights:
- Session Save: download-only JSON (no new-tab preview).
- Session Load: verified round-trip stability (shots/charges/units/badges preserved).
- Phase 3 confidence: tightened for 1000y realism (shot-count gravity + target-first when ShotMarker disagrees).

Notes:
- localStorage keys are namespaced (xqa_*).
- Expected state (no base loaded) is not an error.
-->


<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>GRT Importer Advanced v0.89</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
/* Silence Tailwind CDN production warning in this single-file tool */
(function(){
  try{
    const _w = console.warn;
    console.warn = function(){
      try{
        if(arguments && typeof arguments[0]==='string' && arguments[0].indexOf('cdn.tailwindcss.com should not be used in production')>=0) return;
      }catch(_e){}
      return _w.apply(console, arguments);
    };
  }catch(_e){}
})();
</script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        :root {
            --grt-bg: #10141c;
            --grt-panel: #1b2431;
            --grt-panel-soft: #151d28;
            --grt-highlight: #273347;
            --grt-border: #3a4a61;
            --grt-border-soft: #283447;
            --grt-accent: #3c86c7;
            --grt-accent-soft: #295f90;
            --grt-accent-warm: #e0a542;
            --grt-text-soft: #c7d2e5;
            --grt-text-subtle: #9ca9c0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
                Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--grt-bg);
        }
        .bg-grt-panel { background-color: var(--grt-panel); }
        .bg-grt-panel-soft { background-color: var(--grt-panel-soft); }
        .bg-grt-highlight { background-color: var(--grt-highlight); }
        .border-grt-frame { border-color: var(--grt-border); }
        .border-grt-soft { border-color: var(--grt-border-soft); }
        .border-grt-accent { border-color: var(--grt-accent); }
        .text-grt-soft { color: var(--grt-text-soft); }
        .text-grt-subtle { color: var(--grt-text-subtle); }

        /* Floating toast container */
        #statusArea {
            position: fixed;
            right: 1rem;
            bottom: 1rem;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 20rem;
            pointer-events: none;
        }
    
        /* Stepper circles for top progress indicator */
        .step-circle {
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 9999px;
            border: 1px solid var(--grt-border-soft);
            background: transparent;
            color: var(--grt-text-subtle);
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            position: relative;
            transform-origin: center;
            transition:
                background-color 0.18s ease,
                border-color 0.18s ease,
                color 0.18s ease,
                transform 0.18s ease,
                box-shadow 0.18s ease;
        }
        .step-circle--active {
            border-color: var(--grt-accent);
            background: var(--grt-highlight);
            color: var(--grt-text-soft);
            transform: scale(1.05);
        }
        .step-circle--done {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.16);
            color: #bbf7d0;
        }
        .step-circle--done::after {
            content: "‚úì";
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            opacity: 0.25;
            pointer-events: none;
        }

    
        /* Animated active step circle */
        .step-circle--active {
            animation: pulseStep 1.2s infinite ease-in-out;
        }
        @keyframes pulseStep {
            0% { transform: scale(1.05); box-shadow: 0 0 0 0 rgba(60,134,199,0.6); }
            70% { transform: scale(1.12); box-shadow: 0 0 10px 6px rgba(60,134,199,0); }
            100% { transform: scale(1.05); box-shadow: 0 0 0 0 rgba(60,134,199,0); }
        }

        /* Session complete pulse for header pill + stepper */
        .session-pulse {
            animation: sessionPulse 0.45s ease-out;
        }
        @keyframes sessionPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.85);
            }
            100% {
                box-shadow: 0 0 0 14px rgba(34, 197, 94, 0);
            }
        }



/* v094: file input button visibility */
input[type="file"]{color:inherit;}
input[type="file"]::file-selector-button{
  background: rgba(255,255,255,0.08);
  color: rgba(255,255,255,0.92);
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 12px;
  padding: 10px 14px;
  margin-right: 14px;
  cursor: pointer;
}
input[type="file"]::file-selector-button:hover{background: rgba(255,255,255,0.12);}
input[type="file"]::file-selector-button:active{background: rgba(255,255,255,0.16);}


/* Neon skin to visually distinguish this build */
.header-neon{
  position: relative;
  overflow: hidden;
  border-color: rgba(0,245,255,.35) !important;
  background:
    radial-gradient(1200px 500px at 15% 0%, rgba(0,245,255,.18), transparent 60%),
    radial-gradient(900px 420px at 85% 0%, rgba(180,0,255,.16), transparent 55%),
    linear-gradient(180deg, rgba(18,28,44,.96), rgba(12,18,28,.92));
  box-shadow:
    0 0 0 1px rgba(0,245,255,.12),
    0 0 28px rgba(0,245,255,.18),
    0 0 64px rgba(180,0,255,.12),
    0 18px 50px rgba(0,0,0,.55);
}
.header-neon::before{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius: inherit;
  padding: 2px;
  background: linear-gradient(90deg, rgba(0,245,255,.95), rgba(180,0,255,.95), rgba(0,255,133,.90));
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events:none;
  opacity:.9;
}
.header-neon::after{
  content:"";
  position:absolute;
  left:-30%;
  top:-60%;
  width:160%;
  height:180%;
  background: radial-gradient(circle at 35% 35%, rgba(0,245,255,.12), transparent 55%),
              radial-gradient(circle at 65% 45%, rgba(180,0,255,.10), transparent 60%);
  filter: blur(10px);
  transform: rotate(6deg);
  pointer-events:none;
  opacity:.8;
}
</style>
</head>
<body class="min-h-screen p-4 md:p-6">
<main class="max-w-5xl mx-auto">
<!-- Header -->
<div class="bg-grt-panel rounded-2xl shadow-2xl p-6 mb-4 border border-grt-frame header-neon">
<div class="flex items-start justify-between gap-4">
<div>
<div class="inline-flex items-center gap-2 mb-2">
<span class="inline-flex items-center px-2 py-0.5 rounded-full bg-grt-highlight border border-grt-accent text-[10px] font-semibold tracking-wide uppercase text-grt-soft">
                            Chronograph ‚Üí GRT
                        </span>
</div>
<h1 class="text-3xl md:text-4xl font-extrabold text-white mb-1">
                        GARMIN / ATHLON ‚Üí GRT Importer
                    </h1>
<p class="text-grt-soft text-sm md:text-base">
                        Import chronograph data (Garmin Xero C1 Pro or Athlon Rangecraft Velocity Pro)
                        into Gordon's Reloading Tool projects.
                    </p>
<!-- Quick start line -->
<p class="text-grt-subtle text-[11px] mt-1">
                        Quick start: 1) Load base <code class="bg-slate-800/70 px-1 rounded">.grtload</code> (optional),
                        2) pick chrono + files, 3) download <code class="bg-slate-800/70 px-1 rounded">.grtload</code> and open in GRT.
                    </p>
<div class="flex flex-wrap items-center gap-2 mt-2 text-xs">
<p class="text-grt-subtle">
                            GRT Importer Advanced v0.89 ‚Ä¢ XquiziT Arms
                        </p>
<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full border border-grt-soft bg-grt-panel-soft text-[10px] md:text-[11px] text-grt-soft" id="sessionPill" title="Summary of imported sessions and current velocity unit.">
                            ‚öôÔ∏è Standard ‚Ä¢ 0 files ‚Ä¢ ft/s
                        </span>
</div>
</div>
<div class="flex flex-col items-end gap-3">
<div class="flex items-center gap-2">
<button aria-label="Start new session" class="p-2.5 rounded-full bg-grt-panel-soft hover:bg-grt-highlight text-slate-100 border border-grt-frame shadow-md transition-transform transform hover:-translate-y-0.5 hover:shadow-lg" id="newSessionBtn" title="Start new session">
<svg class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4.5 12a7.5 7.5 0 0112.62-5.303L19.5 9M7.5 9H4.5V6m15 6a7.5 7.5 0 01-12.62 5.303L4.5 15m12 0h3v3" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</button>
</div>
</div>

<div class="hidden md:flex items-start justify-end">
    <button id="helpOverlayButton"
            class="inline-flex items-center gap-1 px-3 py-1.5 rounded-full border border-grt-frame text-grt-soft text-[11px] md:text-xs bg-grt-panel-soft hover:border-grt-accent hover:text-grt-accent transition">
        <span>‚ùì How to use this</span>
    </button>
</div>
</div>
</div>

<!-- Stepper -->
<div class="mb-4 md:mb-5">
<ol class="flex items-center gap-2 text-[11px] md:text-xs text-grt-subtle" id="topStepper">
<li class="flex items-center gap-1" data-step="1">
<div class="step-circle step-circle--active">
                        1
                    </div>
<span>Pictures &amp; notes</span>
</li>
<li class="flex-1 h-px bg-grt-highlight/60 mx-1"></li>
<li class="flex items-center gap-1" data-step="2">
<div class="step-circle">
                        2
                    </div>
<span>Add-ons</span>
</li>
<li class="flex-1 h-px bg-grt-highlight/30 mx-1"></li>
<li class="flex items-center gap-1" data-step="3">
<div class="step-circle">
                        3
                    </div>
<span>Load base .grtload</span>
</li>
<li class="flex-1 h-px bg-grt-highlight/30 mx-1"></li>
<li class="flex items-center gap-1" data-step="4">
<div class="step-circle">
                        4
                    </div>
<span>Chronograph files</span>
</li>
</ol>
</div>
<!-- Floating status toasts --><!-- Floating status toasts -->
<div aria-live="polite" id="statusArea" role="status"></div>
<!-- Upload Area -->
<section aria-label="Import configuration" class="space-y-4 md:space-y-5" id="uploadArea" title="Configure device, units, and import mode, then load your chrono files.">
<!-- 3. Imported Pictures & Notes -->
<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame hover:border-grt-accent transition-colors">
<div class="flex items-start gap-4">
<div class="flex-shrink-0 w-10 h-10 md:w-12 md:h-12 bg-grt-highlight rounded-full flex items-center justify-center text-lg md:text-xl font-bold text-grt-soft border-grt-accent border shadow-inner">
                        1
                    </div>
<div class="flex-1">
<h3 class="text-lg font-bold text-white mb-1.5">
                            üñºÔ∏è Optional: Imported Pictures &amp; Notes
                        </h3>
<p class="text-grt-soft text-xs md:text-sm mb-3">
                            Add screenshots, target photos, and text notes directly into the GRT project.
                            Pictures go to <strong>Imported Pictures</strong>; notes go to
                            <strong>Imported Notes</strong>. Your existing tabs remain unchanged.
                        </p>
<div class="grid grid-cols-1 md:grid-cols-1 gap-3">
<!-- Pictures -->
<div class="bg-grt-panel-soft rounded-xl border border-grt-frame p-3">
<h4 class="text-white text-xs md:text-sm font-semibold mb-2">Imported Pictures</h4>
<p class="text-grt-subtle text-[11px] mb-2">
                                    Select one or more images. They‚Äôre stored inside the
                                    <code class="bg-slate-800/70 px-1 rounded text-[10px]">.grtload</code> as a gallery tab.
                                </p>
<div class="flex flex-wrap items-center gap-2">
<input accept="image/*" class="hidden" id="pictureInput" multiple="" type="file"/>
<button class="px-3 py-1.5 bg-grt-panel hover:bg-grt-highlight text-white rounded-md text-[11px] md:text-xs border border-grt-frame" id="pictureBtn" onclick="document.getElementById('pictureInput').click()" type="button">
                                        Select Pictures
                                    </button>
<span class="text-grt-subtle text-[11px] md:text-xs" id="picturesStatus">
                                        No pictures selected
                                    </span>
</div>
</div>
<!-- Notes -->
<div class="bg-grt-panel-soft rounded-xl border border-grt-frame p-3">
<h4 class="text-white text-xs md:text-sm font-semibold mb-2">Imported Notes</h4>
<p class="text-grt-subtle text-[11px] mb-2">
                                    Select text files (<code class="bg-slate-800/70 px-1 rounded text-[10px]">.txt</code>,
                                    <code class="bg-slate-800/70 px-1 rounded text-[10px]">.md</code>, etc.). Files are merged into one notes tab.
                                </p>
<div class="flex flex-wrap items-center gap-2">
<input accept=".txt,.md,.rtf,.log" class="hidden" id="notesInput" multiple="" type="file"/>
<button class="px-3 py-1.5 bg-grt-panel hover:bg-grt-highlight text-white rounded-md text-[11px] md:text-xs border border-grt-frame" id="notesBtn" onclick="document.getElementById('notesInput').click()" type="button">
                                        Select Notes Files
                                    </button>
<span class="text-grt-subtle text-[11px] md:text-xs" id="notesStatus">
                                        No notes added
                                    </span>
</div>
</div>
</div>
</div>
</div>
</div>

<!-- 2. Optional Add-ons: ShotMarker -->
<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame hover:border-grt-accent transition-colors">
  <div class="flex items-start gap-4">
    <div class="flex-shrink-0 w-10 h-10 md:w-12 md:h-12 bg-grt-highlight rounded-full flex items-center justify-center text-lg md:text-xl font-bold text-grt-soft border border-grt-accent shadow-inner">
      2
    </div>
    <div class="flex-1">
      <h3 class="text-lg font-bold text-white mb-1.5">üß© Optional Add-ons: ShotMarker</h3>
      <p class="text-grt-soft text-xs md:text-sm mb-3">
        Load exported add-on files. These will be shown in the run summary and exported as appendix tabs in the generated
        <code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.grtload</code>.
      </p>

      <div class="grid grid-cols-1 gap-3">
        <!-- ShotMarker -->
        <div class="bg-grt-panel-soft rounded-xl border border-grt-frame p-3">
          <div class="flex items-start justify-between gap-2">
            <div>
              <h4 class="text-white text-xs md:text-sm font-semibold mb-1">ShotMarker</h4>
              <p class="text-grt-subtle text-[11px] mb-2">
                Import a ShotMarker export (CSV). We‚Äôll summarize ES/MR when possible.
              </p>
            </div>
            <span class="text-grt-subtle text-[10px] md:text-xs" id="shotMarkerStatus">No file loaded</span>
          </div>

          <div class="flex flex-wrap items-center gap-2 mb-2">
            <input accept=".csv" class="hidden" id="shotMarkerInput" type="file"/>
            <button class="px-3 py-1.5 bg-grt-panel hover:bg-grt-highlight text-white rounded-md text-[11px] md:text-xs border border-grt-frame"
                    type="button" onclick="document.getElementById('shotMarkerInput').click()">
              Select ShotMarker CSV
            </button>
            <button class="px-3 py-1.5 bg-grt-panel hover:bg-grt-highlight text-white rounded-md text-[11px] md:text-xs border border-grt-frame"
                    type="button" onclick="clearShotMarkerAddons()">
              Clear
            </button>
          </div>

          <div id="shotMarkerInlineCards" class="space-y-2"></div>
        </div>

        
        
      </div>
    </div>
</div>

<!-- 1. GRT Base File -->
<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame hover:border-grt-accent transition-colors">
<div class="flex items-start gap-4">
<div class="flex-shrink-0 w-10 h-10 md:w-12 md:h-12 bg-grt-highlight rounded-full flex items-center justify-center text-lg md:text-xl font-bold text-grt-soft border border-grt-accent shadow-inner">
                        3
                    </div>
<div class="flex-1">
<h3 class="text-lg font-bold text-white mb-1.5">
                            üìÅ Load GRT Base File (Optional)
                        </h3>
<p class="text-grt-soft text-xs md:text-sm mb-4">
                            Upload an existing <code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.grtload</code>
                            with your rifle, ammo, and powder configuration. Your original tabs and ladder remain untouched.
                            Standard mode creates an <strong>Imported Measurement</strong> tab; Ladder mode creates an
                            <strong>Imported Ladder</strong> tab.
                        </p>
<div class="flex flex-wrap items-center gap-3">
<input accept=".grtload,.grt" class="hidden" id="grtBaseInput" title="Optional: choose a base .grtload file to merge ladder data into." type="file"/>
<button class="px-4 py-2 bg-grt-panel-soft hover:bg-grt-highlight text-white rounded-lg text-sm font-medium border border-grt-frame shadow-sm transition-colors" id="grtBaseBtn" onclick="document.getElementById('grtBaseInput').click()" title="Browse for the base .grtload file used for ladder imports.">
                                Select .grtload
                            </button>
<span class="text-emerald-300 text-xs md:text-sm" id="grtBaseStatus"></span>
</div>
</div>
</div>
</div>

<!-- 2. Chronograph Files -->
<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame hover:border-grt-accent transition-colors">
<div class="flex items-start gap-4">
<div class="flex-shrink-0 w-10 h-10 md:w-12 md:h-12 bg-grt-highlight rounded-full flex items-center justify-center text-lg md:text-xl font-bold text-grt-soft border border-grt-accent shadow-inner">
                        4
                    </div>
<div class="flex-1">
<h3 class="text-lg font-bold text-white mb-1.5">üéØ Load Chronograph Files</h3>
<p class="text-grt-soft text-xs md:text-sm mb-4">
                            Load chronograph data as CSV or Excel files
                            (<code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.csv</code>,
                             <code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.xls</code>,
                             <code class="text-slate-200 bg-slate-800/80 px-1 py-0.5 rounded text-[11px]">.xlsx</code>),
                            then pick device, file unit, and import mode.
                        </p>
<!-- Device / unit / mode -->
<div class="flex flex-col gap-2 mb-4">
<div class="flex flex-wrap items-center gap-2">
<label class="text-grt-soft text-xs md:text-sm font-semibold" for="deviceSelect">
                                    Chronograph:
                                </label>
<select class="px-2.5 py-1.5 rounded-lg bg-grt-panel-soft text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)]" id="deviceSelect" title="Choose the chronograph device that produced your files (Garmin or Athlon).">
<option value="garmin">Garmin Xero C1 Pro</option>
<option value="athlon">Athlon Rangecraft Velocity Pro</option>
</select>
</div>
<div class="flex flex-wrap items-center gap-2">
<label class="text-grt-soft text-xs md:text-sm font-semibold" for="unitSelect">
                                    Velocity unit in file:
                                </label>
<select class="px-2.5 py-1.5 rounded-lg bg-grt-panel-soft text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)]" id="unitSelect" title="Set the velocity unit that matches your chronograph exports.">
<option value="imperial">Imperial (ft/s)</option>
<option value="metric">Metric (m/s)</option>
</select>
<span class="text-grt-subtle text-[11px] md:text-xs">
                                    GRT always receives m/s; we convert if needed.
                                </span>
</div>
<div class="flex flex-wrap items-center gap-2">
<label class="text-grt-soft text-xs md:text-sm font-semibold" for="modeSelect">
                                    Import mode:
                                </label>
<select class="px-2.5 py-1.5 rounded-lg bg-grt-panel-soft text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)]" id="modeSelect" title="Select Standard, Ladder, or Sessions import mode.">
<option value="normal">Standard ‚Üí Imported Measurement</option>
<option value="ladder">Ladder ‚Üí Imported Ladder</option>
<option value="sessions">Sessions - Imported Sessions</option>

</select>
<div class="mt-3 p-3 md:p-4 rounded-xl bg-grt-panel-soft border border-grt-frame">
  <div class="flex flex-col md:flex-row md:items-baseline md:justify-between gap-1 md:gap-3 mb-2">
    <span class="text-grt-soft text-xs md:text-sm font-semibold">Export &amp; GRT options</span>
    <span class="text-grt-subtle text-[10px] md:text-xs">
      Affects what gets written into the next <span class="font-mono">.grtload</span> export.
    </span>
  </div>

  <div class="flex flex-col sm:flex-row sm:flex-wrap gap-3">
    <label class="inline-flex items-center gap-2 text-grt-subtle text-[11px] md:text-xs" title="If enabled, we‚Äôll write extended metrics into the charge notes when exporting.">
      <input id="analysisIncludeInNotes" type="checkbox" class="rounded border-grt-frame bg-grt-panel-soft" />
      <span>Write extended metrics into charge notes</span>
    </label>

    <label class="inline-flex items-center gap-2 text-grt-subtle text-[11px] md:text-xs" title="If enabled, we‚Äôll add the Analysis summary note/tab to the .grtload appendix.">
      <input id="exportAnalysisTab" type="checkbox" class="rounded border-grt-frame bg-grt-panel-soft" />
      <span>Export ‚ÄúAnalysis‚Äù tab (summary note)</span>
    </label>
  </div>

  <div class="mt-2 text-grt-subtle text-[10px] md:text-xs">Remembered on this browser.</div>
</div>
</div>
</div>
<!-- Standard multi-file panel inside drag-and-drop zone -->
<div class="border border-dashed border-grt-frame rounded-xl p-3 hover:border-grt-accent hover:bg-grt-panel-soft/60 transition-colors" id="multiFileDropzone" title="Drop chronograph exports here or click to browse from disk.">
<div class="flex flex-wrap items-center gap-3" id="multiFilePanel">
<input accept=".csv,.xls,.xlsx" class="hidden" id="garminInput" multiple="" title="Load a Garmin session workbook (.xls/.xlsx) with one sheet per string." type="file"/>
<button class="px-5 py-2.5 bg-[var(--grt-accent)] hover:bg-[var(--grt-accent-soft)] text-white rounded-lg text-sm font-semibold shadow-md border border-grt-accent transition-transform transform hover:-translate-y-0.5 hover:shadow-lg" onclick="document.getElementById('garminInput').click()">
                                    Select Chronograph Files
                                </button>
<span class="text-grt-subtle text-[11px] md:text-xs">
                                    Standard mode: each file becomes a separate charge in ‚ÄúImported Measurement‚Äù.
                                </span>
<div class="mt-1 text-grt-subtle text-[11px] md:text-xs">
    <span class="font-semibold">Sessions layout (Sessions mode only):</span>
    <label class="inline-flex items-center gap-1 ml-2">
        <input type="radio" name="sessionsLayout" value="compact" id="sessionsLayoutCompact" checked />
        <span>Single tab ‚Äì compact sessions</span>
    </label>
    <label class="inline-flex items-center gap-1 ml-2">
        <input type="radio" name="sessionsLayout" value="legacy" id="sessionsLayoutLegacy" />
        <span>One tab per session (legacy)</span>
    </label>
</div>

</div>
<p class="mt-2 text-grt-subtle text-[10px] md:text-xs">
                                Tip: You can also drag &amp; drop chronograph files anywhere on this box.
                            </p>
</div>
<!-- Per-file processing status list -->
<div class="mt-2 space-y-1 text-[11px] md:text-xs text-grt-subtle" id="fileStatusList"></div>
<!-- Ladder panel -->
<div class="hidden mt-4 border border-grt-frame rounded-xl bg-grt-panel-soft p-3 md:p-4" id="ladderPanel">
<p class="text-grt-soft text-xs md:text-sm mb-3">
                                Ladder mode: select one file per charge step. A new <strong>Imported Ladder</strong> tab
                                is created; the original ladder measurement in your base file stays intact.
                            </p>
<!-- Ladder state badge -->
<div class="inline-flex items-center gap-2 px-2.5 py-1 rounded-full border border-grt-frame bg-grt-panel text-[11px] md:text-xs text-grt-subtle mb-3" id="ladderStateBadge">
<span class="h-1.5 w-1.5 rounded-full bg-slate-500"></span>
<span>Base .grtload not loaded ‚Äî ladder state unknown</span>
</div>
<!-- Hidden if ladder disabled in base -->
<div id="ladderControls">
<!-- Advanced ladder options toggle -->
<button class="inline-flex items-center gap-1 px-2.5 py-1 rounded-md bg-grt-panel border border-grt-frame text-[11px] md:text-xs text-grt-soft hover:bg-grt-highlight transition-colors mb-2" id="ladderAdvancedToggle" type="button">
<span>Advanced ladder options</span>
<span class="inline-block transform transition-transform" id="ladderAdvancedChevron">‚ñº</span>
</button>
<div class="mt-1 hidden" id="ladderAdvancedPanel">
<div class="flex flex-col gap-2 mb-2">
<div class="flex flex-wrap items-center gap-2">
<label class="text-grt-soft text-xs md:text-sm font-semibold" for="ladderStepsSelect">
                                                Loading Ladder Steps (display):
                                            </label>
<select class="px-2.5 py-1.5 rounded-lg bg-grt-panel text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)]" id="ladderStepsSelect">
<option value="2">2</option>
<option value="3">3</option>
<option value="4">4</option>
<option value="5">5</option>
<option value="6">6</option>
<option value="7">7</option>
<option value="8">8</option>
<option value="9">9</option>
<option selected="" value="10">10</option>
</select>
<span class="text-grt-subtle text-[11px] md:text-xs">
                                                Actual step count is read from the base .grtload.
                                            </span>
</div>
<div class="flex flex-wrap items-center gap-2">
<span class="text-grt-soft text-xs md:text-sm font-semibold">
                                                Ladder charge names:
                                            </span>
<select class="px-2.5 py-1.5 rounded-lg bg-grt-panel text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)]" id="ladderNameModeSelect">
<option value="filename">Use file name</option>
<option value="charge">Use ‚ÄúCharge #‚Äù</option>
</select>
<span class="text-grt-subtle text-[11px] md:text-xs flex items-center gap-1">
<span>Preference is remembered.</span>
<span class="inline-flex items-center justify-center h-4 w-4 rounded-full bg-grt-panel-soft border border-grt-frame text-[9px] cursor-help" title="Controls how charges are named in Imported Ladder tab.">
                                                    ?
                                                </span>
</span>
</div>
<div class="flex flex-wrap items-center gap-2 mt-1">
    <span class="text-grt-soft text-xs md:text-sm font-semibold">
        Chrono vs Sim export:
    </span>
    <label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
        <input id="ladderIncludeChronoSim" type="checkbox"
               class="rounded border-grt-frame bg-grt-panel-soft" />
        <span>Export ‚ÄúChrono vs Sim‚Äù tab for ladder</span>
    </label>
    <span class="text-grt-subtle text-[10px] md:text-xs">
        Remembered on this browser.
    </span>
</div>

<div class="flex flex-wrap items-center gap-2 mt-1">
  <span class="text-grt-soft text-xs md:text-sm font-semibold">GRT Simulation Export (JSON):</span>
  <input id="grtSimJsonInput" type="file" accept=".json"
         class="block text-xs md:text-sm text-grt-soft file:mr-2 file:py-1 file:px-3 file:rounded-md file:border-0 file:bg-grt-highlight file:text-white hover:file:bg-grt-accent cursor-pointer"/>
  <span id="grtSimJsonStatus" class="text-grt-subtle text-[10px] md:text-xs">
    No file loaded. Requires GRT export with ‚ÄúLoading ladder complete (all charges)‚Äù.
  </span>
</div>
<div class="flex flex-wrap items-center gap-3 mt-1">
  <label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
    <input id="exportAdvancedDiagnostics" type="checkbox" class="rounded border-grt-frame bg-grt-panel-soft" checked />
    <span>Export ‚ÄúAdvanced Diagnostics‚Äù dashboard (single tab)</span>
  </label>
  <label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
    <input id="exportSimOverlays" type="checkbox" class="rounded border-grt-frame bg-grt-panel-soft" checked />
    <span>Enable Sim overlays (Pressure / Barrel Time / Optimal BT)</span>
  </label>
  <label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
    <input id="alsoExportIndividualOverlays" type="checkbox" class="rounded border-grt-frame bg-grt-panel-soft" />
    <span>Also export individual overlay pictures</span>
  </label>
</div>
<div class="flex flex-wrap items-center gap-2 mt-1">
  <span class="text-grt-soft text-xs md:text-sm font-semibold">Peak pressure ‚Äúsoft limit‚Äù:</span>
  <input id="softLimitPsi" type="number" inputmode="numeric" placeholder="e.g. 62000"
         class="px-2.5 py-1.5 rounded-lg bg-grt-panel text-white text-xs md:text-sm border border-grt-frame focus:outline-none focus:ring-2 focus:ring-[var(--grt-accent)] focus:border-[var(--grt-accent)] w-36"/>
  <span class="text-grt-subtle text-[11px] md:text-xs">psi (optional)</span>
</div>


</div>
</div>
<!-- Ladder rows -->
<div class="grid grid-cols-1 md:grid-cols-1 gap-2 mb-3" id="ladderRows"></div>
<div class="flex justify-end">
<button class="px-4 py-2 bg-[var(--grt-accent)] hover:bg-[var(--grt-accent-soft)] text-white rounded-lg text-xs md:text-sm font-semibold shadow-md border border-grt-accent transition-transform transform hover:-translate-y-0.5 hover:shadow-lg opacity-60 cursor-not-allowed" disabled="" id="processLadderBtn" type="button">
                                        Process Ladder
                                    </button>
</div>
</div>
</div>
<!-- /Ladder panel -->
</div>
</div>
</div>
</section>
<!-- Changelog panel (small text) ‚Äì below "What this tool does" -->
<!-- Results -->
<section aria-label="Import results" class="hidden space-y-5 md:space-y-6 mt-4" id="resultsArea">
<!-- Run summary card -->
<div class="bg-grt-panel-soft rounded-2xl border border-grt-frame p-4" id="runSummaryCard">
<h3 class="text-white text-sm md:text-base font-semibold mb-2">
                    üìå Run summary
                </h3>
<div class="grid grid-cols-1 md:grid-cols-3 gap-x-4 gap-y-1 text-[11px] md:text-xs text-grt-subtle">
<div>Files: <span class="text-grt-soft font-semibold" id="summaryFiles">0</span></div>
<div>Total shots: <span class="text-grt-soft font-semibold" id="summaryShots">0</span></div>
<div>Chronograph: <span class="text-grt-soft font-semibold" id="summaryDevice">‚Äì</span></div>
<div>Mode: <span class="text-grt-soft font-semibold" id="summaryMode">‚Äì</span></div>
<div>File unit: <span class="text-grt-soft font-semibold" id="summaryUnit">‚Äì</span></div>
<div>Base .grtload: <span class="text-grt-soft font-semibold" id="summaryBase">Not loaded</span></div>
</div>
<div class="mt-2 text-[11px] md:text-xs text-grt-soft" id="summaryBestNode">
                    ‚≠ê Best node: <span class="text-grt-subtle">Not determined yet.</span>
</div>
<!-- Add-ons loaded summary -->
<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame mb-5 hidden" id="addonsLoadedCard">
  <h3 class="text-white text-sm md:text-base font-semibold mb-2">üß© Add-ons loaded</h3>
  <p class="text-grt-subtle text-[11px] md:text-xs mb-4">These will be exported as appendix tabs in the generated <span class="font-mono">.grtload</span>.</p>

    <div class="grid grid-cols-1 gap-4">
    <div>
      <div class="text-white text-xs md:text-sm font-semibold mb-2">ShotMarker</div>
      <div id="shotMarkerResultsCards" class="space-y-2"></div>
      <div id="shotMarkerSessionCards" class="mt-3"></div>
    </div>
  </div>

<!-- Quick actions: copy summary / export / advanced -->
<div class="flex flex-wrap items-center justify-between gap-2 md:gap-3 mb-3" id="quickActionsRow">
<div class="flex flex-wrap items-center gap-2 text-[11px] md:text-xs text-grt-subtle">
<span>Quick actions</span>
</div>
<div class="flex flex-wrap items-center gap-2">
<button class="inline-flex items-center gap-1 px-3 py-1.5 rounded-full bg-grt-panel-soft border border-grt-frame text-[11px] md:text-xs text-grt-soft hover:bg-grt-highlight transition" onclick="copySessionSummary()" type="button">
<span>üìã</span>
<span>Copy summary</span>
</button>
<button class="inline-flex items-center gap-1 px-3 py-1.5 rounded-full bg-grt-panel-soft border border-emerald-600/70 text-[11px] md:text-xs text-emerald-200 hover:bg-emerald-700/40 transition" onclick="downloadGRT()" type="button">
<span>üíæ</span>
<span>Export .grtload</span>
</button>

<button class="inline-flex items-center gap-1 px-3 py-1.5 rounded-full bg-grt-panel-soft border border-grt-frame text-[11px] md:text-xs text-grt-soft hover:bg-grt-highlight transition" id="saveSessionBtn" type="button" title="Save the current imported data (chronograph + add-ons + analysis state) so you can reload it later without GRT.">
  <span>üßæ</span><span>Save session</span>
</button>
<button class="inline-flex items-center gap-1 px-3 py-1.5 rounded-full bg-grt-panel-soft border border-grt-frame text-[11px] md:text-xs text-grt-soft hover:bg-grt-highlight transition" onclick="document.getElementById('standaloneJsonInput').click()" type="button" title="Load a previously saved session (.json) from this tool.">
  <span>üìÇ</span><span>Load session</span>
</button>
<input id="standaloneJsonInput" type="file" accept=".json" class="hidden" onchange="importStandaloneJsonFile(this.files && this.files[0])"/>

</div>
</div>
<!-- Analysis Dashboard -->
<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame mb-5 hidden" id="analysisDashboard">
<div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
<div>
<h2 class="text-xl font-bold text-white flex items-center gap-2">
                üîß Analysis Dashboard
            </h2>
<p class="text-grt-subtle text-xs md:text-sm">
                Set your SD / ES targets and toggle extended metrics. These settings affect badges and best-node selection.
            </p>
</div>
<div class="flex flex-wrap items-center gap-3">
<div class="flex items-center gap-1">
<label class="text-grt-soft text-xs md:text-sm font-semibold" for="analysisTargetSD">
                    Target SD
                </label>
<input class="w-20 px-2 py-1 rounded border border-grt-frame bg-grt-panel-soft text-xs md:text-sm text-white focus:outline-none focus:ring-1 focus:ring-grt-accent" id="analysisTargetSD" step="0.1" title="Target SD threshold for flagging groups as tight or wide." type="number"/>
</div>
<div class="flex items-center gap-1">
<label class="text-grt-soft text-xs md:text-sm font-semibold" for="analysisTargetES">
                    Target ES
                </label>
<input class="w-20 px-2 py-1 rounded border border-grt-frame bg-grt-panel-soft text-xs md:text-sm text-white focus:outline-none focus:ring-1 focus:ring-grt-accent" id="analysisTargetES" step="0.1" title="Target ES threshold for flagging groups as tight or wide." type="number"/>
</div>
</div>

<div class="flex items-center gap-2">
  <span class="text-grt-soft text-xs md:text-sm font-semibold">ShotMarker Phase 3:</span>
  <label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
    <span>String ratio</span>
    <input id="smP3RatioDom" type="number" step="0.05" class="w-20 px-2 py-1 rounded border border-grt-frame bg-grt-panel-soft text-xs md:text-sm text-white focus:outline-none focus:ring-1 focus:ring-grt-accent" />
  </label>
  <label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
    <span>Min MOA</span>
    <input id="smP3StringMoaMin" type="number" step="0.01" class="w-20 px-2 py-1 rounded border border-grt-frame bg-grt-panel-soft text-xs md:text-sm text-white focus:outline-none focus:ring-1 focus:ring-grt-accent" />
  </label>
  <button id="smP3ResetBtn" type="button" class="px-2.5 py-1 rounded-md bg-grt-panel-soft border border-grt-frame text-[11px] md:text-xs text-grt-soft hover:bg-grt-highlight transition" title="Reset Phase 3 thresholds to defaults">
    Reset
  </button>
</div>


</div>
<div class="flex flex-col lg:flex-row gap-4">
<div class="flex-1 flex flex-col gap-2">
<div class="flex flex-wrap items-center gap-3">
<span class="text-grt-soft text-[11px] md:text-xs font-semibold uppercase tracking-wide">
                    Extended metrics
                </span>
                <!-- Extended metrics help chip -->
                <button
                  id="extendedMetricsHelpBtn"
                  type="button"
                  class="inline-flex items-center justify-center h-5 w-5 rounded-full
                         bg-grt-panel-soft border border-grt-frame text-[10px] text-grt-soft
                         hover:bg-grt-highlight hover:text-white transition"
                  title="What do these extra metrics mean?"
                >
                  ?
                </button>
<label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
<input class="rounded border-grt-frame bg-grt-panel-soft" id="analysisShow95Band" title="Show the ¬±1.96 SD band (about 95% of shots) in analysis." type="checkbox"/>
<span>¬±95% SD band</span>
</label>
<label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
<input class="rounded border-grt-frame bg-grt-panel-soft" id="analysisShowMAD" title="Include Median Absolute Deviation (MAD) in the analysis metrics." type="checkbox"/>
<span>MAD</span>
</label>
<label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
<input class="rounded border-grt-frame bg-grt-panel-soft" id="analysisShowCV" title="Include coefficient of variation (SD divided by mean) in the analysis metrics." type="checkbox"/>
<span>CV%</span>
</label>
<label class="inline-flex items-center gap-1 text-grt-subtle text-[11px] md:text-xs">
<input class="rounded border-grt-frame bg-grt-panel-soft" id="analysisShowESD" title="Include ESD (ES divided by SD) in the analysis metrics." type="checkbox"/>
<span>ESD (ES/4)</span>
</label>
</div>
<div
    id="extendedMetricsHelpCard"
    class="hidden mt-2 bg-grt-panel-soft border border-grt-frame rounded-xl p-3
           text-[11px] md:text-xs text-grt-soft max-w-xl"
>
    <h4 class="text-white font-semibold mb-2 text-xs md:text-sm">
        Extended metrics ‚Äì quick explainer
    </h4>
    <ul class="list-disc list-inside space-y-1.5">
        <li>
            <span class="font-semibold">¬±95% SD band</span> ‚Äì
            Mean ¬± 1.96 √ó SD. Roughly where about 95% of shots should land
            if your velocity is behaving nicely. Good for visualizing your
            ‚Äúnormal‚Äù speed window.
        </li>
        <li>
            <span class="font-semibold">MAD (Median Absolute Deviation)</span> ‚Äì
            A robust version of spread. Like SD but much less sensitive to
            that one weird slow/fast shot. Lower MAD = more consistent.
        </li>
        <li>
            <span class="font-semibold">CV%</span> (Coefficient of Variation) ‚Äì
            SD √∑ mean √ó 100. Lets you compare consistency between loads with
            different average speeds (e.g., 2800 vs 3000 ft/s).
        </li>
        <li>
            <span class="font-semibold">ESD (ES/4)</span> ‚Äì
            Rule-of-thumb ‚Äúestimated SD‚Äù from extreme spread:
            SD ‚âà ES √∑ 4 for typical 5‚Äì10 shot strings. Good sanity check:
            if SD and ES/4 wildly disagree, something odd is going on.
        </li>
    </ul>
    <p class="mt-2 text-grt-subtle">
        Tip: these metrics don‚Äôt replace SD/ES ‚Äî they just give you more
        ways to spot stable nodes and weird outliers.
    </p>
</div>
</div>
<div class="w-full lg:w-64 flex flex-col gap-2">
<label class="text-grt-soft text-[11px] md:text-xs font-semibold uppercase tracking-wide" for="analysisBestNodeMode">
                Best node selection
            </label>
<select class="w-full px-2.5 py-1.5 rounded border border-grt-frame bg-grt-panel-soft text-xs md:text-sm text-white focus:outline-none focus:ring-1 focus:ring-grt-accent" id="analysisBestNodeMode" title="How the tool chooses the best velocity node based on your thresholds.">
<option value="sd">Min SD (within targets)</option>
<option value="es">Min ES (within targets)</option>
<option value="weighted">Weighted SD + ES</option>
</select>
<div class="text-grt-subtle text-[11px] md:text-xs leading-snug" id="analysisBestNodeSummary" title="Short text summary of the best node chosen from your data.">
                Best node will be highlighted after stats are computed.
            </div>
</div>
</div>
</div>
<!-- Analysis Dashboard -->

<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame">
<div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
  <h2 class="text-xl font-bold text-white">
    üìä Files Processed: <span id="fileCount">0</span>
  </h2>
  <div class="flex flex-col gap-1 md:items-start">
    <div class="flex flex-wrap items-center gap-2">
      <span class="text-grt-subtle text-xs md:text-sm">File stats unit:</span>
      <span class="inline-flex items-center px-2.5 py-1 rounded-full text-xs md:text-sm border border-grt-frame-soft bg-grt-panel-soft/70 text-grt-soft font-medium" id="resultsUnit" title="Velocity unit used in tables, charts, and exported notes.">
         
      </span>
    </div>
    <div class="flex flex-col md:flex-row md:items-center gap-2 text-[10px] md:text-xs text-grt-subtle">
      <span>GRT internally uses m/s for imported shots.</span>
      <div class="flex flex-wrap items-center gap-2">
        <span class="inline-flex items-center gap-1">
          <span class="h-1.5 w-1.5 rounded-full bg-emerald-400"></span>
          <span>Within target</span>
        </span>
        <span class="inline-flex items-center gap-1">
          <span class="h-1.5 w-1.5 rounded-full bg-sky-400"></span>
          <span>Partial hit</span>
        </span>
        <span class="inline-flex items-center gap-1">
          <span class="h-1.5 w-1.5 rounded-full bg-rose-400"></span>
          <span>Outside / wide</span>
        </span>
      </div>
    </div>
  </div>
</div>

</div>
<div class="grid grid-cols-1 md:grid-cols-1 lg:grid-cols-3 gap-4" id="statsGrid"></div>
</div>
<div class="bg-grt-panel rounded-2xl shadow-xl p-5 md:p-6 border border-grt-frame">
<div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
<h2 class="text-xl font-bold text-white flex items-center gap-2">
                        üìÑ GRT File (.grtload)
                    </h2>
<button class="px-5 py-2.5 bg-emerald-600 hover:bg-emerald-500 text-white rounded-lg text-sm font-semibold shadow-md border border-emerald-500/80 transition-transform transform hover:-translate-y-0.5 hover:shadow-lg" onclick="downloadGRT()">
                        Download .grtload
                    </button>
</div>
<div class="bg-emerald-950/70 border border-emerald-700/70 rounded-xl p-4">
<h3 class="text-white font-semibold mb-2 text-sm md:text-base">‚úÖ How to use in GRT</h3>
<ol class="text-emerald-200 text-xs md:text-sm space-y-1.5 list-decimal list-inside">
<li>Download the generated <code class="bg-emerald-900/70 px-1 rounded text-[11px]">.grtload</code> file.</li>
<li>Open GRT and go to <strong>File ‚Üí Open</strong>.</li>
<li>Standard mode: use the <strong>Imported Measurement</strong> tab.</li>
<li>Ladder mode: use the <strong>Imported Ladder</strong> tab; original ladder is unchanged.</li>
<li>If used, view <strong>Imported Pictures</strong> and <strong>Imported Notes</strong> tabs.</li>
<li>Check charge notes for AVG-E / SD / ES / MIN / MAX / UNIT.</li>
<li>Check individual shots for PF and Time notes when present in the chrono file.</li>
</ol>
</div>
</div>
<!-- Advanced diagnostics pane -->


</main>
<div class="max-w-5xl mx-auto pb-10">
<!-- Footer / What this tool does -->
<div class="hidden text-emerald-300 text-amber-300 text-rose-300"></div>

<div id="footerWhatToolDoes" class="bg-grt-panel-soft rounded-2xl border border-grt-frame p-4 md:p-4 mt-6">
  <div class="flex flex-col md:flex-row md:items-start md:justify-between gap-4">
    <div class="md:max-w-[60%]">
      <h4 class="text-white font-semibold mb-2 text-xs md:text-sm flex items-center gap-2">
        <span class="opacity-90">üí°</span> What this tool does
      </h4>
      <p class="text-grt-soft text-[11px] md:text-xs leading-relaxed">
        Converts chronograph strings into ready-to-use GRT measurements while keeping your base project intact.
      </p>
    </div>

    <div class="md:max-w-[40%]">
      <ul class="space-y-2 text-[11px] md:text-xs text-grt-soft leading-snug">
        <li class="flex items-start gap-2">
          <span class="inline-flex items-center justify-center w-4 h-4 rounded bg-emerald-500/20 border border-emerald-500/40 text-emerald-300">‚úì</span>
          <span>Garmin Xero &amp; Athlon Rangecraft support</span>
        </li>
        <li class="flex items-start gap-2">
          <span class="inline-flex items-center justify-center w-4 h-4 rounded bg-emerald-500/20 border border-emerald-500/40 text-emerald-300">‚úì</span>
          <span>Standard, Ladder &amp; Measurements Sessions modes</span>
        </li>
        <li class="flex items-start gap-2">
          <span class="inline-flex items-center justify-center w-4 h-4 rounded bg-emerald-500/20 border border-emerald-500/40 text-emerald-300">‚úì</span>
          <span>Metric/imperial file units ‚Üí GRT m/s</span>
        </li>
        <li class="flex items-start gap-2">
          <span class="inline-flex items-center justify-center w-4 h-4 rounded bg-emerald-500/20 border border-emerald-500/40 text-emerald-300">‚úì</span>
          <span>Charge notes: AVG‚ÄëE / SD / ES / MIN / MAX / UNIT</span>
        </li>
        <li class="flex items-start gap-2">
          <span class="inline-flex items-center justify-center w-4 h-4 rounded bg-emerald-500/20 border border-emerald-500/40 text-emerald-300">‚úì</span>
          <span>Per‚Äëshot notes when PF &amp; time are present</span>
        </li>
        <li class="flex items-start gap-2">
          <span class="inline-flex items-center justify-center w-4 h-4 rounded bg-emerald-500/20 border border-emerald-500/40 text-emerald-300">‚úì</span>
          <span>Optional Imported Pictures &amp; Imported Notes tabs</span>
        </li>
      </ul>
    </div>
  </div>
</div>

<!-- Changelog panel (small text) ‚Äì below "What this tool does" -->
<div class="mt-6 flex justify-center">
  <div class="inline-flex items-center gap-2 rounded-full px-4 py-2 bg-grt-panel-soft border border-grt-accent shadow-lg">
    <span class="h-1.5 w-1.5 rounded-full bg-emerald-400 animate-pulse"></span>
    <span class="text-[11px] md:text-xs text-grt-soft tracking-wide uppercase">Made for GRT group</span>
  </div>
</div>
</div>

<script>
        // =======================
        // Constants / state
        // =======================
        const VELOCITY_MIN = 200;
        const VELOCITY_MAX = 5000;
        const HEADER_SCAN_ROWS = 15;
        const CSV_HEADER_SCAN_LINES = 8;
        const HEADER_PATTERNS = [
            'velocity', 'velocit', 'vel', 'm/s', 'ft/s', 'fps', 'mps'
        ];
        const DEFAULT_NOTE_CONFIG = '%7Bedit%2C17%2C6%2C-1%2C-1%2C-1%2C-1%2C0%2C0%7D';

        const CONFIG = {
            sdBands: [
                {
                    max: 10,
                    label: 'Tight',
                    key: 'tight',
                    chipClass: 'bg-emerald-900/80 text-emerald-200 border-emerald-500/60',
                    dotClass: 'bg-emerald-400',
                    barColor: '#22c55e'
                },
                {
                    max: 20,
                    label: 'OK',
                    key: 'ok',
                    chipClass: 'bg-amber-900/80 text-amber-200 border-amber-500/60',
                    dotClass: 'bg-amber-400',
                    barColor: '#fbbf24'
                },
                {
                    max: Infinity,
                    label: 'Wide',
                    key: 'wide',
                    chipClass: 'bg-red-900/80 text-red-200 border-red-500/60',
                    dotClass: 'bg-red-400',
                    barColor: '#f97373'
                }
            ]
        };

        let grtBaseContent = null;
        let grtBaseFilename = '';
        let outputXML = '';
        let allStats = [];

        let shotMarkerManualMap = {};          // sessionKey -> chargeIndex (manual override)
                let shotMarkerScoreSettings = null;      // optional override for scoring params
        
                const LS_SM_MANUAL_MAP = 'xqa_smManualMap_v1';
                const LS_SM_SCORE_SETTINGS = 'xqa_smScoreSettings_v1';
        
                function _loadShotMarkerPrefs() {
                    try {
                        const m = localStorage.getItem(LS_SM_MANUAL_MAP);
                        if (m) shotMarkerManualMap = JSON.parse(m) || {};
                    } catch {}
                    try {
                        const s = localStorage.getItem(LS_SM_SCORE_SETTINGS);
                        if (s) shotMarkerScoreSettings = JSON.parse(s) || null;
                    } catch {}
                }
        
                function _saveShotMarkerManualMap() {
                    try { localStorage.setItem(LS_SM_MANUAL_MAP, JSON.stringify(shotMarkerManualMap || {})); } catch {}
                }
                
                
                function onSmChargeLinkChange(selEl){
                    try{
                        const keyEnc = selEl.getAttribute('data-sm-key') || '';
                        const sessionKey = decodeURIComponent(keyEnc);
                        const v = selEl.value;
                        if (!shotMarkerManualMap) shotMarkerManualMap = {};
                        if (v === '' || v == null){
                            // Auto
                            delete shotMarkerManualMap[sessionKey];
                        } else {
                            shotMarkerManualMap[sessionKey] = Number(v);
                        }
                        _saveShotMarkerManualMap();
                        try{ showToast(`Linked: ${sessionKey.split('|')[1]||'session'} ‚Üí Charge ${v||'‚Äî'}`,'ok'); }catch(_e){}
                        // re-render so badges + node confidence update immediately
                        renderShotMarkerSessionCards();
                    }catch(e){
                        console.error(e);
                    }
                }

                function smLockAutoLinksToManual(sessions){
                    try{
                        let arr = Array.isArray(sessions) ? sessions : [];
                        if (!arr.length){
                            try { arr = (shotMarkerAddons && shotMarkerAddons[0] && Array.isArray(shotMarkerAddons[0].sessions)) ? shotMarkerAddons[0].sessions : []; } catch(e) { arr = []; }
                        }

                        if (!shotMarkerManualMap) shotMarkerManualMap = {};
                        // Ensure auto-matches are computed
                        mapShotMarkerSessionsToChronoCharges(arr);
                        let locked = 0;
                        for (const s of arr){
                            if (!s) continue;
                            const key = (s.meta && s.meta.sessionKey) ? s.meta.sessionKey : _smSessionKey(s);
                            const d = s.derived || {};
                            const cm = d.chargeMatch || null;
                            const autoIdx = (cm && isFinite(cm.chargeIndex)) ? Number(cm.chargeIndex) : null;
                            if (autoIdx === null) continue;
                            // Only lock if not already manually set
                            if (shotMarkerManualMap[key] == null){
                                shotMarkerManualMap[key] = autoIdx;
                                locked++;
                            }
                        }
                        _saveShotMarkerManualMap();
                        renderShotMarkerSessionCards();
                        if (typeof showStatus === 'function'){
                            showStatus('success', locked ? `Locked ${locked} auto link${locked===1?'':'s'} to charges.` : 'No auto links to lock (nothing matched yet).');
                        }
                    }catch(e){
                        console.error(e);
                        if (typeof showStatus === 'function') showStatus('error', 'Lock auto links failed: ' + (e?.message || e));
                    }
                }

// ShotMarker Phase 3 tuning (persisted)
let smPhase3Config = { ratioDom: 1.60, stringMoaMin: 0.35 };
const LS_SM_P3_CONFIG = 'xqa_smPhase3Config_v1';

function _loadSmPhase3Config(){
  try{
    const s = localStorage.getItem(LS_SM_P3_CONFIG);
    if(s){
      const o = JSON.parse(s);
      if(o && typeof o === 'object'){
        if(Number.isFinite(Number(o.ratioDom))) smPhase3Config.ratioDom = Number(o.ratioDom);
        if(Number.isFinite(Number(o.stringMoaMin))) smPhase3Config.stringMoaMin = Number(o.stringMoaMin);
      }
    }
  }catch(_e){}
}

function _saveSmPhase3Config(){
  try{ localStorage.setItem(LS_SM_P3_CONFIG, JSON.stringify(smPhase3Config||{})); }catch(_e){}
}

function _bindSmPhase3Controls(){
  const ratioEl = document.getElementById('smP3RatioDom');
  const moaEl   = document.getElementById('smP3StringMoaMin');
  const resetEl = document.getElementById('smP3ResetBtn');
  if(ratioEl){ ratioEl.value = String(smPhase3Config.ratioDom); }
  if(moaEl){ moaEl.value = String(smPhase3Config.stringMoaMin); }

  const onChange = ()=>{
    if(ratioEl && ratioEl.value !== '') smPhase3Config.ratioDom = Number(ratioEl.value);
    if(moaEl && moaEl.value !== '') smPhase3Config.stringMoaMin = Number(moaEl.value);
    _saveSmPhase3Config();
    try{ renderShotMarkerSessionCards(); }catch(_e){}
  };
  if(ratioEl) ratioEl.addEventListener('change', onChange);
  if(moaEl) moaEl.addEventListener('change', onChange);

  if(resetEl){
    resetEl.addEventListener('click', ()=>{
      smPhase3Config = { ratioDom: 1.60, stringMoaMin: 0.35 };
      _saveSmPhase3Config();
      if(ratioEl) ratioEl.value = String(smPhase3Config.ratioDom);
      if(moaEl) moaEl.value = String(smPhase3Config.stringMoaMin);
      try{ renderShotMarkerSessionCards(); }catch(_e){}
      try{ showToast('Phase 3 thresholds reset.','ok'); }catch(_e){}
    });
  }
}

function _saveShotMarkerScoreSettings() {
                    try { localStorage.setItem(LS_SM_SCORE_SETTINGS, JSON.stringify(shotMarkerScoreSettings || null)); } catch {}
                }
        
                function _smSessionKey(s) {
                    const m = (s && s.meta) ? s.meta : {};
                    const parts = [
                        m.dateText || '',
                        m.relay || '',
                        m.label || '',
                        m.img || '',
                        m.targetName || ''
                    ];
                    return parts.map(x => String(x||'').trim()).join('|');
                }
        
                function _hydrateShotMarkerPrefsFromBase(grtText) {
                    // Prefer hidden XML attributes; fall back to legacy plain-text markers.
                    const t = String(grtText || '');
                    const a1 = t.match(/xqa_sm_manual_map="([^"]+)"/i);
                    const a2 = t.match(/xqa_sm_score_settings="([^"]+)"/i);
                    const m1 = t.match(/XQA_SM_MANUAL_MAP:([A-Za-z0-9+/=]+)/);
                    const m2 = t.match(/XQA_SM_SCORE_SETTINGS:([A-Za-z0-9+/=]+)/);
                    const mapB64 = (a1 && a1[1]) ? a1[1] : (m1 && m1[1] ? m1[1] : null);
                    const setB64 = (a2 && a2[1]) ? a2[1] : (m2 && m2[1] ? m2[1] : null);
                    try {
                        if (mapB64) {
                            const jsonStr = atob(mapB64);
                            const obj = JSON.parse(jsonStr);
                            if (obj && typeof obj === 'object') {
                                shotMarkerManualMap = obj;
                                _saveShotMarkerManualMap();
                            }
                        }
                    } catch {}
                    try {
                        if (setB64) {
                            const jsonStr = atob(setB64);
                            const obj = JSON.parse(jsonStr);
                            shotMarkerScoreSettings = obj || null;
                            _saveShotMarkerScoreSettings();
                        }
                    } catch {}
                }
        
        _loadShotMarkerPrefs();
        _loadSmPhase3Config();
        try{ setTimeout(_bindSmPhase3Controls, 0); }catch(_e){}

        let unit = 'imperial';          // file unit: imperial(ft/s) or metric(m/s)
        let chronographType = 'garmin'; // 'garmin' or 'athlon'
        let mode = 'normal';            // 'normal', 'ladder', or 'sessions'
        let sessionsLayout = 'compact'; // 'compact' or 'legacy'

        
        let ladderNameMode = 'filename'; // 'filename' or 'charge'
        let ladderSteps = 10;

        let analysisConfig = {
            targetSD: 15,
            targetES: 30,
            show95Band: true,
            showMAD: true,
            showCV: true,
            showESD: true,
            includeInNotes: false,
            bestNodeMode: 'sd' // 'sd', 'es', 'weighted'
        };
        let grtLadderSteps = null;
        let ladderDisabled = false;

        let defaultMcValue = '0.002';
        let ladderStepMassG = null;

        // Top stepper state
        let currentStep = 1;
        let bestNodeIndex = -1;
        let lastBestNodeIndex = -1;

        function updateTopStepper() {
            const container = document.getElementById('topStepper');
            if (!container) return;
            const steps = container.querySelectorAll('li[data-step]');
            steps.forEach((li) => {
                const stepNum = parseInt(li.dataset.step || '0', 10);
                const circle = li.querySelector('.step-circle');
                if (!circle) return;
                circle.classList.remove('step-circle--active', 'step-circle--done');
                if (stepNum < currentStep) {
                    circle.classList.add('step-circle--done');
                } else if (stepNum === currentStep) {
                    circle.classList.add('step-circle--active');
                }
            });
        }

        function setCurrentStep(step) {
            const clamped = Math.max(1, Math.min(4, step | 0));
            if (clamped === currentStep) return;
            currentStep = clamped;
            updateTopStepper();
        }

        // Initialize stepper at step 1
        updateTopStepper();


        const ladderSlots = new Array(10).fill(null); // ladderSlots[i] = { stats, filename, chargeIndex }

        // Imported Pictures & Notes
        let importedPictures = [];    // { filename, name, type, width, height, data }
        let importedNotesText = '';   // plain text, encoded later
        let analysisNoteText = '';

        // Optional Add-ons: ShotMarker
        let shotMarkerAddons = [];   // [{ filename, rows, shots, metrics, rawText }]
    // auto-built analysis summary for Appendix
        
// --- GRT Simulation Export (JSON) integration (stable) ---
let grtSimLadderRows = null;          // normalized ladder rows [{chargeGr, mv, peakPsi, btMs, obtMs, units}]
let grtSimSeriesForChart = null;      // array aligned to C1..CN in current unit (ft/s or m/s)
let grtSimPressurePsi = null;         // array aligned
let grtSimBarrelTimeMs = null;        // array aligned
let grtSimOptimalBTMs = null;         // array aligned

function parseValueUnit(str) {
  if (typeof str !== 'string') return { value: NaN, unit: '' };
  const m = str.trim().match(/^(-?\d+(?:\.\d+)?)\s*([^\s].*)?$/);
  if (!m) return { value: NaN, unit: '' };
  return { value: parseFloat(m[1]), unit: (m[2] || '').trim() };
}

function toGrains(v, unit) {
  if (!isFinite(v)) return NaN;
  const u = (unit || '').toLowerCase();
  if (u.includes('grain') || u === 'gr') return v;
  // fallback: assume grains
  return v;
}

function toFps(v, unit) {
  if (!isFinite(v)) return NaN;
  const u = (unit || '').toLowerCase();
  if (u.includes('m/s') || u.includes('mps')) return v * 3.28084;
  return v; // ft/s assumed
}

function detectChartUnit() {
  const unit = (typeof garminVelocityUnit === 'string') ? garminVelocityUnit : '';
  return (unit === 'mps' || unit === 'm/s') ? 'm/s' : 'ft/s';
}

function fpsToChart(vFps) {
  if (!isFinite(vFps)) return NaN;
  return (detectChartUnit() === 'm/s') ? (vFps / 3.28084) : vFps;
}

function normalizeSimJson(jsonObj) {
  const ladder = Array.isArray(jsonObj?.ladder) ? jsonObj.ladder : null;
  if (!ladder || !ladder.length) return null;
  const out = [];
  for (const row of ladder) {
    const ch = parseValueUnit(row?.charge || '');
    const mv = parseValueUnit(row?.results?.MuzzleVelocity || row?.MuzzleVelocity || '');
    const pp = parseValueUnit(row?.results?.PeakPressure || row?.PeakPressure || '');
    const bt = parseValueUnit(row?.results?.BarrelTime || row?.BarrelTime || '');
    const obt = parseValueUnit(row?.results?.OptimalBarrelTime || row?.OptimalBarrelTime || '');
    const chargeGr = toGrains(ch.value, ch.unit);
    const mvFps = toFps(mv.value, mv.unit);
    const peakPsi = pp.value; // already psi in imperial projects; if metric, we leave as numeric but label will still say psi; future: convert.
    out.push({ chargeGr, mvFps, peakPsi, btMs: bt.value, obtMs: obt.value });
  }
  // sort ascending by charge for C1..CN mapping
  out.sort((a,b)=> (a.chargeGr||0) - (b.chargeGr||0));
  return out;
}

function updateSimStatus(text, good) {
  const el = document.getElementById('grtSimJsonStatus');
  if (!el) return;
  el.textContent = text;
  el.classList.toggle('text-emerald-300', !!good);
  el.classList.toggle('text-rose-300', !good);
  el.classList.toggle('text-grt-subtle', false);
}
// --- /GRT Simulation Export (JSON) integration ---

let chronoSimPngData = '';
        let chronoSimImageWidth = 0;
        let chronoSimImageHeight = 0;

        function shouldExportChronoSimTab() {
            const cb = document.getElementById('ladderIncludeChronoSim');
            return (mode === 'ladder' || mode === 'sessions') && !!(cb && cb.checked);
        }

        function ensureChronoSimPngData() {
            // If we already have PNG cached, keep it
            if (chronoSimPngData && chronoSimImageWidth && chronoSimImageHeight) return true;

            // Try to grab the currently-rendered canvas (if present)
            const canvas = document.getElementById('chronoSimChart');
            if (!canvas || !canvas.toDataURL) return false;

            try {
                chronoSimImageWidth = Math.round(canvas.width || canvas.clientWidth || 0);
                chronoSimImageHeight = Math.round(canvas.height || canvas.clientHeight || 0);
                const dataUrl = canvas.toDataURL('image/png');
                chronoSimPngData = dataUrl.replace(/^data:image\/png;base64,/, '');
                return !!chronoSimPngData;
            } catch (e) {
                // If the canvas isn't ready for any reason, just skip exporting this tab.
                return false;
            }
        }

        // =======================
        // Utility functions
        // =======================
        function unitLabel() {
            return unit === 'imperial' ? 'ft/s' : 'm/s';
        }

        function fpsToMps(v) {
            return v / 3.28084;
        }

        function parseNumber(value) {
            if (value === undefined || value === null) return NaN;
            return parseFloat(String(value).replace(',', '.'));
        }

        function isValidNumber(value) {
            return typeof value === 'number' && !isNaN(value);
        }

        
        function computeStats(velocities) {
            if (!velocities.length) {
                throw new Error('No valid velocity data found');
            }
            const count = velocities.length;
            const mean = velocities.reduce((a, b) => a + b, 0) / count;
            const variance = velocities.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / count;
            const sd = Math.sqrt(variance);
            const min = Math.min(...velocities);
            const max = Math.max(...velocities);
            const es = max - min;

            // Extended stats
            const sorted = [...velocities].sort((a, b) => a - b);
            let median;
            if (count % 2 === 1) {
                median = sorted[(count - 1) / 2];
            } else {
                const mid1 = sorted[count / 2 - 1];
                const mid2 = sorted[count / 2];
                median = (mid1 + mid2) / 2;
            }
            const absDevs = sorted.map((v) => Math.abs(v - median)).sort((a, b) => a - b);
            let mad;
            if (count % 2 === 1) {
                mad = absDevs[(count - 1) / 2];
            } else {
                const midA = absDevs[count / 2 - 1];
                const midB = absDevs[count / 2];
                mad = (midA + midB) / 2;
            }
            const cvPercent = mean !== 0 ? (sd / mean) * 100 : 0;
            const low95 = mean - 1.96 * sd;
            const high95 = mean + 1.96 * sd;
            const esdFromEs = es / 4;

            return {
                count,
                mean,
                sd,
                min,
                max,
                es,
                extended: {
                    median,
                    mad,
                    cvPercent,
                    low95,
                    high95,
                    esdFromEs
                }
            };
        }

        // =======================
        // Velocity SD (explicit)
        // =======================
        function xqaFmtNum(x, digits = 1, fallback = '‚Äî') {
            const n = Number(x);
            return Number.isFinite(n) ? n.toFixed(digits) : fallback;
        }
        // Tooltip helper for score cards (safe default)
        function _xqaScoreHintTitle(row){
            try{
                const parts = [];
                if (row && typeof row.velocitySDSource === 'string' && row.velocitySDSource){
                    parts.push(`SD src: ${row.velocitySDSource}`);
                }
                // Chrono SD / ES if present (most rows)
                if (row && Number.isFinite(Number(row.sd))){
                    parts.push(`SD: ${xqaFmtNum(row.sd, 1)} fps`);
                } else if (row && Number.isFinite(Number(row.velocitySD))){
                    parts.push(`SD: ${xqaFmtNum(row.velocitySD, 1)} fps`);
                }
                if (row && Number.isFinite(Number(row.es))){
                    parts.push(`ES: ${xqaFmtNum(row.es, 1)} fps`);
                }
                if (row && Number.isFinite(Number(row.vertMOA))){
                    parts.push(`Vert: ${xqaFmtNum(row.vertMOA, 3)} MOA`);
                }
                if (row && Number.isFinite(Number(row.mrMOA))){
                    parts.push(`MR: ${xqaFmtNum(row.mrMOA, 3)} MOA`);
                }
                return parts.length ? parts.join(' ‚Ä¢ ') : 'Score details';
            }catch(_e){
                return 'Score details';
            }
        }


        // Sample SD (n-1). Returns null if <3 values.
        function xqaIsSighter(tags){ return String(tags||'').toLowerCase().includes('sighter'); }

function xqaSampleSD(values) {
            const arr = Array.isArray(values) ? values.map(Number).filter(Number.isFinite) : [];
            const n = arr.length;
            if (n < 3) return null;
            const mean = arr.reduce((a,b)=>a+b,0) / n;
            const ss = arr.reduce((a,b)=>a + (b-mean)*(b-mean), 0);
            return Math.sqrt(ss / (n - 1));
        }

        // Attach explicit SD fields to a stats object derived from a velocity array.
        // - Never silently invent SD: if <3 shots, SD becomes null and source=insufficient.
        function xqaAugmentVelocityStats(stats, velocities) {
            try {
                const vAll = Array.isArray(velocities) ? velocities.map(Number).filter(Number.isFinite) : [];
                const nAll = vAll.length;

                let velocitySD = null;
                let velocitySDSource = 'missing';

                if (nAll === 0) {
                    velocitySDSource = 'missing';
                } else if (nAll < 3) {
                    velocitySDSource = 'insufficient';
                } else {
                    velocitySD = xqaSampleSD(vAll);
                    velocitySDSource = 'computed';
                }

                if (stats && typeof stats === 'object') {
                    stats.velocitySD = velocitySD;
                    stats.velocitySDSource = velocitySDSource;
                    stats.velocityShotCount = nAll;
                    stats.velocityExcludedCount = 0; // Chrono imports have no sighters/quality yet

                    // Make "SD handling" explicit by preventing silent SD usage for n<3
                    if (velocitySDSource !== 'computed' && velocitySDSource !== 'measured') {
                        stats.sd = null;
                    } else if (Number.isFinite(velocitySD)) {
                        // Prefer sample SD for analysis/scoring going forward
                        stats.sd = velocitySD;
                    }
                }
            } catch (e) {
                console.error('xqaAugmentVelocityStats failed', e);
            }
        }

        function xqaGetVelocitySD(stats) {
            const v = stats && Number.isFinite(stats.velocitySD) ? stats.velocitySD
                      : (stats && Number.isFinite(stats.sd) ? stats.sd : null);
            const src = stats && stats.velocitySDSource ? stats.velocitySDSource
                      : (Number.isFinite(v) ? 'computed' : 'missing');
            return { v, src };
        }




        function computeAggregates(statsArray) {
            if (!Array.isArray(statsArray) || !statsArray.length) {
                return null;
            }

            let totalShots = 0;
            let sumMeans = 0;
            let sumSq = 0;
            let sumSd = 0;
            let validGroups = 0;
            let minEs = Infinity;
            let maxEs = -Infinity;

            statsArray.forEach((item) => {
                const s = item.stats || {};
                const n = s.count || 0;
                const mean = typeof s.mean === 'number' ? s.mean : NaN;
                const sd = typeof s.sd === 'number' ? s.sd : NaN;
                const es = typeof s.es === 'number' ? s.es : NaN;

                if (!n || isNaN(mean)) return;

                totalShots += n;
                sumMeans += mean * n;
                sumSq += n * (sd * sd + mean * mean);

                if (!isNaN(sd)) {
                    sumSd += sd;
                    validGroups += 1;
                }

                if (!isNaN(es)) {
                    if (es < minEs) minEs = es;
                    if (es > maxEs) maxEs = es;
                }
            });

            if (!totalShots) {
                return null;
            }

            const overallMean = sumMeans / totalShots;
            const overallE2 = sumSq / totalShots;
            const overallVar = overallE2 - overallMean * overallMean;
            const overallSd = overallVar > 0 ? Math.sqrt(overallVar) : 0;
            const avgSd = validGroups ? (sumSd / validGroups) : 0;

            return {
                totalShots,
                strings: validGroups,
                overallMean,
                overallSd,
                avgSd,
                minEs: isFinite(minEs) ? minEs : null,
                maxEs: isFinite(maxEs) ? maxEs : null
            };
        }

function showStatus(type, message) {
            const area = document.getElementById('statusArea');
            if (!area) return;

            const colors = {
                loading: 'bg-blue-950/80 border-blue-700 text-blue-100',
                error: 'bg-red-950/85 border-red-700 text-red-100',
                success: 'bg-emerald-950/80 border-emerald-700 text-emerald-100'
            };
            const icons = {
                loading: '‚è≥',
                error: '‚ö†Ô∏è',
                success: '‚úÖ'
            };

            // Clear any existing toasts so they don't stack up
            while (area.firstChild) {
                area.removeChild(area.firstChild);
            }

            const toast = document.createElement('div');
            toast.className =
                (colors[type] || colors.loading) +
                ' border rounded-xl px-3 py-2 shadow-lg flex items-start gap-2 text-xs md:text-sm pointer-events-auto transform transition ease-out duration-200 translate-y-0 opacity-100';

            toast.innerHTML = `
                <div class="text-base leading-none pt-0.5">${icons[type] || ''}</div>
                <div>${message}</div>
            `;

            area.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('opacity-0', 'translate-y-2');
                setTimeout(() => {
                    if (toast.parentNode === area) {
                        area.removeChild(toast);
                    }
                }, 250);
            }, 5000);
        }

        // Per-file status list
        function updateFileStatus(name, status, detail) {
            const list = document.getElementById('fileStatusList');
            if (!list) return;

            const existing = list.querySelector(`[data-file="${CSS.escape(name)}"]`);
            const icon = status === 'ok' ? '‚úÖ' :
                         status === 'error' ? '‚ö†Ô∏è' :
                         '‚è≥';

            const line = `
                <span class="inline-flex items-center gap-1">
                    <span>${icon}</span>
                    <span class="font-medium text-slate-100">${name}</span>
                    <span class="text-grt-subtle">‚Äì ${detail}</span>
                </span>
            `;

            const baseClass = 'px-2 py-1 rounded-md text-[11px] md:text-xs';
            let statusClass = ' bg-grt-panel-soft/40 border border-grt-frame/40';
            if (status === 'error') {
                statusClass = ' bg-red-900/40 border border-red-700/60';
            } else if (status === 'ok') {
                statusClass = ' bg-emerald-900/10 border border-emerald-700/40';
            } else if (status === 'pending') {
                statusClass = ' bg-slate-900/40 border border-slate-700/60';
            }

            if (existing) {
                existing.innerHTML = line;
                existing.className = baseClass + statusClass;
            } else {
                const div = document.createElement('div');
                div.dataset.file = name;
                div.innerHTML = line;
                div.className = baseClass + statusClass;
                list.appendChild(div);
            }
        }

        // =======================
        // Ladder UI helpers
        // =======================

        function createLadderRows() {
            const container = document.getElementById('ladderRows');
            if (!container) return;
            container.innerHTML = '';

            for (let i = 1; i <= 10; i++) {
                const row = document.createElement('div');
                row.id = 'ladderRow' + i;
                row.dataset.chargeIndex = String(i);
                row.className = 'flex items-center justify-between gap-2 text-xs md:text-sm';

                const labelSpan = document.createElement('span');
                labelSpan.className = 'text-grt-soft ladder-charge-label';
                labelSpan.dataset.role = 'ladderChargeLabel';
                labelSpan.textContent = 'Charge ' + i;

                const right = document.createElement('div');
                right.className = 'flex items-center gap-2';

                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.csv,.xls,.xlsx';
                input.className = 'hidden';
                input.id = 'ladderInput' + i;

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'px-2.5 py-1 bg-grt-panel hover:bg-grt-highlight text-white rounded-md border border-grt-frame text-[11px] md:text-xs';
                btn.textContent = 'Select File';
                btn.addEventListener('click', () => input.click());

                const fileLabel = document.createElement('span');
                fileLabel.id = 'ladderLabel' + i;
                fileLabel.className = 'text-grt-subtle text-[10px] md:text-[11px] truncate max-w-[120px] md:max-w-[160px]';

                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    const chargeIndex = i;
                    ladderSlots[chargeIndex - 1] = null;
                    if (fileLabel) fileLabel.textContent = file ? file.name : '';
                    row.classList.remove('ring-1', 'ring-red-500/70');

                    if (!file) {
                        updateProcessLadderButtonState();
                        return;
                    }

                    if (mode !== 'ladder') {
                        showStatus('error', 'Ladder files can only be used when Ladder mode is selected.');
                        e.target.value = '';
                        updateProcessLadderButtonState();
                        return;
                    }
                    if (ladderDisabled) {
                        showStatus('error', 'Loading Ladder is disabled in the base .grtload (laddercnt = 1).');
                        e.target.value = '';
                        updateProcessLadderButtonState();
                        return;
                    }

                    const uiSteps = ladderSteps || 10;
                    if (chargeIndex > uiSteps) {
                        showStatus('error', 'Charge ' + chargeIndex + ' is above the configured ladder display steps (' + uiSteps + ').');
                        e.target.value = '';
                        updateProcessLadderButtonState();
                        return;
                    }

                    showStatus('loading', 'Processing ladder file for Charge ' + chargeIndex + '‚Ä¶');

                    const isExcel = file.name.endsWith('.xls') || file.name.endsWith('.xlsx');
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            let stats;
                            if (isExcel) {
                                stats = (chronographType === 'athlon')
                                    ? processAthlonExcel(ev.target.result)
                                    : processExcel(ev.target.result);
                            } else {
                                stats = processCSV(ev.target.result);
                            }

                            ladderSlots[chargeIndex - 1] = {
                                stats,
                                filename: file.name,
                                chargeIndex
                            };

                            if (fileLabel) fileLabel.textContent = file.name;
                            row.classList.remove('ring-1', 'ring-red-500/70');

                            showStatus(
                                'success',
                                'Charge ' + chargeIndex + ' file processed. When ready, click ‚ÄúProcess Ladder‚Äù to update the GRT project.'
                            );
                        } catch (err) {
                            ladderSlots[chargeIndex - 1] = null;
                            row.classList.add('ring-1', 'ring-red-500/70');
                            showStatus(
                                'error',
                                'Error in Charge ' + chargeIndex + ' file: ' + err.message
                            );
                        }
                        updateProcessLadderButtonState();
                    };
                    if (isExcel) reader.readAsArrayBuffer(file);
                    else reader.readAsText(file);
                });

                right.appendChild(input);
                right.appendChild(btn);
                right.appendChild(fileLabel);

                row.appendChild(labelSpan);
                row.appendChild(right);
                container.appendChild(row);
            }
        }

        function updateLadderRowsVisibility() {
            const container = document.getElementById('ladderRows');
            if (!container) return;
            Array.from(container.children).forEach((row) => {
                const idx = parseInt(row.dataset.chargeIndex || '0', 10);
                if (!idx) return;
                if (idx <= ladderSteps) {
                    row.classList.remove('hidden');
                } else {
                    row.classList.add('hidden');
                    ladderSlots[idx - 1] = null;
                    const input = row.querySelector('input[type="file"]');
                    const label = row.querySelector('[id^="ladderLabel"]');
                    row.classList.remove('ring-1', 'ring-red-500/70');
                    if (input) input.value = '';
                    if (label) label.textContent = '';
                }
            });
        }

        function updateLadderChargeValueLabels() {
            const labels = document.querySelectorAll('.ladder-charge-label[data-role="ladderChargeLabel"]');
            const mcG = getMcG();

            const totalSteps =
                (typeof grtLadderSteps === 'number' && grtLadderSteps >= 2 && grtLadderSteps <= 10)
                    ? grtLadderSteps
                    : ladderSteps;

            const stepG =
                (typeof ladderStepMassG === 'number' && ladderStepMassG > 0)
                    ? ladderStepMassG
                    : null;

            labels.forEach((el) => {
                const row = el.closest('[data-charge-index]');
                if (!row) return;
                const chargeIndex = parseInt(row.dataset.chargeIndex || '0', 10);
                const baseLabel = 'Charge ' + chargeIndex;

                if (stepG && totalSteps >= 2 && chargeIndex <= totalSteps) {
                    const massG = mcG - (totalSteps - chargeIndex) * stepG;
                    const massGrains = massG * 15.43236;
                    if (isFinite(massGrains)) {
                        el.textContent = `${baseLabel} (${massGrains.toFixed(2)} gr)`;
                    } else {
                        el.textContent = baseLabel;
                    }
                } else {
                    el.textContent = baseLabel;
                }
            });
        }

        function updateLadderStateBadge() {
            const badge = document.getElementById('ladderStateBadge');
            if (!badge) return;

            let dotClass = 'bg-slate-500';
            let text = 'Base .grtload not loaded ‚Äî ladder state unknown';

            if (!grtBaseContent) {
                dotClass = 'bg-slate-500';
                text = 'Base .grtload not loaded ‚Äî ladder state unknown';
            } else if (ladderDisabled) {
                dotClass = 'bg-red-500';
                text = 'Loading Ladder disabled in base .grtload (laddercnt = 1)';
            } else if (typeof grtLadderSteps === 'number' && grtLadderSteps >= 2 && grtLadderSteps <= 10) {
                dotClass = 'bg-emerald-400';
                text = 'Loading Ladder enabled in base .grtload (' + grtLadderSteps + ' steps)';
            } else {
                dotClass = 'bg-amber-400';
                text = 'Ladder configuration not found ‚Äî using UI steps only';
            }

            badge.innerHTML = `
                <span class="h-1.5 w-1.5 rounded-full ${dotClass}"></span>
                <span>${text}</span>
            `;
        }

        function updateLadderControlsVisibility() {
            const controls = document.getElementById('ladderControls');
            if (!controls) return;

            // Only show ladder upload controls when we have a base .grtload AND it contains a real ladder (2+ steps)
            // This keeps the Ladder screen "clean" until the user loads a ladder-configured base file.
            const ladderReady =
                !!grtBaseContent &&
                !ladderDisabled &&
                (typeof grtLadderSteps === 'number') &&
                grtLadderSteps >= 2 &&
                grtLadderSteps <= 10;

            if (!ladderReady) {
                controls.classList.add('hidden');
            } else {
                controls.classList.remove('hidden');
            }
        }

        function clearLadderSlotsUI() {
            for (let i = 0; i < 10; i++) ladderSlots[i] = null;
            const container = document.getElementById('ladderRows');
            if (!container) return;
            Array.from(container.children).forEach((row) => {
                const input = row.querySelector('input[type="file"]');
                const label = row.querySelector('[id^="ladderLabel"]');
                row.classList.remove('ring-1', 'ring-red-500/70');
                if (input) input.value = '';
                if (label) label.textContent = '';
            });
        }

        function updateProcessLadderButtonState() {
            const btn = document.getElementById('processLadderBtn');
            if (!btn) return;
            const hasBase = !!grtBaseContent;
            const selectedCount = ladderSlots.filter(Boolean).length;

            const can =
                (mode === 'ladder') &&
                !ladderDisabled &&
                hasBase &&
                selectedCount >= 2;

            btn.disabled = !can;
            if (can) {
                btn.classList.remove('opacity-60', 'cursor-not-allowed');
            } else {
                btn.classList.add('opacity-60', 'cursor-not-allowed');
            }
        }

        function getMcG() {
            let v = parseFloat(defaultMcValue);
            if (!isFinite(v) || v <= 0) return 3.0;
            if (v < 0.05) {
                return v * 1000; // convert kg ‚Üí g if base is in kg
            }
            return v;
        }
        // Extract default ladder charge + step size from base .grtload (best-effort)
        function extractDefaultMcValue() {
            if (!grtBaseContent) return;

            // Base .grtload files can be XML (common) or JSON (rare). We support both.
            const raw = String(grtBaseContent);

            function toNum(x) {
                const v = parseFloat(String(x));
                return Number.isFinite(v) ? v : null;
            }

            function parseXmlInput(name) {
                const re1 = new RegExp('<input\\s+name="' + name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '"\\s+value="([^"]+)"\\s+unit="([^"]*)"', 'i');
                const m = raw.match(re1);
                if (!m) return null;
                return { value: m[1], unit: m[2] || '' };
            }

            function parseJsonField(name) {
                const re1 = new RegExp('"' + name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '"\\s*:\\s*("?)([^",\\}\\]]+)\\1', 'i');
                const m = raw.match(re1);
                if (!m) return null;
                return m[2];
            }

            // Defaults (keep existing behavior)
            let mcG = null;
            let ladderStepG = null;
            let ladderCnt = null;

            const isXml = raw.trim().startsWith('<');

            if (isXml) {
                // XML .grtload
                const mc = parseXmlInput('mc');
                const laddermc = parseXmlInput('laddermc');
                const laddercnt = parseXmlInput('laddercnt');

                if (mc) {
                    const v = toNum(mc.value);
                    if (v != null) {
                        // XML typically stores grams already (unit="g")
                        mcG = (mc.unit || '').toLowerCase() === 'kg' ? v * 1000 : v;
                    }
                }
                if (laddermc) {
                    const v = toNum(laddermc.value);
                    if (v != null) {
                        ladderStepG = (laddermc.unit || '').toLowerCase() === 'kg' ? v * 1000 : v;
                    }
                }
                if (laddercnt) {
                    const v = toNum(laddercnt.value);
                    if (v != null) ladderCnt = Math.round(v);
                }
            } else {
                // JSON-ish base (fallback)
                const mc = parseJsonField('mc');
                const laddermc = parseJsonField('laddermc');
                const laddercnt = parseJsonField('laddercnt') || parseJsonField('laddersteps');

                if (mc != null) {
                    const v = toNum(mc);
                    if (v != null) {
                        // Heuristic: if it's tiny (e.g. 0.003) treat as kg -> g, else grams.
                        mcG = v < 0.1 ? v * 1000 : v;
                    }
                }
                if (laddermc != null) {
                    const v = toNum(laddermc);
                    if (v != null) {
                        ladderStepG = v < 0.1 ? v * 1000 : v;
                    }
                }
                if (laddercnt != null) {
                    const v = toNum(laddercnt);
                    if (v != null) ladderCnt = Math.round(v);
                }
            }

            if (mcG != null) defaultMcValue = String(mcG);
            if (ladderStepG != null) ladderStepMassG = ladderStepG;
            if (ladderCnt != null) grtLadderSteps = ladderCnt;

            // Determine whether the base file actually has a ladder configured.
            // In GRT, laddercnt = 1 means Loading Ladder is effectively disabled.
            ladderDisabled = (grtLadderSteps === 1);

            // If the base provides a valid ladder step count, lock the UI to that.
            if (!ladderDisabled && typeof grtLadderSteps === 'number' && grtLadderSteps >= 2 && grtLadderSteps <= 10) {
                ladderSteps = grtLadderSteps;
                const ladderStepsSelect = document.getElementById('ladderStepsSelect');
                if (ladderStepsSelect) ladderStepsSelect.value = String(ladderSteps);
            }

            // Refresh ladder UI now that base-derived config is known.
            updateLadderRowsVisibility();
            updateLadderChargeValueLabels();
            updateLadderStateBadge();
            updateLadderControlsVisibility();
            updateProcessLadderButtonState();
            /* v0.80 resetSession finalize */
            // Re-apply ladder badge/lock + row visibility after clearing state.
            try {
                updateLadderStateBadge();
                updateLadderControlsVisibility();
                updateLadderRowsVisibility();
                updateLadderChargeValueLabels();
            } catch (e) {
                // Non-fatal: UI helpers may not exist in older builds.
            }

        }


        // =======================
        // Session & base .grtload
        // =======================

        function resetSession() {
            grtBaseContent = null;
            
            // Reset GRT Sim JSON state
            grtSimLadderRows = null;
            grtSimSeriesForChart = null;
            grtSimPressurePsi = null;
            grtSimBarrelTimeMs = null;
            grtSimOptimalBTMs = null;
            const simInput = document.getElementById('grtSimJsonInput');
            if (simInput) simInput.value = '';
            if (typeof updateSimStatus === 'function') {
                updateSimStatus('No file loaded. Requires GRT export with ‚ÄúLoading ladder complete (all charges)‚Äù.', false);
            }
            // Reset ladder config derived from base .grtload
            defaultMcValue = null;
            ladderStepMassG = null;
            grtLadderSteps = null;
// Clear base .grtload selection
            const baseInput = document.getElementById('grtBaseInput');
            const baseStatus = document.getElementById('grtBaseStatus');
            if (baseInput) baseInput.value = '';
            if (baseStatus) baseStatus.textContent = '';

            outputXML = '';
            allStats = [];
            defaultMcValue = '0.002';
            ladderStepMassG = null;
            grtLadderSteps = null;
            ladderDisabled = false;
            ladderSteps = 10;
            for (let i = 0; i < 10; i++) ladderSlots[i] = null;

            importedPictures = [];
            importedNotesText = '';
            const picInput = document.getElementById('pictureInput');
            const notesInput = document.getElementById('notesInput');
            const picStatus = document.getElementById('picturesStatus');
            const notesStatus = document.getElementById('notesStatus');
            if (picInput) picInput.value = '';
            if (notesInput) notesInput.value = '';
            if (picStatus) picStatus.textContent = 'No pictures selected';
            if (notesStatus) notesStatus.textContent = 'No notes added';

            // Reset add-ons (ShotMarker)
            shotMarkerAddons = [];
            const smInput = document.getElementById('shotMarkerInput');
            //  removed
if (smInput) smInput.value = '';            if (typeof renderAddonCards === 'function') {
                renderAddonCards();
                }


            document.getElementById('uploadArea').classList.remove('hidden');
            document.getElementById('resultsArea').classList.add('hidden');
            document.getElementById('statusArea').innerHTML = '';
            document.getElementById('fileCount').textContent = '0';
            // Clear chronograph file UI + selection (prevents "ghost" file rows after Start New Session)
            const fileStatusListEl = document.getElementById('fileStatusList');
            if (fileStatusListEl) fileStatusListEl.innerHTML = '';
            const chronoInputEl = document.getElementById('garminInput');
            if (chronoInputEl) chronoInputEl.value = '';

            document.getElementById('statsGrid').innerHTML = '';
            document.getElementById('resultsUnit').textContent = '';

            // Clear run summary
            const sFiles = document.getElementById('summaryFiles');
            const sShots = document.getElementById('summaryShots');
            const sDevice = document.getElementById('summaryDevice');
            const sMode = document.getElementById('summaryMode');
            const sUnit = document.getElementById('summaryUnit');
            const sBase = document.getElementById('summaryBase');
            if (sFiles) sFiles.textContent = '0';
            if (sShots) sShots.textContent = '0';
            if (sDevice) sDevice.textContent = '‚Äì';
            if (sMode) sMode.textContent = '‚Äì';
            if (sUnit) sUnit.textContent = '‚Äì';
            if (sBase) sBase.textContent = 'Not loaded';

            const container = document.getElementById('ladderRows');
            if (container) {
                Array.from(container.children).forEach((row) => {
                    const input = row.querySelector('input[type="file"]');
                    const label = row.querySelector('[id^="ladderLabel"]');
                    row.classList.remove('ring-1', 'ring-red-500/70');
                    if (input) input.value = '';
                    if (label) label.textContent = '';
                });
            }

            const unitSelect = document.getElementById('unitSelect');
            const deviceSelect = document.getElementById('deviceSelect');
            const modeSelect = document.getElementById('modeSelect');
            const ladderNameSelect = document.getElementById('ladderNameModeSelect');
            const ladderStepsSelect = document.getElementById('ladderStepsSelect');

            let savedUnit = null;
            let savedDevice = null;
            let savedNameMode = null;
            let savedMode = null;
            let savedSteps = null;
            let savedChronoSim = null;

            try {
                savedUnit = localStorage.getItem('xqa_unit');
                savedDevice = localStorage.getItem('xqa_device');
                savedNameMode = localStorage.getItem('xqa_ladderNameMode');
                savedMode = localStorage.getItem('xqa_mode');
                savedSteps = localStorage.getItem('xqa_ladderSteps');
                savedChronoSim = localStorage.getItem('xqa_ladderChronoSim');
            } catch (e) {}

            unit = (savedUnit === 'metric' || savedUnit === 'imperial') ? savedUnit : 'imperial';
            if (unitSelect) unitSelect.value = unit;

            chronographType = (savedDevice === 'garmin' || savedDevice === 'athlon') ? savedDevice : 'garmin';
            if (deviceSelect) deviceSelect.value = chronographType;

            ladderNameMode = (savedNameMode === 'charge' || savedNameMode === 'filename') ? savedNameMode : 'filename';
            if (ladderNameSelect) ladderNameSelect.value = ladderNameMode;

            if (savedSteps) {
                const n = parseInt(savedSteps, 10);
                if (!isNaN(n) && n >= 2 && n <= 10) {
                    ladderSteps = n;
                }
            }

            mode = (savedMode === 'ladder' || savedMode === 'normal' || savedMode === 'sessions') ? savedMode : 'normal';
            if (modeSelect) modeSelect.value = mode;
            updateModeUI();
            const ladderChronoCheckbox = document.getElementById('ladderIncludeChronoSim');

            if (ladderStepsSelect) ladderStepsSelect.value = String(ladderSteps);
            updateLadderRowsVisibility();

            updateLadderChargeValueLabels();
            updateLadderStateBadge();
            updateLadderControlsVisibility();
            updateProcessLadderButtonState();}

        function updateModeUI() {
            const multiPanel = document.getElementById('multiFileDropzone');
            const ladderPanel = document.getElementById('ladderPanel');
            if (!multiPanel || !ladderPanel) return;

            if (mode === 'ladder') {
                multiPanel.classList.add('hidden');
                ladderPanel.classList.remove('hidden');
                updateLadderRowsVisibility();
                updateLadderChargeValueLabels();
                updateLadderStateBadge();
                updateLadderControlsVisibility();
            } else {
                multiPanel.classList.remove('hidden');
                ladderPanel.classList.add('hidden');
            }

            updateProcessLadderButtonState();
        }

        // =======================
        // Init ladder UI, preferences & new session
        // =======================

        createLadderRows();
        updateLadderRowsVisibility();
        updateLadderChargeValueLabels();
        updateLadderStateBadge();
        updateLadderControlsVisibility();
        updateProcessLadderButtonState();

        (function initUnitSelect() {
            const unitSelect = document.getElementById('unitSelect');
            if (!unitSelect) return;
            let savedUnit = null;
            try {
                savedUnit = localStorage.getItem('xqa_unit');
            } catch (e) {}
            unit = (savedUnit === 'metric' || savedUnit === 'imperial') ? savedUnit : 'imperial';
            unitSelect.value = unit;
            updateSessionPill();
            unitSelect.addEventListener('change', (e) => {
                unit = e.target.value;
                try {
                    localStorage.setItem('xqa_unit', unit);
                } catch (err) {}
                updateSessionPill();
});
        })();

        (function initAnalysisDashboard() {
            const sdInput = document.getElementById('analysisTargetSD');
            const esInput = document.getElementById('analysisTargetES');
            const bestModeSelect = document.getElementById('analysisBestNodeMode');
            const show95 = document.getElementById('analysisShow95Band');
            const showMAD = document.getElementById('analysisShowMAD');
            const showCV = document.getElementById('analysisShowCV');
            const showESD = document.getElementById('analysisShowESD');
            const includeNotes = document.getElementById('analysisIncludeInNotes');
            const summaryEl = document.getElementById('analysisBestNodeSummary');

            if (!sdInput || !esInput || !bestModeSelect || !show95 || !showMAD || !showCV || !showESD || !includeNotes || !summaryEl) {
                return;
            }

            // Load settings from localStorage
            try {
                const savedTargetSD = parseFloat(localStorage.getItem('xqa_targetSD'));
                const savedTargetES = parseFloat(localStorage.getItem('xqa_targetES'));
                const savedBestMode = localStorage.getItem('xqa_bestNodeMode');
                const savedShow95 = localStorage.getItem('xqa_show95Band');
                const savedShowMAD = localStorage.getItem('xqa_showMAD');
                const savedShowCV = localStorage.getItem('xqa_showCV');
                const savedShowESD = localStorage.getItem('xqa_showESD');
                const savedIncludeNotes = localStorage.getItem('xqa_includeInNotes');

                if (!isNaN(savedTargetSD)) analysisConfig.targetSD = savedTargetSD;
                if (!isNaN(savedTargetES)) analysisConfig.targetES = savedTargetES;
                if (savedBestMode === 'sd' || savedBestMode === 'es' || savedBestMode === 'weighted') {
                    analysisConfig.bestNodeMode = savedBestMode;
                }
                if (savedShow95 !== null) analysisConfig.show95Band = savedShow95 === 'true';
                if (savedShowMAD !== null) analysisConfig.showMAD = savedShowMAD === 'true';
                if (savedShowCV !== null) analysisConfig.showCV = savedShowCV === 'true';
                if (savedShowESD !== null) analysisConfig.showESD = savedShowESD === 'true';
                if (savedIncludeNotes !== null) analysisConfig.includeInNotes = savedIncludeNotes === 'true';
            } catch (e) {}

            // Sync controls to config
            sdInput.value = analysisConfig.targetSD;
            esInput.value = analysisConfig.targetES;
            bestModeSelect.value = analysisConfig.bestNodeMode;
            show95.checked = !!analysisConfig.show95Band;
            showMAD.checked = !!analysisConfig.showMAD;
            showCV.checked = !!analysisConfig.showCV;
            showESD.checked = !!analysisConfig.showESD;
            includeNotes.checked = !!analysisConfig.includeInNotes;

            function persistAndRefresh() {
                try {
                    localStorage.setItem('xqa_targetSD', String(analysisConfig.targetSD));
                    localStorage.setItem('xqa_targetES', String(analysisConfig.targetES));
                    localStorage.setItem('xqa_bestNodeMode', analysisConfig.bestNodeMode);
                    localStorage.setItem('xqa_show95Band', String(analysisConfig.show95Band));
                    localStorage.setItem('xqa_showMAD', String(analysisConfig.showMAD));
                    localStorage.setItem('xqa_showCV', String(analysisConfig.showCV));
                    localStorage.setItem('xqa_showESD', String(analysisConfig.showESD));
                    localStorage.setItem('xqa_includeInNotes', String(analysisConfig.includeInNotes));
                } catch (err) {}
                // Recompute best node and redraw if we have results
                if (typeof showResults === 'function' && allStats && allStats.length) {
                    bestNodeIndex = findBestNodeIndex();
                    showResults();
                } else if (summaryEl) {
                    summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
                }
            }

            sdInput.addEventListener('change', () => {
                const v = parseFloat(sdInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetSD = v;
                    persistAndRefresh();
                }
            });
            esInput.addEventListener('change', () => {
                const v = parseFloat(esInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetES = v;
                    persistAndRefresh();
                }
            });
            bestModeSelect.addEventListener('change', () => {
                const v = bestModeSelect.value;
                if (v === 'sd' || v === 'es' || v === 'weighted') {
                    analysisConfig.bestNodeMode = v;
                    persistAndRefresh();
                }
            });
            show95.addEventListener('change', () => {
                analysisConfig.show95Band = !!show95.checked;
                persistAndRefresh();
            });
            showMAD.addEventListener('change', () => {
                analysisConfig.showMAD = !!showMAD.checked;
                persistAndRefresh();
            });
            showCV.addEventListener('change', () => {
                analysisConfig.showCV = !!showCV.checked;
                persistAndRefresh();
            });
            showESD.addEventListener('change', () => {
                analysisConfig.showESD = !!showESD.checked;
                persistAndRefresh();
            });
            includeNotes.addEventListener('change', () => {
                analysisConfig.includeInNotes = !!includeNotes.checked;
                persistAndRefresh();
            });

            // Initial summary text
            summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
        })();

        (function initDeviceSelect() {
            const deviceSelect = document.getElementById('deviceSelect');
            if (!deviceSelect) return;
            let savedDevice = null;
            try {
                savedDevice = localStorage.getItem('xqa_device');
            } catch (e) {}
            chronographType = (savedDevice === 'garmin' || savedDevice === 'athlon') ? savedDevice : 'garmin';
            deviceSelect.value = chronographType;
            deviceSelect.addEventListener('change', (e) => {
                chronographType = e.target.value;
                try {
                    localStorage.setItem('xqa_device', chronographType);
                } catch (err) {}
});
        })();

        (function initAnalysisDashboard() {
            const sdInput = document.getElementById('analysisTargetSD');
            const esInput = document.getElementById('analysisTargetES');
            const bestModeSelect = document.getElementById('analysisBestNodeMode');
            const show95 = document.getElementById('analysisShow95Band');
            const showMAD = document.getElementById('analysisShowMAD');
            const showCV = document.getElementById('analysisShowCV');
            const showESD = document.getElementById('analysisShowESD');
            const includeNotes = document.getElementById('analysisIncludeInNotes');
            const summaryEl = document.getElementById('analysisBestNodeSummary');

            if (!sdInput || !esInput || !bestModeSelect || !show95 || !showMAD || !showCV || !showESD || !includeNotes || !summaryEl) {
                return;
            }

            // Load settings from localStorage
            try {
                const savedTargetSD = parseFloat(localStorage.getItem('xqa_targetSD'));
                const savedTargetES = parseFloat(localStorage.getItem('xqa_targetES'));
                const savedBestMode = localStorage.getItem('xqa_bestNodeMode');
                const savedShow95 = localStorage.getItem('xqa_show95Band');
                const savedShowMAD = localStorage.getItem('xqa_showMAD');
                const savedShowCV = localStorage.getItem('xqa_showCV');
                const savedShowESD = localStorage.getItem('xqa_showESD');
                const savedIncludeNotes = localStorage.getItem('xqa_includeInNotes');

                if (!isNaN(savedTargetSD)) analysisConfig.targetSD = savedTargetSD;
                if (!isNaN(savedTargetES)) analysisConfig.targetES = savedTargetES;
                if (savedBestMode === 'sd' || savedBestMode === 'es' || savedBestMode === 'weighted') {
                    analysisConfig.bestNodeMode = savedBestMode;
                }
                if (savedShow95 !== null) analysisConfig.show95Band = savedShow95 === 'true';
                if (savedShowMAD !== null) analysisConfig.showMAD = savedShowMAD === 'true';
                if (savedShowCV !== null) analysisConfig.showCV = savedShowCV === 'true';
                if (savedShowESD !== null) analysisConfig.showESD = savedShowESD === 'true';
                if (savedIncludeNotes !== null) analysisConfig.includeInNotes = savedIncludeNotes === 'true';
            } catch (e) {}

            // Sync controls to config
            sdInput.value = analysisConfig.targetSD;
            esInput.value = analysisConfig.targetES;
            bestModeSelect.value = analysisConfig.bestNodeMode;
            show95.checked = !!analysisConfig.show95Band;
            showMAD.checked = !!analysisConfig.showMAD;
            showCV.checked = !!analysisConfig.showCV;
            showESD.checked = !!analysisConfig.showESD;
            includeNotes.checked = !!analysisConfig.includeInNotes;

            function persistAndRefresh() {
                try {
                    localStorage.setItem('xqa_targetSD', String(analysisConfig.targetSD));
                    localStorage.setItem('xqa_targetES', String(analysisConfig.targetES));
                    localStorage.setItem('xqa_bestNodeMode', analysisConfig.bestNodeMode);
                    localStorage.setItem('xqa_show95Band', String(analysisConfig.show95Band));
                    localStorage.setItem('xqa_showMAD', String(analysisConfig.showMAD));
                    localStorage.setItem('xqa_showCV', String(analysisConfig.showCV));
                    localStorage.setItem('xqa_showESD', String(analysisConfig.showESD));
                    localStorage.setItem('xqa_includeInNotes', String(analysisConfig.includeInNotes));
                } catch (err) {}
                // Recompute best node and redraw if we have results
                if (typeof showResults === 'function' && allStats && allStats.length) {
                    bestNodeIndex = findBestNodeIndex();
                    showResults();
                } else if (summaryEl) {
                    summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
                }
            }

            sdInput.addEventListener('change', () => {
                const v = parseFloat(sdInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetSD = v;
                    persistAndRefresh();
                }
            });
            esInput.addEventListener('change', () => {
                const v = parseFloat(esInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetES = v;
                    persistAndRefresh();
                }
            });
            bestModeSelect.addEventListener('change', () => {
                const v = bestModeSelect.value;
                if (v === 'sd' || v === 'es' || v === 'weighted') {
                    analysisConfig.bestNodeMode = v;
                    persistAndRefresh();
                }
            });
            show95.addEventListener('change', () => {
                analysisConfig.show95Band = !!show95.checked;
                persistAndRefresh();
            });
            showMAD.addEventListener('change', () => {
                analysisConfig.showMAD = !!showMAD.checked;
                persistAndRefresh();
            });
            showCV.addEventListener('change', () => {
                analysisConfig.showCV = !!showCV.checked;
                persistAndRefresh();
            });
            showESD.addEventListener('change', () => {
                analysisConfig.showESD = !!showESD.checked;
                persistAndRefresh();
            });
            includeNotes.addEventListener('change', () => {
                analysisConfig.includeInNotes = !!includeNotes.checked;
                persistAndRefresh();
            });

            // Initial summary text
            summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
        })();

        (function initModeSelect() {
    const modeSelect = document.getElementById('modeSelect');
    if (!modeSelect) return;

    let savedMode = null;
    try { savedMode = localStorage.getItem('xqa_mode'); } catch (e) {}

    mode = (savedMode === 'ladder' || savedMode === 'normal' || savedMode === 'sessions')
        ? savedMode
        : (modeSelect.value || 'normal');

    modeSelect.value = mode;

    updateModeUI();
    updateSessionPill();

    modeSelect.addEventListener('change', (e) => {
        mode = (e && e.target && e.target.value) ? e.target.value : 'normal';
        try { localStorage.setItem('xqa_mode', mode); } catch (err) {}
        updateModeUI();
        updateSessionPill();

        // If we already have computed results, changing mode should rebuild output + tabs.
        if (typeof refreshOutputIfPossible === 'function') {
            refreshOutputIfPossible();
        } else if (typeof showResults === 'function' && allStats && allStats.length) {
            showResults();
        }
    });
})();

(function initSessionsLayout() {
    const compact = document.getElementById('sessionsLayoutCompact');
    const legacy = document.getElementById('sessionsLayoutLegacy');
    if (!compact || !legacy) return;

    let saved = null;
    try { saved = localStorage.getItem('xqa_sessionsLayout'); } catch (e) {}
    sessionsLayout = (saved === 'legacy') ? 'legacy' : 'compact';

    legacy.checked = (sessionsLayout === 'legacy');
    compact.checked = !legacy.checked;

    function applyLayout(value) {
        sessionsLayout = (value === 'legacy') ? 'legacy' : 'compact';
        try { localStorage.setItem('xqa_sessionsLayout', sessionsLayout); } catch (err) {}
        // Re-render session tabs if results already exist
        if (typeof refreshOutputIfPossible === 'function') {
            refreshOutputIfPossible();
        } else if (typeof showResults === 'function' && allStats && allStats.length) {
            showResults();
        }
    }

    compact.addEventListener('change', (e) => {
        if (e && e.target && e.target.checked) applyLayout('compact');
    });

    legacy.addEventListener('change', (e) => {
        if (e && e.target && e.target.checked) applyLayout('legacy');
    });
})();

(function initAnalysisDashboard() {
            const sdInput = document.getElementById('analysisTargetSD');
            const esInput = document.getElementById('analysisTargetES');
            const bestModeSelect = document.getElementById('analysisBestNodeMode');
            const show95 = document.getElementById('analysisShow95Band');
            const showMAD = document.getElementById('analysisShowMAD');
            const showCV = document.getElementById('analysisShowCV');
            const showESD = document.getElementById('analysisShowESD');
            const includeNotes = document.getElementById('analysisIncludeInNotes');
            const summaryEl = document.getElementById('analysisBestNodeSummary');

            if (!sdInput || !esInput || !bestModeSelect || !show95 || !showMAD || !showCV || !showESD || !includeNotes || !summaryEl) {
                return;
            }

            // Load settings from localStorage
            try {
                const savedTargetSD = parseFloat(localStorage.getItem('xqa_targetSD'));
                const savedTargetES = parseFloat(localStorage.getItem('xqa_targetES'));
                const savedBestMode = localStorage.getItem('xqa_bestNodeMode');
                const savedShow95 = localStorage.getItem('xqa_show95Band');
                const savedShowMAD = localStorage.getItem('xqa_showMAD');
                const savedShowCV = localStorage.getItem('xqa_showCV');
                const savedShowESD = localStorage.getItem('xqa_showESD');
                const savedIncludeNotes = localStorage.getItem('xqa_includeInNotes');

                if (!isNaN(savedTargetSD)) analysisConfig.targetSD = savedTargetSD;
                if (!isNaN(savedTargetES)) analysisConfig.targetES = savedTargetES;
                if (savedBestMode === 'sd' || savedBestMode === 'es' || savedBestMode === 'weighted') {
                    analysisConfig.bestNodeMode = savedBestMode;
                }
                if (savedShow95 !== null) analysisConfig.show95Band = savedShow95 === 'true';
                if (savedShowMAD !== null) analysisConfig.showMAD = savedShowMAD === 'true';
                if (savedShowCV !== null) analysisConfig.showCV = savedShowCV === 'true';
                if (savedShowESD !== null) analysisConfig.showESD = savedShowESD === 'true';
                if (savedIncludeNotes !== null) analysisConfig.includeInNotes = savedIncludeNotes === 'true';
            } catch (e) {}

            // Sync controls to config
            sdInput.value = analysisConfig.targetSD;
            esInput.value = analysisConfig.targetES;
            bestModeSelect.value = analysisConfig.bestNodeMode;
            show95.checked = !!analysisConfig.show95Band;
            showMAD.checked = !!analysisConfig.showMAD;
            showCV.checked = !!analysisConfig.showCV;
            showESD.checked = !!analysisConfig.showESD;
            includeNotes.checked = !!analysisConfig.includeInNotes;

            function persistAndRefresh() {
                try {
                    localStorage.setItem('xqa_targetSD', String(analysisConfig.targetSD));
                    localStorage.setItem('xqa_targetES', String(analysisConfig.targetES));
                    localStorage.setItem('xqa_bestNodeMode', analysisConfig.bestNodeMode);
                    localStorage.setItem('xqa_show95Band', String(analysisConfig.show95Band));
                    localStorage.setItem('xqa_showMAD', String(analysisConfig.showMAD));
                    localStorage.setItem('xqa_showCV', String(analysisConfig.showCV));
                    localStorage.setItem('xqa_showESD', String(analysisConfig.showESD));
                    localStorage.setItem('xqa_includeInNotes', String(analysisConfig.includeInNotes));
                } catch (err) {}
                // Recompute best node and redraw if we have results
                if (typeof showResults === 'function' && allStats && allStats.length) {
                    bestNodeIndex = findBestNodeIndex();
                    showResults();
                } else if (summaryEl) {
                    summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
                }
            }

            sdInput.addEventListener('change', () => {
                const v = parseFloat(sdInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetSD = v;
                    persistAndRefresh();
                }
            });
            esInput.addEventListener('change', () => {
                const v = parseFloat(esInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetES = v;
                    persistAndRefresh();
                }
            });
            bestModeSelect.addEventListener('change', () => {
                const v = bestModeSelect.value;
                if (v === 'sd' || v === 'es' || v === 'weighted') {
                    analysisConfig.bestNodeMode = v;
                    persistAndRefresh();
                }
            });
            show95.addEventListener('change', () => {
                analysisConfig.show95Band = !!show95.checked;
                persistAndRefresh();
            });
            showMAD.addEventListener('change', () => {
                analysisConfig.showMAD = !!showMAD.checked;
                persistAndRefresh();
            });
            showCV.addEventListener('change', () => {
                analysisConfig.showCV = !!showCV.checked;
                persistAndRefresh();
            });
            showESD.addEventListener('change', () => {
                analysisConfig.showESD = !!showESD.checked;
                persistAndRefresh();
            });
            includeNotes.addEventListener('change', () => {
                analysisConfig.includeInNotes = !!includeNotes.checked;
                persistAndRefresh();
            });

            // Initial summary text
            summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
        })();

        (function initLadderStepsSelect() {
            const ladderStepsSelect = document.getElementById('ladderStepsSelect');
            if (!ladderStepsSelect) return;
            let savedSteps = null;
            try {
                savedSteps = localStorage.getItem('xqa_ladderSteps');
            } catch (e) {}
            if (savedSteps) {
                const n = parseInt(savedSteps, 10);
                if (!isNaN(n) && n >= 2 && n <= 10) {
                    ladderSteps = n;
                }
            }
            ladderStepsSelect.value = String(ladderSteps);
            ladderStepsSelect.addEventListener('change', (e) => {
                const n = parseInt(e.target.value, 10);
                ladderSteps = (!isNaN(n) && n >= 2 && n <= 10) ? n : 10;
                try {
                    localStorage.setItem('xqa_ladderSteps', String(ladderSteps));
                } catch (err) {}
                updateLadderRowsVisibility();
                updateLadderChargeValueLabels();
                updateProcessLadderButtonState();
            });
            updateLadderRowsVisibility();
            updateLadderChargeValueLabels();
        })();

        (function initAnalysisDashboard() {
            const sdInput = document.getElementById('analysisTargetSD');
            const esInput = document.getElementById('analysisTargetES');
            const bestModeSelect = document.getElementById('analysisBestNodeMode');
            const show95 = document.getElementById('analysisShow95Band');
            const showMAD = document.getElementById('analysisShowMAD');
            const showCV = document.getElementById('analysisShowCV');
            const showESD = document.getElementById('analysisShowESD');
            const includeNotes = document.getElementById('analysisIncludeInNotes');
            const summaryEl = document.getElementById('analysisBestNodeSummary');

            if (!sdInput || !esInput || !bestModeSelect || !show95 || !showMAD || !showCV || !showESD || !includeNotes || !summaryEl) {
                return;
            }

            // Load settings from localStorage
            try {
                const savedTargetSD = parseFloat(localStorage.getItem('xqa_targetSD'));
                const savedTargetES = parseFloat(localStorage.getItem('xqa_targetES'));
                const savedBestMode = localStorage.getItem('xqa_bestNodeMode');
                const savedShow95 = localStorage.getItem('xqa_show95Band');
                const savedShowMAD = localStorage.getItem('xqa_showMAD');
                const savedShowCV = localStorage.getItem('xqa_showCV');
                const savedShowESD = localStorage.getItem('xqa_showESD');
                const savedIncludeNotes = localStorage.getItem('xqa_includeInNotes');

                if (!isNaN(savedTargetSD)) analysisConfig.targetSD = savedTargetSD;
                if (!isNaN(savedTargetES)) analysisConfig.targetES = savedTargetES;
                if (savedBestMode === 'sd' || savedBestMode === 'es' || savedBestMode === 'weighted') {
                    analysisConfig.bestNodeMode = savedBestMode;
                }
                if (savedShow95 !== null) analysisConfig.show95Band = savedShow95 === 'true';
                if (savedShowMAD !== null) analysisConfig.showMAD = savedShowMAD === 'true';
                if (savedShowCV !== null) analysisConfig.showCV = savedShowCV === 'true';
                if (savedShowESD !== null) analysisConfig.showESD = savedShowESD === 'true';
                if (savedIncludeNotes !== null) analysisConfig.includeInNotes = savedIncludeNotes === 'true';
            } catch (e) {}

            // Sync controls to config
            sdInput.value = analysisConfig.targetSD;
            esInput.value = analysisConfig.targetES;
            bestModeSelect.value = analysisConfig.bestNodeMode;
            show95.checked = !!analysisConfig.show95Band;
            showMAD.checked = !!analysisConfig.showMAD;
            showCV.checked = !!analysisConfig.showCV;
            showESD.checked = !!analysisConfig.showESD;
            includeNotes.checked = !!analysisConfig.includeInNotes;

            function persistAndRefresh() {
                try {
                    localStorage.setItem('xqa_targetSD', String(analysisConfig.targetSD));
                    localStorage.setItem('xqa_targetES', String(analysisConfig.targetES));
                    localStorage.setItem('xqa_bestNodeMode', analysisConfig.bestNodeMode);
                    localStorage.setItem('xqa_show95Band', String(analysisConfig.show95Band));
                    localStorage.setItem('xqa_showMAD', String(analysisConfig.showMAD));
                    localStorage.setItem('xqa_showCV', String(analysisConfig.showCV));
                    localStorage.setItem('xqa_showESD', String(analysisConfig.showESD));
                    localStorage.setItem('xqa_includeInNotes', String(analysisConfig.includeInNotes));
                } catch (err) {}
                // Recompute best node and redraw if we have results
                if (typeof showResults === 'function' && allStats && allStats.length) {
                    bestNodeIndex = findBestNodeIndex();
                    showResults();
                } else if (summaryEl) {
                    summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
                }
            }

            sdInput.addEventListener('change', () => {
                const v = parseFloat(sdInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetSD = v;
                    persistAndRefresh();
                }
            });
            esInput.addEventListener('change', () => {
                const v = parseFloat(esInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetES = v;
                    persistAndRefresh();
                }
            });
            bestModeSelect.addEventListener('change', () => {
                const v = bestModeSelect.value;
                if (v === 'sd' || v === 'es' || v === 'weighted') {
                    analysisConfig.bestNodeMode = v;
                    persistAndRefresh();
                }
            });
            show95.addEventListener('change', () => {
                analysisConfig.show95Band = !!show95.checked;
                persistAndRefresh();
            });
            showMAD.addEventListener('change', () => {
                analysisConfig.showMAD = !!showMAD.checked;
                persistAndRefresh();
            });
            showCV.addEventListener('change', () => {
                analysisConfig.showCV = !!showCV.checked;
                persistAndRefresh();
            });
            showESD.addEventListener('change', () => {
                analysisConfig.showESD = !!showESD.checked;
                persistAndRefresh();
            });
            includeNotes.addEventListener('change', () => {
                analysisConfig.includeInNotes = !!includeNotes.checked;
                persistAndRefresh();
            });

            // Initial summary text
            summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
        })();

        (function initLadderNameMode() {
            const select = document.getElementById('ladderNameModeSelect');
            if (!select) return;
            let saved = null;
            try {
                saved = localStorage.getItem('xqa_ladderNameMode');
            } catch (e) {}
            ladderNameMode = (saved === 'charge' || saved === 'filename') ? saved : 'filename';
            select.value = ladderNameMode;
            select.addEventListener('change', (e) => {
                ladderNameMode = e.target.value;
                try {
                    localStorage.setItem('xqa_ladderNameMode', ladderNameMode);
                } catch (err) {}
            });
        })();

        (function initAnalysisDashboard() {
            const sdInput = document.getElementById('analysisTargetSD');
            const esInput = document.getElementById('analysisTargetES');
            const bestModeSelect = document.getElementById('analysisBestNodeMode');
            const show95 = document.getElementById('analysisShow95Band');
            const showMAD = document.getElementById('analysisShowMAD');
            const showCV = document.getElementById('analysisShowCV');
            const showESD = document.getElementById('analysisShowESD');
            const includeNotes = document.getElementById('analysisIncludeInNotes');
            const summaryEl = document.getElementById('analysisBestNodeSummary');

            if (!sdInput || !esInput || !bestModeSelect || !show95 || !showMAD || !showCV || !showESD || !includeNotes || !summaryEl) {
                return;
            }

            // Load settings from localStorage
            try {
                const savedTargetSD = parseFloat(localStorage.getItem('xqa_targetSD'));
                const savedTargetES = parseFloat(localStorage.getItem('xqa_targetES'));
                const savedBestMode = localStorage.getItem('xqa_bestNodeMode');
                const savedShow95 = localStorage.getItem('xqa_show95Band');
                const savedShowMAD = localStorage.getItem('xqa_showMAD');
                const savedShowCV = localStorage.getItem('xqa_showCV');
                const savedShowESD = localStorage.getItem('xqa_showESD');
                const savedIncludeNotes = localStorage.getItem('xqa_includeInNotes');

                if (!isNaN(savedTargetSD)) analysisConfig.targetSD = savedTargetSD;
                if (!isNaN(savedTargetES)) analysisConfig.targetES = savedTargetES;
                if (savedBestMode === 'sd' || savedBestMode === 'es' || savedBestMode === 'weighted') {
                    analysisConfig.bestNodeMode = savedBestMode;
                }
                if (savedShow95 !== null) analysisConfig.show95Band = savedShow95 === 'true';
                if (savedShowMAD !== null) analysisConfig.showMAD = savedShowMAD === 'true';
                if (savedShowCV !== null) analysisConfig.showCV = savedShowCV === 'true';
                if (savedShowESD !== null) analysisConfig.showESD = savedShowESD === 'true';
                if (savedIncludeNotes !== null) analysisConfig.includeInNotes = savedIncludeNotes === 'true';
            } catch (e) {}

            // Sync controls to config
            sdInput.value = analysisConfig.targetSD;
            esInput.value = analysisConfig.targetES;
            bestModeSelect.value = analysisConfig.bestNodeMode;
            show95.checked = !!analysisConfig.show95Band;
            showMAD.checked = !!analysisConfig.showMAD;
            showCV.checked = !!analysisConfig.showCV;
            showESD.checked = !!analysisConfig.showESD;
            includeNotes.checked = !!analysisConfig.includeInNotes;

            function persistAndRefresh() {
                try {
                    localStorage.setItem('xqa_targetSD', String(analysisConfig.targetSD));
                    localStorage.setItem('xqa_targetES', String(analysisConfig.targetES));
                    localStorage.setItem('xqa_bestNodeMode', analysisConfig.bestNodeMode);
                    localStorage.setItem('xqa_show95Band', String(analysisConfig.show95Band));
                    localStorage.setItem('xqa_showMAD', String(analysisConfig.showMAD));
                    localStorage.setItem('xqa_showCV', String(analysisConfig.showCV));
                    localStorage.setItem('xqa_showESD', String(analysisConfig.showESD));
                    localStorage.setItem('xqa_includeInNotes', String(analysisConfig.includeInNotes));
                } catch (err) {}
                // Recompute best node and redraw if we have results
                if (typeof showResults === 'function' && allStats && allStats.length) {
                    bestNodeIndex = findBestNodeIndex();
                    showResults();
                } else if (summaryEl) {
                    summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
                }
            }

            sdInput.addEventListener('change', () => {
                const v = parseFloat(sdInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetSD = v;
                    persistAndRefresh();
                }
            });
            esInput.addEventListener('change', () => {
                const v = parseFloat(esInput.value);
                if (!isNaN(v) && v >= 0) {
                    analysisConfig.targetES = v;
                    persistAndRefresh();
                }
            });
            bestModeSelect.addEventListener('change', () => {
                const v = bestModeSelect.value;
                if (v === 'sd' || v === 'es' || v === 'weighted') {
                    analysisConfig.bestNodeMode = v;
                    persistAndRefresh();
                }
            });
            show95.addEventListener('change', () => {
                analysisConfig.show95Band = !!show95.checked;
                persistAndRefresh();
            });
            showMAD.addEventListener('change', () => {
                analysisConfig.showMAD = !!showMAD.checked;
                persistAndRefresh();
            });
            showCV.addEventListener('change', () => {
                analysisConfig.showCV = !!showCV.checked;
                persistAndRefresh();
            });
            showESD.addEventListener('change', () => {
                analysisConfig.showESD = !!showESD.checked;
                persistAndRefresh();
            });
            includeNotes.addEventListener('change', () => {
                analysisConfig.includeInNotes = !!includeNotes.checked;
                persistAndRefresh();
            });

            // Initial summary text
            summaryEl.textContent = 'Best node will be highlighted after stats are computed.';
        })();

        (function initLadderAdvancedToggle() {
            const btn = document.getElementById('ladderAdvancedToggle');
            const panel = document.getElementById('ladderAdvancedPanel');
            const chevron = document.getElementById('ladderAdvancedChevron');
            if (!btn || !panel || !chevron) return;

            btn.addEventListener('click', () => {
                const isHidden = panel.classList.contains('hidden');
                if (isHidden) {
                    panel.classList.remove('hidden');
                    chevron.style.transform = 'rotate(180deg)';
                } else {
                    panel.classList.add('hidden');
                    chevron.style.transform = 'rotate(0deg)';
                }
            });
        })();

        document.getElementById('newSessionBtn').addEventListener('click', resetSession);

        // Base .grtload
        document.getElementById('grtBaseInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                grtBaseContent = ev.target.result;
                _hydrateShotMarkerPrefsFromBase(grtBaseContent);

                grtBaseFilename = file && file.name ? file.name : '';
                setCurrentStep(4);
                const statusEl = document.getElementById('grtBaseStatus');
                const btnEl = document.getElementById('grtBaseBtn');
                if (statusEl) statusEl.textContent = '‚úì ' + file.name;
                if (btnEl) {
                    btnEl.className =
                        'px-4 py-2 bg-green-700 hover:bg-green-600 text-white rounded-lg text-sm font-medium border border-green-500 shadow-sm transition-colors';
                }
                extractDefaultMcValue();
                showStatus('success', 'Base .grtload loaded.');
            };
            reader.readAsText(file);
        });

        // =======================
        // Imported Pictures & Notes UI
        // =======================

        
        function renderPicsNotesSummaryCards() {
            const el = document.getElementById('picsNotesResultsCards');
            if (!el) return;

            const items = [];
            if (Array.isArray(importedPictures) && importedPictures.length) {
                items.push(`<div class="bg-grt-panel rounded-2xl border border-grt-frame p-4">
                    <div class="text-white font-semibold">Imported Pictures</div>
                    <div class="text-grt-subtle text-[11px]">${importedPictures.length} file(s)</div>
                    <div class="mt-2 text-grt-subtle text-[11px] space-y-0.5">${importedPictures.slice(0,6).map(p=>`<div class="truncate">‚Ä¢ ${escapeHtml(p.filename || p.name || 'image')}</div>`).join('')}${importedPictures.length>6?'<div class="text-grt-subtle">‚Ä¶</div>':''}</div>
                </div>`);
            }
            if (typeof importedNotesText === 'string' && importedNotesText.trim().length) {
                items.push(`<div class="bg-grt-panel rounded-2xl border border-grt-frame p-4">
                    <div class="text-white font-semibold">Imported Notes</div>
                    <div class="text-grt-subtle text-[11px]">Loaded</div>
                </div>`);
            }
            if (!items.length) {
                el.innerHTML = `<div class="text-grt-subtle text-[11px] md:text-xs">None loaded</div>`;
                return;
            }
            el.innerHTML = items.join('');
        }

        // =======================
        // Add-ons (ShotMarker)
        // =======================
        function escapeHtml(str) {
            return String(str || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }


        // Alias used by newer UI helpers (kept for backward compatibility)
        function _escapeHtml(str) {
            return escapeHtml(str);
        }
        function normalizeHeaderKey(s) {
            return String(s || '')
                .trim()
                .toLowerCase()
                .replace(/[\s\-_]+/g, '');
        }

        function parseSimpleCsv(text) {
            const raw = String(text || '');
            const lines = raw.replace(/\r/g, '').split('\n').filter(l => l.trim().length);
            if (!lines.length) return { headers: [], rows: [] };

            // detect delimiter from first line
            const first = lines[0];
            const delim = (first.split('\t').length > first.split(',').length) ? '\t' : ',';

            const headers = first.split(delim).map(h => h.trim());
            const rows = [];
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(delim);
                const row = {};
                for (let c = 0; c < headers.length; c++) {
                    row[headers[c]] = (parts[c] ?? '').trim();
                }
                rows.push(row);
            }
            return { headers, rows };
        }

        function tryComputeGroupMetrics(parsed) {
            // Try to compute ES/MR if we can find x/y columns (in inches/mm) or similar.
            const headers = parsed.headers || [];
            const keyMap = {};
            headers.forEach(h => { keyMap[normalizeHeaderKey(h)] = h; });

            const xKey = keyMap['x'] || keyMap['x(in)'] || keyMap['xinch'] || keyMap['xmm'] || keyMap['xcoord'] || keyMap['xcoordinate'];
            const yKey = keyMap['y'] || keyMap['y(in)'] || keyMap['yinch'] || keyMap['ymm'] || keyMap['ycoord'] || keyMap['ycoordinate'];

            if (!xKey || !yKey) return null;

            const pts = [];
            for (const r of parsed.rows || []) {
                const x = parseFloat(String(r[xKey] ?? '').replace(',', '.'));
                const y = parseFloat(String(r[yKey] ?? '').replace(',', '.'));
                if (isFinite(x) && isFinite(y)) pts.push({ x, y });
            }
            if (pts.length < 2) return null;

            // ES = max distance between any two points (same units as x/y)
            let es = 0;
            for (let i = 0; i < pts.length; i++) {
                for (let j = i + 1; j < pts.length; j++) {
                    const dx = pts[i].x - pts[j].x;
                    const dy = pts[i].y - pts[j].y;
                    const d = Math.sqrt(dx * dx + dy * dy);
                    if (d > es) es = d;
                }
            }
            // MR = mean radius from centroid
            const cx = pts.reduce((a,p)=>a+p.x,0) / pts.length;
            const cy = pts.reduce((a,p)=>a+p.y,0) / pts.length;
            const mr = pts.reduce((a,p)=>{
                const dx=p.x-cx, dy=p.y-cy;
                return a + Math.sqrt(dx*dx+dy*dy);
            },0) / pts.length;

            return { es, mr, shots: pts.length };
        }

        
        // =======================
        // ShotMarker shotslog (.csv) parser (Archived Data export)
        // =======================
        function _csvSplitLine(line) {
            // CSV split with quotes support (minimal but robust)
            const out = [];
            let cur = '';
            let inQ = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"') {
                    if (inQ && line[i+1] === '"') { cur += '"'; i++; }
                    else inQ = !inQ;
                } else if (ch === ',' && !inQ) {
                    out.push(cur);
                    cur = '';
                } else {
                    cur += ch;
                }
            }
            out.push(cur);
            return out;
        }

        function _clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

        function _scoreToTier(score0to100) {
            if (!isFinite(score0to100)) return null;
            const s = Number(score0to100);
            if (s >= 85) return 1;
            if (s >= 70) return 2;
            if (s >= 55) return 3;
            if (s >= 40) return 4;
            return 5;
        }

        function _mmToMoa(mm, distanceYd) {
            if (!isFinite(mm) || !isFinite(distanceYd) || distanceYd <= 0) return null;
            const distanceM = distanceYd * 0.9144;
            const rad = (mm / 1000.0) / distanceM;
            return rad * (180 / Math.PI) * 60;
        }

        
// =======================
// ShotMarker Advanced scoring + chrono mapping (MR-first, vertical-critical, 1000y bias)
// =======================
function _shotMarkerScoreParams(distanceYd) {
  // Defaults tuned for F-Class Open (1000y bias) ‚Äì safe starting point
  const isLong = (isFinite(distanceYd) && distanceYd >= 900);
  const base = {
    kMR: 1.20,
    vRef: isLong ? 0.35 : 0.40,     // MOA vertical reference (smaller = harsher penalty)
    vPow: 2.20,
    sdRef: isLong ? 7.5 : 8.5,      // fps SD reference
    sdPow: 1.70,
    wV: isLong ? 1.50 : 1.35,       // vertical critical at 1000y
    wVel: isLong ? 0.65 : 0.55
  };

  // Optional user overrides (persisted)
  try {
    if (shotMarkerScoreSettings && typeof shotMarkerScoreSettings === 'object') {
      const o = shotMarkerScoreSettings;
      // Support separate long/short overrides
      const bucket = isLong ? (o.long || o) : (o.short || o);
      ['kMR','vRef','vPow','sdRef','sdPow','wV','wVel'].forEach(k => {
        if (bucket && isFinite(bucket[k])) base[k] = Number(bucket[k]);
      });
    }
  } catch {}
  return base;
}

function _computeShotMarkerScoreAdvanced(mrMoa, vertMoa, vel, distanceYd) {
  if (mrMoa === null || !isFinite(mrMoa)) return null;
  const p = _shotMarkerScoreParams(distanceYd);

  // MR base: exponential reward for smaller MR
  const mrScore = 100 * Math.exp(-p.kMR * mrMoa);

  // Vertical penalty: multiplicative gate (critical)
  const v = (vertMoa !== null && isFinite(vertMoa)) ? vertMoa : null;
  const vPenalty = (v === null) ? 1.0 : (1 / (1 + Math.pow((v / p.vRef), p.vPow)));

  // Velocity penalty: secondary (SD preferred; fallback to ES)
  let velPenalty = 1.0;
  const sd = (vel && isFinite(vel.sd)) ? vel.sd : null;
  const es = (vel && isFinite(vel.es)) ? vel.es : null;
  if (sd !== null) velPenalty = 1 / (1 + Math.pow((sd / p.sdRef), p.sdPow));
  else if (es !== null) velPenalty = 1 / (1 + Math.pow((es / (p.sdRef * 3)), p.sdPow));

  const final = mrScore * Math.pow(vPenalty, p.wV) * Math.pow(velPenalty, p.wVel);

  return {
    mrScore: _clamp(mrScore, 0, 100),
    vPenalty: _clamp(vPenalty, 0, 1),
    velPenalty: _clamp(velPenalty, 0, 1),
    finalScore: _clamp(final, 0, 100),
    params: p
  };
}

function _extractChargeFromText(t) {
  const s = String(t || '');
  // e.g. "45.2gr", "45.0 gn", "2.93 g"
  const m = s.match(/(\d{1,3}(?:\.\d{1,3})?)\s*(gr|gn|g)\b/i);
  if (!m) return null;
  const val = parseFloat(m[1]);
  const unit = (m[2] || '').toLowerCase();
  if (!isFinite(val)) return null;
  if (unit === 'g') return val * 15.43236; // grams -> grains
  return val; // gr/gn -> grains
}

function _numMaybe(x) {
  if (x == null) return null;
  if (typeof x === 'number') return isFinite(x) ? x : null;
  const s = String(x).trim();
  if (!s) return null;
  // Extract first number from strings like "2893.1 fps" or "SD 4.7"
  const m = s.match(/-?\d+(\.\d+)?/);
  if (!m) return null;
  const v = parseFloat(m[0]);
  return isFinite(v) ? v : null;
}

function _getChronoGroupsForMapping() {
  const groups = [];

  const hasLadder = (typeof ladderSlots !== 'undefined') && Array.isArray(ladderSlots) && ladderSlots.length;
  const hasAllStats = (typeof allStats !== 'undefined') && Array.isArray(allStats) && allStats.length;

  // Ladder mode: ladderSlots (1-indexed chargeIndex)
  if (hasLadder) {
    for (let i = 0; i < ladderSlots.length; i++) {
      const slot = ladderSlots[i];
      if (!slot) continue;

      const chargeIndex = slot.chargeIndex || (i + 1);
      const stats = slot.stats || null;

      let label = '';
      const simRow = (typeof grtSimLadderRows !== 'undefined' && Array.isArray(grtSimLadderRows) && grtSimLadderRows[chargeIndex - 1]) ? grtSimLadderRows[chargeIndex - 1] : null;
      if (simRow && isFinite(simRow.chargeGr)) label = `${simRow.chargeGr.toFixed(1)}gr`;
      else label = (slot.filename || `Charge ${chargeIndex}`).replace(/\.(csv|xls|xlsx)$/i, '');

      groups.push({
        chargeIndex,
        label: `Charge ${chargeIndex} ‚Äî ${label}`,
        meanFps: _numMaybe(stats && (stats.mean ?? stats.avg ?? stats.average ?? stats.meanFps ?? stats.avgFps)),
        sdFps: _numMaybe(stats && (stats.sd ?? stats.sdFps ?? stats.stdev)),
        minFps: _numMaybe(stats && (stats.min ?? stats.minFps ?? stats.minimum)),
        maxFps: _numMaybe(stats && (stats.max ?? stats.maxFps ?? stats.maximum)),
        esFps: (()=>{ const mn=_numMaybe(stats && (stats.min ?? stats.minFps ?? stats.minimum)); const mx=_numMaybe(stats && (stats.max ?? stats.maxFps ?? stats.maximum)); return (Number.isFinite(mn)&&Number.isFinite(mx)) ? (mx-mn) : null; })(),
        count: _numMaybe(stats && (stats.count ?? stats.shots ?? stats.n))
      });
    }
    if (groups.length) return groups;
  }

  // Standard / Sessions fallback: use allStats (Files Processed)
  if (hasAllStats) {
    let idx = 1;
    for (const item of allStats) {
      if (!item) continue;
      const stats = item.stats || item;

      const meanFps = _numMaybe(stats.mean ?? stats.avg ?? stats.average ?? stats.meanFps ?? stats.avgFps);
      const sdFps   = _numMaybe(stats.sd ?? stats.sdFps ?? stats.stdev);
      const count   = _numMaybe(stats.count ?? stats.shots ?? stats.n);

      // Include even if stats are missing; we still want manual linking by file/slot
      const chargeIndex = idx++;
      const rawName = item.label || item.filename || item.name || `Rifle file ${chargeIndex}`;
      const cleanName = String(rawName).replace(/\.(csv|xls|xlsx)$/i, '');

      groups.push({
        chargeIndex,
        label: `Charge ${chargeIndex} ‚Äî ${cleanName}`,
        meanFps,
        sdFps,
        minFps: _numMaybe(stats.min ?? stats.minFps ?? stats.minimum),
        maxFps: _numMaybe(stats.max ?? stats.maxFps ?? stats.maximum),
        esFps: (()=>{ const mn=_numMaybe(stats.min ?? stats.minFps ?? stats.minimum); const mx=_numMaybe(stats.max ?? stats.maxFps ?? stats.maximum); return (Number.isFinite(mn)&&Number.isFinite(mx)) ? (mx-mn) : null; })(),
        count
      });
    }
    if (groups.length) return groups;
  }

  // Last resort: create 3 placeholders so UI always appears once SM sessions exist
  const fallbackN = hasLadder ? ladderSlots.length : (hasAllStats ? allStats.length : 3);
  for (let i = 1; i <= fallbackN; i++) {
    groups.push({ chargeIndex: i, label: `Charge ${i}`, meanFps: null, sdFps: null, count: null });
  }
  return groups;
}

function _matchShotMarkerSessionToChronoGroup(session, groups) {
  const d = session?.derived || {};
  const m = session?.meta || {};
  if (!Array.isArray(groups) || !groups.length) return null;

  // 1) Name/label tag match (most reliable)
  const taggedGr = _extractChargeFromText(m.label) ?? _extractChargeFromText(m.targetName) ?? _extractChargeFromText(m.scoreText);
  if (taggedGr !== null) {
    let best = null;
    let bestAbs = 1e9;
    for (const g of groups) {
      const gGr = _extractChargeFromText(g.label);
      if (gGr === null) continue;
      const abs = Math.abs(gGr - taggedGr);
      if (abs < bestAbs) { bestAbs = abs; best = g; }
    }
    if (best && bestAbs <= 0.15) {
      return { chargeIndex: best.chargeIndex, label: best.label, confidence: 95, method: 'tag' };
    }
  }

  // 2) Velocity + shot count matching
  const vMean = (d.velocity) ? _numMaybe(d.velocity.mean ?? d.velocity.avg ?? d.velocity.average ?? d.velocity.meanFps ?? d.velocity.avgFps) : null;
  const n = isFinite(d.shots) ? d.shots : null;

  let best = null;
  let bestScore = 1e9;
  for (const g of groups) {
    if (!isFinite(g.meanFps) || vMean === null) continue;
    const dv = Math.abs(g.meanFps - vMean);               // fps
    const dn = (n !== null && isFinite(g.count)) ? Math.abs(g.count - n) : 0;

    // Weighted distance: mean dominates
    const score = (dv / 6.0) ** 2 + (dn / 2.0) ** 2;
    if (score < bestScore) { bestScore = score; best = g; }
  }

  if (!best) {
    // Fallback: map by relay order (R1/R2/R3) if present, otherwise by import order.
    const rtxt = String((m.relay ?? m.label ?? m.targetName ?? '') || '');
    const rm = rtxt.match(/\bR(\d+)\b/i);
    const r = rm ? parseInt(rm[1], 10) : NaN;
    let g = null;
    if (isFinite(r) && r >= 1) g = groups[Math.min(r - 1, groups.length - 1)];
    if (!g) g = groups[0];
    return { chargeIndex: g.chargeIndex, label: g.label, confidence: 55, method: 'order' };
  }

  // Convert distance score into a confidence (cap at reasonable bounds)
  const conf = _clamp(92 - (bestScore * 14), 50, 92);
  return { chargeIndex: best.chargeIndex, label: best.label, confidence: conf, method: 'velocity' };
}

function mapShotMarkerSessionsToChronoCharges(sessions) {
  const groups = _getChronoGroupsForMapping();
  if (!Array.isArray(sessions) || !sessions.length) return sessions;

  sessions.forEach((s, idx) => {
    if (!s) return;
    if (!s.derived) s.derived = {};

    const key = (s.meta && s.meta.sessionKey) ? s.meta.sessionKey : _smSessionKey(s);
    const manualIdx = (shotMarkerManualMap && key != null && isFinite(shotMarkerManualMap[key]))
      ? Number(shotMarkerManualMap[key])
      : null;

    let match = null;

    if (manualIdx !== null) {
      const g = groups.find(x => Number(x.chargeIndex) === Number(manualIdx));
      if (g) {
        match = Object.assign({}, g, { confidence: 100, manual: true, method: 'manual' });
        s.derived.manualChargeIndex = Number(manualIdx);
      } else {
        // stale manual mapping; fall back to auto
        match = _matchShotMarkerSessionToChronoGroup(s, groups);
        s.derived.manualChargeIndex = null;
      }
    } else {
      match = _matchShotMarkerSessionToChronoGroup(s, groups);
      s.derived.manualChargeIndex = null;
    }

    // HARD FALLBACK: if auto matching fails, map by order (so Auto-link + Lock can still function in Standard mode)
    if (!match && Array.isArray(groups) && groups.length) {
      const g = groups[Math.min(idx, groups.length - 1)];
      match = { chargeIndex: g.chargeIndex, label: g.label, confidence: 20, method: 'order' };
    }

    s.derived.chargeMatch = match;

    // Attach chrono-derived velocity stats (session-level) so cards update when Charge link changes.
    // This does NOT imply per-shot velocity correlation is available.
    try{
      if(match && Number.isFinite(match.chargeIndex)){
        const g = groups.find(x => Number(x.chargeIndex) === Number(match.chargeIndex));
        if(g){
          const vel = {
            mean: (Number.isFinite(g.meanFps) ? Number(g.meanFps) : null),
            sd:   (Number.isFinite(g.sdFps) ? Number(g.sdFps) : null),
            es:   (Number.isFinite(g.esFps) ? Number(g.esFps) : null),
            min:  (Number.isFinite(g.minFps) ? Number(g.minFps) : null),
            max:  (Number.isFinite(g.maxFps) ? Number(g.maxFps) : null),
            n:    (Number.isFinite(g.count) ? Number(g.count) : null),
            source: 'chrono'
          };
          s.derived.velocity = vel;
        }
      } else {
        // If unlinked/auto with no match, avoid carrying stale chrono velocity
        if(s.derived.velocity && s.derived.velocity.source === 'chrono') delete s.derived.velocity;
      }
    }catch(_e){} 

  });

  return sessions;
}

function lockShotMarkerAutoLinks(strings){
  try{
    const sessions = Array.isArray(strings) ? strings : [];
    if (!sessions.length) return;
    // Ensure matches are up to date
    try { mapShotMarkerSessionsToChronoCharges(sessions); } catch(e){}
    let changed = 0;
    sessions.forEach(s=>{
      if (!s || !s.derived) return;
      const key = (s.meta && s.meta.sessionKey) ? s.meta.sessionKey : _smSessionKey(s);
      if (!key) return;
      // If user already set a manual mapping, respect it
      if (shotMarkerManualMap && Object.prototype.hasOwnProperty.call(shotMarkerManualMap, key)) return;
      const m = s.derived.chargeMatch;
      if (m && isFinite(m.chargeIndex)) {
        if (!shotMarkerManualMap) shotMarkerManualMap = {};
        shotMarkerManualMap[key] = Number(m.chargeIndex);
        s.derived.manualChargeIndex = Number(m.chargeIndex);
        // promote match to manual for UI clarity
        s.derived.chargeMatch = Object.assign({}, m, { manual: true, confidence: 100 });
        changed++;
      }
    });
    if (changed){
      try { _saveShotMarkerManualMap(); } catch(e){}
      try { renderShotMarkerSessionCards(); } catch(e){}
    }
  }catch(e){}
}
// =======================
// /ShotMarker Advanced scoring + chrono mapping
// =======================

// -----------------------
// ShotMarker helpers
// -----------------------
function _xqaIsSighterTag(tags){
  const t = String(tags || '').toLowerCase();
  // treat 'sighter' as a standalone token or substring (ShotMarker exports vary)
  return (t.split(/[^a-z0-9_]+/).includes('sighter')) || t.includes(' sighter') || t.startsWith('sighter') || t.endsWith('sighter');
}
function _computeGroupMetricsFromXY(xArr, yArr) {
            const n = Math.min(xArr.length, yArr.length);
            if (!n) return null;

            let sx = 0, sy = 0;
            for (let i=0;i<n;i++){ sx += xArr[i]; sy += yArr[i]; }
            const cx = sx / n, cy = sy / n;

            // MR
            let sumR = 0;
            const r = new Array(n);
            for (let i=0;i<n;i++){
                const dx = xArr[i]-cx, dy = yArr[i]-cy;
                const ri = Math.sqrt(dx*dx + dy*dy);
                r[i]=ri;
                sumR += ri;
            }
            const mr = sumR / n;

            // ES (O(n^2) is fine for typical shot counts)
            let es = 0;
            for (let i=0;i<n;i++){
                for (let j=i+1;j<n;j++){
                    const dx = xArr[i]-xArr[j], dy = yArr[i]-yArr[j];
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d > es) es = d;
                }
            }

            let minX=xArr[0], maxX=xArr[0], minY=yArr[0], maxY=yArr[0];
            for (let i=1;i<n;i++){
                if (xArr[i] < minX) minX = xArr[i];
                if (xArr[i] > maxX) maxX = xArr[i];
                if (yArr[i] < minY) minY = yArr[i];
                if (yArr[i] > maxY) maxY = yArr[i];
            }
            const horiz = maxX - minX;
            const vert = maxY - minY;

            return { shots:n, cx, cy, mr, es, horiz, vert, r };
        }

        function _computeVelocityStats(vArr) {
            const vals = vArr.filter(v => isFinite(v));
            const n = vals.length;
            if (!n) return null;
            let sum=0;
            for (const v of vals) sum += v;
            const avg = sum / n;
            let s2=0;
            let min=vals[0], max=vals[0];
            for (const v of vals){
                const dv = v-avg;
                s2 += dv*dv;
                if (v < min) min = v;
                if (v > max) max = v;
            }
            const sd = n>1 ? Math.sqrt(s2/(n-1)) : 0;
            const es = max - min;
            return { n, avg, sd, es, min, max };
        }

        // =======================
        // Shot plot helpers (per-session)
        // =======================
        let shotMarkerPlotUnit = (function(){
          try { return localStorage.getItem('xqa_sm_plot_unit') || 'moa'; } catch(e) { return 'moa'; }
        })();

        function _smUnitLabel(u){
          return (u==='in')?'in' : (u==='mm')?'mm' : (u==='mil')?'mil' : 'MOA';
        }

        function _smMmToIn(mm){ return mm / 25.4; }

        function _smMmToMoa(mm, distanceYd){
          const d = (isFinite(distanceYd) && distanceYd>0) ? distanceYd : 1000;
          const inches = _smMmToIn(mm);
          const moaIn = 1.047 * (d/100);
          return inches / moaIn;
        }

        function _smMmToMil(mm, distanceYd){
          const d = (isFinite(distanceYd) && distanceYd>0) ? distanceYd : 1000;
          const inches = _smMmToIn(mm);
          const milIn = 0.036 * d; // 1 mil ‚âà 0.001 rad
          return inches / milIn;
        }

        function _smConvertMm(mm, unit, distanceYd){
          if (!isFinite(mm)) return null;
          if (unit === 'mm') return mm;
          if (unit === 'in') return _smMmToIn(mm);
          if (unit === 'mil') return _smMmToMil(mm, distanceYd);
          return _smMmToMoa(mm, distanceYd); // default moa
        }

        function _renderShotMarkerPlotPanelHtml(session){
          const s = session || {};
          const shots = Array.isArray(s.shots) ? s.shots : [];
          const m = s.meta || {};
          const d = s.derived || {};
          const unit = shotMarkerPlotUnit || 'moa';
          const uLabel = _smUnitLabel(unit);
          const dist = (m && isFinite(m.distanceYd)) ? m.distanceYd : 1000;

          const ptsMm = [];
          const ptsMmScoring = [];
          for (const sh of shots){
            if (!sh) continue;
            if (isFinite(sh.xMm) && isFinite(sh.yMm)){
              const p = { xMm: sh.xMm, yMm: sh.yMm, isSighter: !!sh.isSighter };
              ptsMm.push(p);
              if (!p.isSighter) ptsMmScoring.push(p);
            }
          }
          if (!ptsMm.length) return '';

          // metrics are computed from scoring shots only (sighters excluded)
          const xsMm = ptsMmScoring.map(p=>p.xMm);
          const ysMm = ptsMmScoring.map(p=>p.yMm);
          const gm = (xsMm.length ? _computeGroupMetricsFromXY(xsMm, ysMm) : null);

          const mr = gm ? _smConvertMm(gm.mr, unit, dist) : null;
          const es = gm ? _smConvertMm(gm.es, unit, dist) : null;
          const w = gm ? _smConvertMm(gm.horiz, unit, dist) : null;
          const h = gm ? _smConvertMm(gm.vert, unit, dist) : null;

          // Normalize plot to max(|x|,|y|) with padding
          let maxAbs = 0;
          for (let i=0;i<xsMm.length;i++){
            const x = _smConvertMm(xsMm[i], unit, dist);
            const y = _smConvertMm(ysMm[i], unit, dist);
            if (!isFinite(x) || !isFinite(y)) continue;
            maxAbs = Math.max(maxAbs, Math.abs(x), Math.abs(y));
          }
          if (!isFinite(maxAbs) || maxAbs<=0) maxAbs = 1;
          const pad = maxAbs * 0.15;
          const range = maxAbs + pad;

          const size = 220;
          const cx = size/2, cy = size/2;

          const toPx = (v) => (v / range) * (size*0.42); // keep margin
          const ringR = [0.25,0.5,0.75,1.0].map(f => Math.abs(toPx(range*f)));

          const pts = [];
          for (let i=0;i<ptsMm.length;i++){
            const p0 = ptsMm[i];
            const x = _smConvertMm(p0.xMm, unit, dist);
            const y = _smConvertMm(p0.yMm, unit, dist);
            if (!isFinite(x) || !isFinite(y)) continue;
            const px = cx + toPx(x);
            const py = cy - toPx(y);
            pts.push({i:i+1, px, py, isSighter: !!p0.isSighter});
          }

          const svg = `
            <svg viewBox="0 0 ${size} ${size}" class="w-full h-auto rounded-xl border border-grt-frame bg-grt-panel-soft">
              <defs>
                <radialGradient id="smPlotGlow" cx="50%" cy="50%" r="70%">
                  <stop offset="0%" stop-color="rgba(60,134,199,0.18)"/>
                  <stop offset="100%" stop-color="rgba(60,134,199,0)"/>
                </radialGradient>
              </defs>
              <rect x="0" y="0" width="${size}" height="${size}" fill="url(#smPlotGlow)"></rect>
              <line x1="${cx}" y1="10" x2="${cx}" y2="${size-10}" stroke="rgba(255,255,255,0.10)" stroke-width="1"/>
              <line x1="10" y1="${cy}" x2="${size-10}" y2="${cy}" stroke="rgba(255,255,255,0.10)" stroke-width="1"/>
              ${ringR.map(r => `<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>`).join('')}
              ${pts.map(p => `
                <g>
                  <circle cx="${p.px}" cy="${p.py}" r="6.3" fill="${p.isSighter ? 'rgba(0,0,0,0)' : 'rgba(0,0,0,0.55)'}" stroke="rgba(255,255,255,0.55)" stroke-width="1" opacity="${p.isSighter ? 0.42 : 1}"/>
                  <text x="${p.px}" y="${p.py+3.2}" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.92)" font-weight="700">${p.i}</text>
                </g>`).join('')}
            </svg>
          `;

          const sd = (d.velocity && isFinite(d.velocity.sd)) ? d.velocity.sd : null;
          const vel = (d.velocity && isFinite(d.velocity.avg)) ? d.velocity.avg : null;

          const stats = `
            <div class="text-[11px] text-grt-soft">
              <div class="flex justify-between gap-2"><span class="text-grt-subtle">Shots</span><span class="font-semibold text-white">${pts.length}</span></div>
              <div class="flex justify-between gap-2"><span class="text-grt-subtle">Size (ES)</span><span class="font-semibold text-white">${(es!==null && isFinite(es))?es.toFixed(unit==='mm'?1:2):'‚Äì'} ${uLabel}</span></div>
              <div class="flex justify-between gap-2"><span class="text-grt-subtle">W / H</span><span class="font-semibold text-white">${(w!==null&&isFinite(w))?w.toFixed(unit==='mm'?1:2):'‚Äì'} / ${(h!==null&&isFinite(h))?h.toFixed(unit==='mm'?1:2):'‚Äì'} ${uLabel}</span></div>
              <div class="flex justify-between gap-2"><span class="text-grt-subtle">MR</span><span class="font-semibold text-white">${(mr!==null&&isFinite(mr))?mr.toFixed(unit==='mm'?1:3):'‚Äì'} ${uLabel}</span></div>
              <div class="flex justify-between gap-2"><span class="text-grt-subtle">V (avg)</span><span class="font-semibold text-white">${(vel!==null&&isFinite(vel))?vel.toFixed(0):'‚Äì'} <span class="text-grt-subtle">fps</span></span></div>
              <div class="flex justify-between gap-2"><span class="text-grt-subtle">SD</span><span class="font-semibold text-white">${(sd!==null&&isFinite(sd))?sd.toFixed(1):'‚Äì'} <span class="text-grt-subtle">fps</span></span></div>
            </div>
          `;

          return `
            <div class="mt-3 bg-grt-panel-soft/40 border border-grt-frame rounded-2xl p-3">
              <div class="flex items-center justify-between gap-2 mb-2">
                <div class="text-white/85 text-xs font-semibold">Shot plot</div>
                <select data-sm-plotunit="1" class="bg-grt-panel-soft border border-grt-frame rounded-xl px-2 py-1 text-white text-[11px]">
                  <option value="moa" ${unit==='moa'?'selected':''}>MOA</option>
                  <option value="mil" ${unit==='mil'?'selected':''}>mil</option>
                  <option value="in" ${unit==='in'?'selected':''}>in</option>
                  <option value="mm" ${unit==='mm'?'selected':''}>mm</option>
                </select>
              </div>
              <div class="grid grid-cols-1 md:grid-cols-3 gap-3 items-start">
                <div class="md:col-span-2">${svg}</div>
                <div>${stats}</div>
              </div>
            </div>
          `;
        }


        function _corr(a, b) {
            const pairs = [];
            for (let i=0;i<Math.min(a.length,b.length);i++){
                if (isFinite(a[i]) && isFinite(b[i])) pairs.push([a[i],b[i]]);
            }
            const n = pairs.length;
            if (n < 3) return null;
            let sa=0,sb=0;
            for (const [x,y] of pairs){ sa+=x; sb+=y; }
            const ma=sa/n, mb=sb/n;
            let num=0,da=0,db=0;
            for (const [x,y] of pairs){
                const xa=x-ma, yb=y-mb;
                num += xa*yb;
                da += xa*xa;
                db += yb*yb;
            }
            const den = Math.sqrt(da*db);
            return den ? (num/den) : null;
        }

        function parseShotMarkerShotslog(rawText) {
            const lines = String(rawText || '').replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n');
            const sessionRe = /^(?:(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}(?:,)?\s+\d{4},|\d{4}-\d{2}-\d{2}\s*,)/;
            const strings = [];

            for (let i=0;i<lines.length;i++){
                const line = (lines[i] || '').trim();
                if (!line) continue;
                if (!sessionRe.test(line)) continue;

                const head = _csvSplitLine(line);
                const dateText = (head[0]||'').trim();
                const relay = (head[1]||'').trim();
                const label = (head[2]||'').trim();
                const img = (head[3]||'').trim();
                const targetName = (head[4]||'').trim();
                const scoreText = (head[5]||'').trim();

                // distance parse (yards only for now)
                let distanceYd = null;
                const m = targetName.match(/\b(\d{3,5})\s*(y|yd|yards)\b/i);
                if (m) distanceYd = parseFloat(m[1]);

                // find shot header line starting with ",time"
                let j = i+1;
                while (j < lines.length && !String(lines[j]||'').startsWith(',time')) j++;
                if (j >= lines.length) continue;

                const shotHeader = _csvSplitLine(lines[j]).slice(1).map(s => s.trim());
                const idx = (name) => shotHeader.findIndex(h => h === name);

                const ix = idx('x mm');
                const iy = idx('y mm');
                const iv = idx('v fps');
                const iid = idx('id');
                const iscore = idx('score');
                const itemp = idx('temp C');
                const iqual = idx('quality');
                const ixyerr = idx('xy_err');

                                const itags = idx('tags');
const shots = [];
                const xs = [], ys = [], vs = [];

                j++;
                while (j < lines.length && String(lines[j]||'').startsWith(',')) {
                    const rawRowLine = String(lines[j] || '');
                    const rowTrim = rawRowLine.trim();
                    // Stop on blank/separator/session headers
                    if (!rowTrim) break;
                    if (/^,+$/.test(rowTrim)) { j++; break; }
                    if (sessionRe.test(rowTrim)) break;
                    if (rawRowLine.trimStart().startsWith(',time')) break;
                    const row = _csvSplitLine(lines[j]).slice(1);
                    const getNum = (k) => {
                        if (k < 0 || k >= row.length) return null;
                        const v = parseFloat(String(row[k]).trim());
                        return isFinite(v) ? v : null;
                    };
                    const getStr = (k) => (k < 0 || k >= row.length) ? '' : String(row[k]||'').trim();

                    const x = getNum(ix);
                    const y = getNum(iy);
                    const v = getNum(iv);

                    const shot = {
                        id: getNum(iid),
                        score: getStr(iscore),
                        tempC: getNum(itemp),
                        tags: getStr(itags),
                        xMm: x,
                        yMm: y,
                        vFps: v,
                        quality: getNum(iqual),
                        xyErr: getNum(ixyerr)
                    };
                    shots.push(shot);
                                        // intent: sighters never count toward scoring
                    const __tagStr = String(shot.tags||'').toLowerCase();
                    shot.isSighter = _xqaIsSighterTag(shot.tags);
if (!shot.isSighter) {
                        if (x !== null && y !== null) { xs.push(x); ys.push(y); }
                        if (v !== null) vs.push(v);
                    }

                    j++;
                }

                const gm = _computeGroupMetricsFromXY(xs, ys);
                if (!gm) { i = j - 1; continue; }

                const vel = _computeVelocityStats(vs);
                const vertMoa = (distanceYd && isFinite(gm.vert)) ? _mmToMoa(gm.vert, distanceYd) : null;
                const horizMoa = (distanceYd && isFinite(gm.horiz)) ? _mmToMoa(gm.horiz, distanceYd) : null;
                const mrMoa = (distanceYd && isFinite(gm.mr)) ? _mmToMoa(gm.mr, distanceYd) : null;

                // shot intent counts (sighters excluded from scoring)
                const totalShots = shots.length;
                const sighterShots = shots.reduce((a,sh)=>a + (sh && sh.isSighter ? 1 : 0), 0);
                const scoringShots = totalShots - sighterShots;

                // simple, explainable diagnostics + confidence
                const __n = scoringShots;
                const __v = Number.isFinite(gm.vert) ? gm.vert : null;
                const __h = Number.isFinite(gm.horiz) ? gm.horiz : null;
                const __tot = (Number.isFinite(__v) && Number.isFinite(__h)) ? (__v + __h) : null;
                const __vDom = (__tot && __tot>0 && Number.isFinite(__v)) ? (__v/__tot) : null;
                const __hDom = (__tot && __tot>0 && Number.isFinite(__h)) ? (__h/__tot) : null;
                function __confFrom(n, domStrong, domModerate, coherent){
                  let pts = 0;
                  if(n>=8) pts += 2; else if(n>=5) pts += 1;
                  if(domStrong) pts += 2; else if(domModerate) pts += 1;
                  if(!coherent) pts -= 2;
                  if(pts>=4) return {label:'High', pts};
                  if(pts>=2) return {label:'Medium', pts};
                  return {label:'Low', pts};
                }
                const __coherent = Number.isFinite(distanceYd) && __n>=3 && Number.isFinite(gm.es);
                let dominantDiag = null;
                if(Number.isFinite(__vDom) && Number.isFinite(__hDom)){
                  if(__vDom>0.70){ dominantDiag = {type:'vertical', dominance:__vDom, conf:__confFrom(__n,true,true,__coherent)}; }
                  else if(__hDom>0.70){ dominantDiag = {type:'horizontal', dominance:__hDom, conf:__confFrom(__n,true,true,__coherent)}; }
                  else if(__vDom>=0.55){ dominantDiag = {type:'vertical', dominance:__vDom, conf:__confFrom(__n,false,true,__coherent)}; }
                  else if(__hDom>=0.55){ dominantDiag = {type:'horizontal', dominance:__hDom, conf:__confFrom(__n,false,true,__coherent)}; }
                  else { dominantDiag = {type:'scatter', dominance:Math.max(__vDom,__hDom), conf:__confFrom(__n,false,false,__coherent)}; }
                }

                const advScore = _computeShotMarkerScoreAdvanced(mrMoa, vertMoa, vel, distanceYd);
                const verticalScore = (advScore && isFinite(advScore.vPenalty)) ? (advScore.vPenalty * 100) : null;
                const precisionScore = (advScore && isFinite(advScore.mrScore)) ? advScore.mrScore : null;
                const confidenceScore = (advScore && isFinite(advScore.finalScore)) ? advScore.finalScore : null;
                const finalScore = (advScore && isFinite(advScore.finalScore)) ? advScore.finalScore : null;

                const vVsY = (vel && (vs && vs.length >= 3) && (ys && ys.length >= 3)) ? _corr(vs, ys) : null;

                const sessionKey = [dateText, relay || '', label || '', img || '', targetName || '']
                    .map(x => String(x || '').trim()).join('|');

                const scoreBreakdown = (advScore && typeof advScore === 'object')
                    ? Object.assign({
                        mrMoa, vertMoa, distanceYd,
                        sdFps: (vel && isFinite(vel.sd)) ? vel.sd : null,
                        esFps: (vel && isFinite(vel.es)) ? vel.es : null
                      }, advScore)
                    : null;

                strings.push({
                    meta: { dateText, relay, label, img, targetName, distanceYd, scoreText, sessionKey },
                    shots,
                    derived: {
                        shots: gm.shots,
                        mrMm: gm.mr,
                        esMm: gm.es,
                        vertMm: gm.vert,
                        horizMm: gm.horiz,
                        mrMoa, vertMoa, horizMoa,
                        totalShots: totalShots,
                        scoringShots: scoringShots,
                        sighterShots: sighterShots,
                        dominantDiag: dominantDiag,

                        velocity: vel,
                        verticalScore, precisionScore, confidenceScore,
                        finalScore,
                        scoreBreakdown: scoreBreakdown,
                        vVsYcorr: vVsY
                    }
                });

                i = j - 1;
            }

            return strings;
        }

        function _pickSessionCards(strings) {
            const valid = (strings || []).filter(s => s && s.derived && (isFinite(s.derived.finalScore) || isFinite(s.derived.mrMoa) || isFinite(s.derived.mrMm)));
            if (!valid.length) return { best:null, typical:null, worst:null };

            // Prefer advanced score when available (MR-first + vertical-critical), fallback to MR MOA.
            const scoreOf = (s) => (s && s.derived && isFinite(s.derived.finalScore)) ? s.derived.finalScore
                               : ((s && s.derived && isFinite(s.derived.mrMoa)) ? (100 - (s.derived.mrMoa * 40)) : -1e9);

            const byScoreDesc = [...valid].sort((a,b)=> scoreOf(b) - scoreOf(a));
            const n = byScoreDesc.length;

            const best = byScoreDesc[0] || null;
            const worst = byScoreDesc[n - 1] || null;

            // "Typical" should be a distinct representative, not a duplicate of best/worst.
            // For n<3, it's clearer to omit the Typical card entirely.
            let typical = null;
            if (n >= 3) {
              typical = byScoreDesc[Math.floor(n/2)] || null;

              // Ensure uniqueness in edge cases (ties/identical objects).
              if (typical === best) typical = byScoreDesc[Math.min(1, n-1)] || null;
              if (typical === worst) typical = byScoreDesc[Math.max(n-2, 0)] || null;
              if (typical === best || typical === worst) typical = null;
            }

            return { best, typical, worst };
        }

        // Relative highlighting within the current import (does not change absolute tiers)
        function _shotMarkerRelativeStats(strings) {
            const valid = (strings || []).filter(s => s && s.derived && isFinite(s.derived.mrMoa) && isFinite(s.derived.vertMoa) && isFinite(s.derived.finalScore));
            const n = valid.length;
            if (!n) return { n: 0, bestCompositeKey: null, bestMrKey: null, bestVertKey: null, rankByKey: {}, keyOf: (s)=>((s&&s.meta&&s.meta.sessionKey)||'') };

            const keyOf = (s) => (s && s.meta && s.meta.sessionKey) ? s.meta.sessionKey : '';
            const byScore = [...valid].sort((a,b)=> (b.derived.finalScore - a.derived.finalScore));
            const byMr = [...valid].sort((a,b)=> (a.derived.mrMoa - b.derived.mrMoa));
            const byVert = [...valid].sort((a,b)=> (a.derived.vertMoa - b.derived.vertMoa));

            const bestCompositeKey = keyOf(byScore[0]);
            const bestMrKey = keyOf(byMr[0]);
            const bestVertKey = keyOf(byVert[0]);

            const rankByKey = {};
            byScore.forEach((s, i) => { const k = keyOf(s); if (k) rankByKey[k] = i + 1; });

            return { n, bestCompositeKey, bestMrKey, bestVertKey, rankByKey, keyOf };
        }

        function _shotMarkerRankedListHtml(strings, rel) {
            const all = (strings || []).filter(s => s && (s.meta || s.derived));
            if (!all.length) return '';
            const scored = all.filter(s => s && s.derived && isFinite(s.derived.finalScore));
            const unscored = all.filter(s => !(s && s.derived && isFinite(s.derived.finalScore)));
            const byScore = [...scored].sort((a,b)=> (b.derived.finalScore - a.derived.finalScore)).concat(unscored);

            const row = (s) => {
                const d = s.derived || {};
                const m = s.meta || {};
                const key = (m.sessionKey || '');
                const rank = (rel && rel.rankByKey && key && rel.rankByKey[key]) ? rel.rankByKey[key] : null;
                const n = (rel && isFinite(rel.n)) ? rel.n : null;
                const score = isFinite(d.finalScore) ? d.finalScore : null;
                const tier = (score !== null) ? _scoreToTier(score) : null;
                const mr = isFinite(d.mrMoa) ? d.mrMoa : null;
                const vv = isFinite(d.vertMoa) ? d.vertMoa : null;

                const isBestComposite = (key && rel && rel.bestCompositeKey && key === rel.bestCompositeKey);
                const isBestMr = (key && rel && rel.bestMrKey && key === rel.bestMrKey);
                const isBestVert = (key && rel && rel.bestVertKey && key === rel.bestVertKey);

                const pills = [
                    isBestComposite ? 'üèÅ Best today' : '',
                    (!isBestComposite && isBestMr) ? 'üéØ Best MR' : '',
                    (!isBestComposite && isBestVert) ? 'üìè Best V' : ''
                ].filter(Boolean).join(' ‚Ä¢ ');

                const title = [m.dateText || m.date || '', m.relay || '', m.label || ''].filter(Boolean).join(' ‚Ä¢ ');
                const t = title || (m.targetName || 'Session');

                return `
                  <div class="flex items-center justify-between gap-3 py-2 border-b border-white/5">
                    <div class="min-w-0">
                      <div class="text-white text-xs md:text-sm truncate">${t}</div>
                      <div class="text-grt-subtle text-[10px] md:text-xs truncate">
                        ${pills || (m.targetName || '')}
                      </div>
                    </div>
                    <div class="flex flex-wrap items-center justify-end gap-2 flex-shrink-0">
                      ${(rank && n) ? `<span class="text-grt-subtle text-[11px]">#${rank}/${n}</span>` : ''}
                      ${(tier !== null) ? `<span class="px-2 py-1 rounded-full border border-white/10 bg-grt-frame/30 text-grt-soft text-[11px]">S${tier}</span>` : `<span class="px-2 py-1 rounded-full border border-white/10 bg-grt-frame/20 text-grt-subtle text-[11px]">Unscored</span>`}
                      ${(mr !== null) ? `<span class="text-grt-subtle text-[11px]">MR ${mr.toFixed(3)}</span>` : ''}
                      ${(vv !== null) ? `<span class="text-grt-subtle text-[11px]">V ${vv.toFixed(3)}</span>` : ''}
                    </div>
                  </div>
                `;
            };

            return `
              <div class="mt-4 bg-grt-panel-soft/40 border border-grt-frame rounded-2xl p-3">
                <details>
                  <summary class="cursor-pointer text-white text-sm font-semibold select-none">All sessions (ranked)</summary>
                  <div class="mt-2">
                    ${byScore.map(row).join('')}
                    <div class="text-grt-subtle text-[11px] mt-2">
                      Relative badges show winners inside this import; S-tier is absolute (your 1000y standard).
                    </div>
                  </div>
                </details>
              </div>
            `;
        }

        
// =======================
// ShotMarker Phase C: Node aggregation + confidence (by charge)
// =======================
function _smWeightedStd(values) {
  // values: [{v, w}]
  if (!Array.isArray(values) || values.length < 2) return 0;
  let sumW = 0, sum = 0;
  for (const it of values) { if (!it) continue; const v = it.v, w = it.w; if (!isFinite(v) || !isFinite(w) || w<=0) continue; sumW += w; sum += v*w; }
  if (sumW <= 0) return 0;
  const mean = sum / sumW;
  let varSum = 0;
  for (const it of values) { if (!it) continue; const v = it.v, w = it.w; if (!isFinite(v) || !isFinite(w) || w<=0) continue; const d = v-mean; varSum += w*d*d; }
  const variance = varSum / sumW;
  return Math.sqrt(Math.max(0, variance));
}

function _smPooledVelAdd(acc, vel) {
  // acc: {n, mean, m2, min, max}
  // vel: {count, mean, sd, min, max}
  const nB = vel && isFinite(vel.count) ? Number(vel.count) : 0;
  const meanB = vel && isFinite(vel.mean) ? Number(vel.mean) : null;
  if (!(nB > 0) || meanB === null) return acc;

  const sdB = vel && isFinite(vel.sd) ? Number(vel.sd) : null;
  const varB = (sdB !== null) ? (sdB*sdB) : 0; // treat as population variance proxy
  const m2B = varB * nB;

  if (!(acc.n > 0)) {
    acc.n = nB;
    acc.mean = meanB;
    acc.m2 = m2B;
    acc.min = (vel && isFinite(vel.min)) ? Number(vel.min) : meanB;
    acc.max = (vel && isFinite(vel.max)) ? Number(vel.max) : meanB;
    return acc;
  }

  const nA = acc.n;
  const meanA = acc.mean;
  const n = nA + nB;
  const delta = meanB - meanA;

  // Parallel/pooled update for M2
  acc.m2 = acc.m2 + m2B + (delta*delta) * (nA * nB / n);
  acc.mean = (meanA*nA + meanB*nB) / n;
  acc.n = n;

  if (vel && isFinite(vel.min)) acc.min = Math.min(acc.min, Number(vel.min));
  if (vel && isFinite(vel.max)) acc.max = Math.max(acc.max, Number(vel.max));
  return acc;
}

function _shotMarkerNodeAggregates(strings) {
  const sessions = (strings || []).filter(s => s && s.derived && s.derived.chargeMatch && isFinite(s.derived.chargeMatch.chargeIndex));
  const byIdx = new Map();

  for (const s of sessions) {
    const d = s.derived || {};
    const m = s.meta || {};
    const match = d.chargeMatch || {};
    const idx = Number(match.chargeIndex);
    if (!isFinite(idx)) continue;

    const label = match.label || `Charge ${idx}`;
    const nShots = (isFinite(d.shots) ? Number(d.shots) : (Array.isArray(s.shots) ? s.shots.length : 0)) || 0;

    let node = byIdx.get(idx);
    if (!node) {
      node = {
        chargeIndex: idx,
        label,
        sessions: [],
        shots: 0,
        mrW: 0, mrSum: 0,
        vertW: 0, vertSum: 0,
        mrVals: [],
        vertVals: [],
        velAcc: { n: 0, mean: 0, m2: 0, min: Infinity, max: -Infinity },
        distances: []
      };
      byIdx.set(idx, node);
    }

    node.sessions.push(s);
    node.shots += nShots;

    if (isFinite(d.mrMoa)) { node.mrSum += d.mrMoa * Math.max(1, nShots); node.mrW += Math.max(1, nShots); node.mrVals.push({v: d.mrMoa, w: Math.max(1, nShots)}); }
    if (isFinite(d.vertMoa)) { node.vertSum += d.vertMoa * Math.max(1, nShots); node.vertW += Math.max(1, nShots); node.vertVals.push({v: d.vertMoa, w: Math.max(1, nShots)}); }

    if (d.velocity) _smPooledVelAdd(node.velAcc, d.velocity);
    const dy = (isFinite(m.distanceYd) ? Number(m.distanceYd) : null);
    if (dy !== null) node.distances.push(dy);
  }

  const nodes = [];
  for (const node of byIdx.values()) {
    const mrMoa = (node.mrW > 0) ? (node.mrSum / node.mrW) : null;
    const vertMoa = (node.vertW > 0) ? (node.vertSum / node.vertW) : null;

    const velN = node.velAcc.n;
    const velMean = (velN > 0) ? node.velAcc.mean : null;
    const velSd = (velN > 0) ? Math.sqrt(Math.max(0, node.velAcc.m2 / velN)) : null;
    const velEs = (velN > 0 && isFinite(node.velAcc.min) && isFinite(node.velAcc.max)) ? (node.velAcc.max - node.velAcc.min) : null;

    // Choose a representative distance (median-ish)
    let distYd = null;
    if (node.distances.length) {
      const sorted = [...node.distances].sort((a,b)=>a-b);
      distYd = sorted[Math.floor(sorted.length/2)];
    }

    const velObj = { mean: velMean, sd: velSd, es: velEs, count: velN, min: isFinite(node.velAcc.min)?node.velAcc.min:null, max: isFinite(node.velAcc.max)?node.velAcc.max:null };
    const adv = _computeShotMarkerScoreAdvanced(mrMoa, vertMoa, velObj, distYd);

    const base = (adv && isFinite(adv.finalScore)) ? adv.finalScore : null;

    // Consistency (vertical repeatability between strings) ‚Äì F-Class critical
    const vertStd = _smWeightedStd(node.vertVals);        // MOA
    const mrStd = _smWeightedStd(node.mrVals);            // MOA

    const vCons = 1 / (1 + Math.pow((vertStd / 0.12), 2));   // 0.12 MOA session-to-session std is "pretty repeatable"
    const mrCons = 1 / (1 + Math.pow((mrStd / 0.07), 2));

    // Repeat bonus: 1 string = cautious; 2+ strings ramps up confidence
    const k = (node.sessions || []).length;
    const rep = _clamp(0.70 + 0.15 * (k - 1), 0.70, 1.00);

    // Final node confidence
    const nodeConf = (base !== null) ? _clamp(base * vCons * mrCons * rep, 0, 100) : null;

    nodes.push({
      chargeIndex: node.chargeIndex,
      label: node.label,
      sessionCount: k,
      shots: node.shots,
      mrMoa,
      vertMoa,
      vertStd,
      mrStd,
      velocity: velObj,
      baseScore: base,
      nodeConfidence: nodeConf,
      breakdown: { vCons, mrCons, rep, adv }
    });
  }

  nodes.sort((a,b)=> (b.nodeConfidence ?? -1e9) - (a.nodeConfidence ?? -1e9));
  return nodes;
}

function _shotMarkerNodeSectionHtml(strings) {
  const nodes = _shotMarkerNodeAggregates(strings);
  // If nothing is linked yet, show a helpful hint instead of silently hiding the section.
  if (!nodes.length) {
    const hasSessions = Array.isArray(strings) && strings.length;
    if (!hasSessions) return '';
    return `
      <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-2xl p-3 mb-3">
        <div class="flex items-start justify-between gap-3">
          <div>
            <div class="text-white text-sm font-semibold">Node confidence (by charge)</div>
            <div class="text-grt-subtle text-[11px] mt-0.5">No sessions are linked to charges yet. Use the <span class=\"font-semibold\">Charge link</span> dropdown on each session card (or import chrono first) and this section will populate.</div>
          </div>
          
          
        </div>
      </div>
    `;
  }

  const best = nodes[0];
  const conf = (best.nodeConfidence !== null) ? Math.round(best.nodeConfidence) : null;
  const tier = (conf !== null) ? _scoreToTier(conf) : null;

  // Confidence badge styling (use same tier palette)
  let badgeClass = 'bg-slate-800/60 text-slate-200 border-slate-500/40';
  if (tier === 1) badgeClass = 'bg-emerald-950/50 text-emerald-200 border-emerald-500/40';
  else if (tier === 2) badgeClass = 'bg-emerald-900/40 text-emerald-100 border-emerald-400/40';
  else if (tier === 3) badgeClass = 'bg-sky-950/50 text-sky-100 border-sky-400/35';
  else if (tier === 4) badgeClass = 'bg-amber-900/45 text-amber-100 border-amber-500/40';
  else if (tier === 5) badgeClass = 'bg-rose-950/55 text-rose-200 border-rose-500/40';

  const vel = best.velocity || {};
  const sd = isFinite(vel.sd) ? vel.sd : null;
  const es = isFinite(vel.es) ? vel.es : null;

  const tipLines = [];
  tipLines.push(`Node: ${best.label}`);
  tipLines.push(`Sessions: ${best.sessionCount} ‚Ä¢ Shots: ${best.shots}`);
  if (isFinite(best.mrMoa)) tipLines.push(`MR: ${best.mrMoa.toFixed(3)} MOA (œÉ ${best.mrStd.toFixed(3)})`);
  if (isFinite(best.vertMoa)) tipLines.push(`V: ${best.vertMoa.toFixed(3)} MOA (œÉ ${best.vertStd.toFixed(3)})`);
  if (sd !== null) tipLines.push(`SD: ${sd.toFixed(1)} fps`);
  if (es !== null) tipLines.push(`ES: ${es.toFixed(1)} fps`);
  if (isFinite(best.baseScore)) tipLines.push(`Base score: ${best.baseScore.toFixed(1)}`);
  tipLines.push(`Repeat: ${(best.breakdown.rep*100).toFixed(0)}%`);
  tipLines.push(`V-consistency: ${(best.breakdown.vCons*100).toFixed(0)}%`);
  tipLines.push(`MR-consistency: ${(best.breakdown.mrCons*100).toFixed(0)}%`);
  if (conf !== null) tipLines.push(`Node confidence: ${conf}`);

  const nodeListRows = nodes.map((n,i)=>{
    const c = (n.nodeConfidence !== null) ? Math.round(n.nodeConfidence) : '‚Äî';
    return `<div class="flex items-center justify-between gap-3 py-1 border-b border-white/5 last:border-0">
      <div class="text-sm text-white/90"><span class="opacity-60 mr-2">#${i+1}</span>${_escapeHtml(n.label)}</div>
      <div class="text-xs text-white/70">${n.sessionCount} sess ‚Ä¢ ${n.shots} shots</div>
      <div class="text-sm font-semibold text-white">${c}</div>
    </div>`;
  }).join('');

  return `
    <div class="mt-4 mb-5">
      <div class="flex items-start justify-between gap-3 mb-2">
        <div>
          <div class="text-sm font-semibold text-white/90">Node confidence (by charge)</div>
          <div class="text-xs text-white/60">Aggregated across sessions (repeatability-weighted)</div>
        </div>
        <div class="flex items-center gap-2 flex-wrap justify-end">
          
          
        </div>
      </div>

      <div class="bg-grt-panel border border-grt-frame rounded-2xl p-4">
        <div class="flex items-start justify-between gap-3">
          <div>
            <div class="text-base font-semibold text-white">Most confident node</div>
            <div class="mt-1 text-white/80 text-sm">${_escapeHtml(best.label)}</div>
            <div class="mt-1 text-white/60 text-xs">${best.sessionCount} sessions ‚Ä¢ ${best.shots} shots</div>
          </div>
          <div class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full border ${badgeClass}" title="${_escapeHtml(tipLines.join('\n'))}">
            <span class="h-1.5 w-1.5 rounded-full bg-current opacity-80"></span>
            ${conf !== null ? `NC ${conf}` : 'NC ‚Äî'}
          </div>
        </div>

        <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
          <div><div class="text-white/60 text-xs">MR (agg)</div><div class="text-white font-semibold">${isFinite(best.mrMoa)?best.mrMoa.toFixed(3):'‚Äî'} <span class="text-white/60 text-xs">MOA</span></div></div>
          <div><div class="text-white/60 text-xs">Vertical (agg)</div><div class="text-white font-semibold">${isFinite(best.vertMoa)?best.vertMoa.toFixed(3):'‚Äî'} <span class="text-white/60 text-xs">MOA</span></div></div>
          <div><div class="text-white/60 text-xs">SD (pooled)</div><div class="text-white font-semibold">${sd!==null?sd.toFixed(1):'‚Äî'} <span class="text-white/60 text-xs">fps</span></div></div>
          <div><div class="text-white/60 text-xs">Vertical œÉ</div><div class="text-white font-semibold">${isFinite(best.vertStd)?best.vertStd.toFixed(3):'‚Äî'} <span class="text-white/60 text-xs">MOA</span></div></div>
        </div>

        <details class="mt-4">
          <summary class="cursor-pointer text-xs text-white/70 hover:text-white/90">All nodes (ranked)</summary>
          <div class="mt-3">${nodeListRows}</div>
        </details>
      </div>
    </div>
  `;
}
// =======================
// /ShotMarker Phase C
// =======================
function renderShotMarkerSessionCards() {
            const host = document.getElementById('shotMarkerSessionCards');
            if (!host) return;

            const arr = Array.isArray(shotMarkerAddons) ? shotMarkerAddons : [];
            const addon = arr.length ? arr[0] : null; // single file for now
            const strings = addon && Array.isArray(addon.sessions) ? addon.sessions : [];
            // Re-map on render so chrono imports/edits immediately reflect in cards
            mapShotMarkerSessionsToChronoCharges(strings);
            try { computeShotMarkerPhase2(strings); } catch(e){ console.warn('Phase2 compute failed', e); }

            const picks = _pickSessionCards(strings);
            const rel = _shotMarkerRelativeStats(strings);
            const rankedHtml = _shotMarkerRankedListHtml(strings, rel);
            const phase2TableHtml = _shotMarkerPhase2RankingTableHtml(strings);
            const nodeSection = _shotMarkerNodeSectionHtml(strings);

            if (!addon || !strings.length || (!picks.best && !picks.typical && !picks.worst)) {
                host.innerHTML = '';
                return;
            }

                        const cardHtml = (title, s) => {
              if (!s) return '';
              const d = s.derived || {};
              const m = s.meta || {};
              const shots = (d.shots !== null && isFinite(d.shots)) ? d.shots : (m.shots || 0);
              const mrMoa = (d.mrMoa !== null && isFinite(d.mrMoa)) ? d.mrMoa : null;
              const vertMoa = (d.vertMoa !== null && isFinite(d.vertMoa)) ? d.vertMoa : null;
              const vScore = (d.verticalScore !== null && isFinite(d.verticalScore)) ? Math.round(d.verticalScore) : null;
              const pScore = (d.precisionScore !== null && isFinite(d.precisionScore)) ? Math.round(d.precisionScore) : null;
              const conf = (d.confidenceScore !== null && isFinite(d.confidenceScore)) ? Math.round(d.confidenceScore) : null;
              const fScore = (d.finalScore !== null && isFinite(d.finalScore)) ? Math.round(d.finalScore) : conf;
              const sd = (d.velocity && isFinite(d.velocity.sd)) ? d.velocity.sd : null;
              const es = (d.velocity && isFinite(d.velocity.es)) ? d.velocity.es : null;

              const match = d.chargeMatch || null;
              const matchLabel = match && match.label ? match.label : '';
              const matchConf = match && isFinite(match.confidence) ? Math.round(match.confidence) : null;

              // Simple, chrono-card-like status styling (Absolute tier, score-driven)
              let statusLabel = (fScore !== null) ? `S${_scoreToTier(fScore)}` : '‚Äî';
              let statusClass = 'bg-slate-800/60 text-slate-200 border-slate-500/40';
              let borderClass = 'border-grt-frame';

              const tier = (fScore !== null) ? _scoreToTier(fScore) : null;
              if (tier !== null) {
                if (tier === 1) { statusClass = 'bg-emerald-900/70 text-emerald-200 border-emerald-500/60'; borderClass = 'border-emerald-500/70'; }
                else if (tier === 2) { statusClass = 'bg-sky-900/70 text-sky-200 border-sky-500/60'; borderClass = 'border-sky-500/60'; }
                else if (tier === 3) { statusClass = 'bg-amber-900/60 text-amber-200 border-amber-500/60'; borderClass = 'border-amber-500/60'; }
                else if (tier === 4) { statusClass = 'bg-amber-900/45 text-amber-200 border-amber-500/50'; borderClass = 'border-amber-500/50'; }
                else { statusClass = 'bg-rose-950/50 text-rose-200 border-rose-500/40'; borderClass = 'border-rose-500/40'; }
              }

              // Relative highlights (best-in-this-import)
              const relKey = (m.sessionKey || '');
              const relRank = (rel && rel.rankByKey && relKey && rel.rankByKey[relKey]) ? rel.rankByKey[relKey] : null;
              const relN = (rel && isFinite(rel.n)) ? rel.n : null;
              const isBestComposite = (relKey && rel && rel.bestCompositeKey && relKey === rel.bestCompositeKey);
              const isBestMr = (relKey && rel && rel.bestMrKey && relKey === rel.bestMrKey);
              const isBestVert = (relKey && rel && rel.bestVertKey && relKey === rel.bestVertKey);

              let relBorder = '';
              if (isBestComposite) relBorder = 'ring-2 ring-emerald-400/60';
              else if (isBestMr) relBorder = 'ring-2 ring-yellow-300/50';
              else if (isBestVert) relBorder = 'ring-2 ring-sky-400/50';

              const relPills = `
                ${(isBestComposite) ? `<div class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full border bg-emerald-900/30 text-emerald-200 border-emerald-500/40 text-[11px] md:text-xs" title="Best composite in this import (relative).">
                    <span class="opacity-90">üèÅ</span>Best today
                  </div>` : ''}
                ${(isBestMr && !isBestComposite) ? `<div class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full border bg-yellow-900/25 text-yellow-200 border-yellow-500/35 text-[11px] md:text-xs" title="Best MR in this import (relative).">
                    <span class="opacity-90">üéØ</span>Best MR
                  </div>` : ''}
                ${(isBestVert && !isBestComposite) ? `<div class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full border bg-sky-900/25 text-sky-200 border-sky-500/35 text-[11px] md:text-xs" title="Best vertical control in this import (relative).">
                    <span class="opacity-90">üìè</span>Best V
                  </div>` : ''}
                ${(relRank !== null && relN) ? `<div class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full border bg-grt-frame/30 text-grt-soft border-white/10 text-[11px] md:text-xs" title="Rank within this import (relative).">
                    <span class="opacity-80">#</span>${relRank}/${relN}
                  </div>` : ''}
              `.trim();

              const fmt = (v, digits=3) => (v === null || !isFinite(v)) ? '‚Äì' : v.toFixed(digits);
              const fmt1 = (v) => (v === null || !isFinite(v)) ? '‚Äì' : v.toFixed(1);

              // Breakdown tooltip (MR-first, vertical-critical, 1000y bias)
              const bd = d.scoreBreakdown || null;
              let scoreTooltip = '';
              if (bd && typeof bd === 'object') {
                const p = bd.params || {};
                const lines = [];
                if (m.distanceYd) lines.push(`Distance: ${m.distanceYd} yd`);
                if (isFinite(bd.mrMoa)) lines.push(`MR: ${bd.mrMoa.toFixed(3)} MOA`);
                if (isFinite(bd.vertMoa)) lines.push(`Vertical: ${bd.vertMoa.toFixed(3)} MOA (ref ${isFinite(p.vRef)?p.vRef.toFixed(2):'‚Äî'})`);
                if (isFinite(bd.sdFps)) lines.push(`SD: ${bd.sdFps.toFixed(1)} fps (ref ${isFinite(p.sdRef)?p.sdRef.toFixed(1):'‚Äî'})`);
                else if (isFinite(bd.esFps)) lines.push(`ES: ${bd.esFps.toFixed(1)} fps`);
                if (isFinite(bd.mrScore)) lines.push(`MR score: ${bd.mrScore.toFixed(1)}`);
                if (isFinite(bd.vPenalty)) lines.push(`Vertical penalty: ${(bd.vPenalty*100).toFixed(1)}% (w ${isFinite(p.wV)?p.wV.toFixed(2):'‚Äî'})`);
                if (isFinite(bd.velPenalty)) lines.push(`Velocity penalty: ${(bd.velPenalty*100).toFixed(1)}% (w ${isFinite(p.wVel)?p.wVel.toFixed(2):'‚Äî'})`);
                if (isFinite(bd.finalScore)) lines.push(`Final: ${bd.finalScore.toFixed(1)}`);
                scoreTooltip = lines.join('\n');
              }

              // Manual mapping UI
              const groupsForUI = _getChronoGroupsForMapping();
              const sessionKey = m.sessionKey || _smSessionKey(s);
              const manualIdx = (d.manualChargeIndex !== null && isFinite(d.manualChargeIndex)) ? Number(d.manualChargeIndex) : null;
              const mapSelect = (groupsForUI && groupsForUI.length) ? `
                <div class="mt-2">
                  <label class="text-grt-subtle text-[11px]">Charge link</label>
                  <select data-sm-map="1" data-sm-key="${encodeURIComponent(sessionKey)}"
                          onchange="onSmChargeLinkChange(this)"
                          class="mt-1 w-full bg-grt-panel-soft border border-grt-frame rounded-xl px-2 py-1.5 text-white text-xs">
                    <option value="">${(manualIdx===null) ? `Select‚Ä¶` : `Unlinked`}</option>
                    ${groupsForUI.map(g => {
                      const idx = Number(g.chargeIndex);
                      const label = g.label || ('Charge ' + idx);
                      const sel = (manualIdx !== null && idx === manualIdx) ? 'selected' : '';
                      return `<option value="${idx}" ${sel}>${label}</option>`;
                    }).join('')}
                  </select>
                </div>` : '';

            
              return `
                <div class="bg-grt-panel rounded-2xl shadow-xl p-4 border ${borderClass} ${relBorder}">
                  <div class="flex items-start justify-between gap-3">
                    <div class="min-w-0">
                      <div class="text-white text-base font-semibold" title="${_xqaScoreHintTitle(d.scoreBreakdown || d || {})}">${title}</div>
                      <div class="text-grt-subtle text-xs mt-0.5">
                        ${m.date || ''}${m.relay ? ` ‚Ä¢ ${m.relay}` : ''}${m.label ? ` ‚Ä¢ ${m.label}` : ''}
                      </div>
                    </div>
                    <div class="flex flex-wrap items-center justify-end gap-2 flex-shrink-0">
                      ${(fScore !== null) ? `<div class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full border ${statusClass} text-[11px] md:text-xs" title="${scoreTooltip || 'Score breakdown unavailable'}">
                          <span class="h-1.5 w-1.5 rounded-full bg-current opacity-80"></span>${statusLabel}
                        </div>` : ''}
                      ${relPills}
                      </div>
                  </div>
                  ${mapSelect}
            
                  <div class="mt-3 space-y-1.5 text-sm">
                    <div class="flex items-center justify-between gap-3"><div class="text-grt-subtle">Shots</div><div class="text-white font-semibold">${shots || '‚Äì'}</div></div>
                    <div class="flex items-center justify-between gap-3"><div class="text-grt-subtle">Mean radius</div><div class="text-white font-semibold">${fmt(mrMoa,3)} <span class="text-grt-subtle text-[11px]">MOA</span></div></div>
                    <div class="flex items-center justify-between gap-3"><div class="text-grt-subtle">Vertical</div><div class="text-white font-semibold">${fmt(vertMoa,3)} <span class="text-grt-subtle text-[11px]">MOA</span></div></div>
                    <div class="flex items-center justify-between gap-3"><div class="text-grt-subtle">Scores</div><div class="text-white font-semibold">
                      ${(pScore!==null?`MR ${pScore}`:'MR ‚Äì')} ‚Ä¢ ${(vScore!==null?`V ${vScore}`:'V ‚Äì')}${(conf!==null?` ‚Ä¢ C ${conf}`:'')}
                    </div></div>
                    <div class="flex items-center justify-between gap-3"><div class="text-grt-subtle">Velocity</div><div class="text-white font-semibold">
                      SD ${fmt1(sd)} ‚Ä¢ ES ${fmt1(es)} <span class="text-grt-subtle text-[11px]">fps</span>
                    </div></div>
                  </div>
            
                  <div class="text-grt-subtle text-[10px] md:text-xs mt-2">
                    ${m.targetName ? `<span class="truncate">${m.targetName}</span>` : ''}
                  </div>
                </div>
              `;
            };

            host.innerHTML = `
              ${phase2TableHtml}

              ${nodeSection}
              <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-2xl p-3 mb-3">
                <details>
                  <summary class="cursor-pointer text-white text-sm font-semibold select-none">Advanced scoring knobs</summary>
                  <div class="mt-3 grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
                    <div>
                      <label class="text-grt-subtle">1000y vertical ref (MOA)</label>
                      <input id="smKnob_vRefLong" type="number" step="0.01" min="0.10" max="1.50"
                             class="mt-1 w-full bg-grt-panel-soft border border-grt-frame rounded-xl px-2 py-1.5 text-white"
                             value="${(shotMarkerScoreSettings && shotMarkerScoreSettings.long && isFinite(shotMarkerScoreSettings.long.vRef)) ? shotMarkerScoreSettings.long.vRef : 0.35}">
                    </div>
                    <div>
                      <label class="text-grt-subtle">1000y vertical weight</label>
                      <input id="smKnob_wVLong" type="number" step="0.05" min="0.50" max="3.00"
                             class="mt-1 w-full bg-grt-panel-soft border border-grt-frame rounded-xl px-2 py-1.5 text-white"
                             value="${(shotMarkerScoreSettings && shotMarkerScoreSettings.long && isFinite(shotMarkerScoreSettings.long.wV)) ? shotMarkerScoreSettings.long.wV : 1.50}">
                    </div>
                    <div>
                      <label class="text-grt-subtle">1000y velocity weight</label>
                      <input id="smKnob_wVelLong" type="number" step="0.05" min="0.00" max="2.00"
                             class="mt-1 w-full bg-grt-panel-soft border border-grt-frame rounded-xl px-2 py-1.5 text-white"
                             value="${(shotMarkerScoreSettings && shotMarkerScoreSettings.long && isFinite(shotMarkerScoreSettings.long.wVel)) ? shotMarkerScoreSettings.long.wVel : 0.65}">
                    </div>
                  </div>
                  <div class="mt-3 flex items-center gap-2">
                    <button id="smKnobApply" class="px-3 py-1.5 rounded-xl bg-grt-highlight hover:bg-grt-highlight/80 text-white text-xs font-semibold border border-grt-frame">
                      Apply scoring
                    </button>
                    <span class="text-grt-subtle text-[11px]">Stored in project + this browser.</span>
                  </div>
                </details>
              </div>
<div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                ${cardHtml('Best precision', picks.best)}
                ${cardHtml('Most typical', picks.typical)}
                ${cardHtml('Worst control', picks.worst)}
              </div>
              ${rankedHtml}
            `;

            // Wire manual mapping dropdowns + scoring knobs (persist + re-render)
            host.querySelectorAll('select[data-sm-map]').forEach(sel => {
              sel.onchange = (ev) => {
                const el = ev.target;
                const key = decodeURIComponent(el.getAttribute('data-sm-key') || '');
                const val = el.value;
                if (!key) return;
                if (val === '' || val === null) delete shotMarkerManualMap[key];
                else shotMarkerManualMap[key] = Number(val);
                _saveShotMarkerManualMap();
                renderShotMarkerSessionCards();
                if (typeof renderShotMarkerAddonCards === 'function') renderShotMarkerAddonCards();
              };
            });

            const applyBtn = host.querySelector('#smKnobApply');
            if (applyBtn) {
              applyBtn.onclick = () => {
                const vRef = parseFloat(host.querySelector('#smKnob_vRefLong')?.value);
                const wV = parseFloat(host.querySelector('#smKnob_wVLong')?.value);
                const wVel = parseFloat(host.querySelector('#smKnob_wVelLong')?.value);

                shotMarkerScoreSettings = shotMarkerScoreSettings || {};
                shotMarkerScoreSettings.long = shotMarkerScoreSettings.long || {};
                if (isFinite(vRef)) shotMarkerScoreSettings.long.vRef = vRef;
                if (isFinite(wV)) shotMarkerScoreSettings.long.wV = wV;
                if (isFinite(wVel)) shotMarkerScoreSettings.long.wVel = wVel;
                _saveShotMarkerScoreSettings();

                try {
                  const arr = Array.isArray(shotMarkerAddons) ? shotMarkerAddons : [];
                  const addon = arr.length ? arr[0] : null;
                  const sessions = addon && Array.isArray(addon.sessions) ? addon.sessions : [];
                  sessions.forEach(s => {
                    if (!s || !s.derived) return;
                    const d = s.derived;
                    const m = s.meta || {};
                    const adv = _computeShotMarkerScoreAdvanced(d.mrMoa, d.vertMoa, d.velocity, m.distanceYd);
                    if (!adv) return;
                    d.precisionScore = adv.mrScore;
                    d.verticalScore = adv.vPenalty * 100;
                    d.confidenceScore = adv.finalScore;
                    d.finalScore = adv.finalScore;
                    d.scoreBreakdown = Object.assign({
                      mrMoa: d.mrMoa, vertMoa: d.vertMoa, distanceYd: m.distanceYd,
                      sdFps: (d.velocity && isFinite(d.velocity.sd)) ? d.velocity.sd : null,
                      esFps: (d.velocity && isFinite(d.velocity.es)) ? d.velocity.es : null
                    }, adv);
                  });
                } catch {}
                renderShotMarkerSessionCards();
                if (typeof renderShotMarkerAddonCards === 'function') renderShotMarkerAddonCards();
              };
            }

        }
function addonCardHtml(addon) {
            const metrics = addon.metrics || null;
            const shots = addon.shots || (metrics ? metrics.shots : 0) || 0;
            const rows = addon.rows || 0;
            const es = metrics && isFinite(metrics.es) ? metrics.es : null;
            const mr = metrics && isFinite(metrics.mr) ? metrics.mr : null;

            const statBoxes = (es !== null || mr !== null) ? `
                <div class="grid grid-cols-1 gap-2 mt-3">
                  <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
                    <div class="text-grt-subtle text-[11px]">Extreme spread</div>
                    <div class="text-white font-semibold text-lg">${es !== null ? es.toFixed(3) : '‚Äì'}</div>
                  </div>
                  <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
                    <div class="text-grt-subtle text-[11px]">Mean radius</div>
                    <div class="text-white font-semibold text-lg">${mr !== null ? mr.toFixed(3) : '‚Äì'}</div>
                  </div>
                </div>
            ` : '';

            return `
              <div class="bg-grt-panel rounded-2xl border border-grt-frame p-4">
                <div class="flex items-start justify-between gap-2">
                  <div class="min-w-0">
                    <div class="text-white font-semibold truncate">${addon.filename || 'Add-on file'}</div>
                    <div class="text-grt-subtle text-[11px]">Rows: ${rows} ‚Ä¢ Shots: ${shots}</div>
                  </div>
                  <span class="inline-flex items-center px-2 py-0.5 rounded-full border border-grt-frame bg-grt-panel-soft text-[10px] text-grt-subtle">Loaded</span>
                </div>
                ${statBoxes}
              </div>
            `;
        }

        function renderAddonCards() {
            const arr = Array.isArray(shotMarkerAddons) ? shotMarkerAddons : [];

            const inlineEl = document.getElementById('shotMarkerInlineCards');
            const resultsEl = document.getElementById('shotMarkerResultsCards');

            const html = arr.length
              ? arr.map(addonCardHtml).join('')
              : '<div class="text-grt-subtle text-[11px] md:text-xs">No file loaded</div>';

            if (inlineEl) inlineEl.innerHTML = html;
            if (resultsEl) resultsEl.innerHTML = html;

            refreshAddonsStatus();
            if (typeof renderShotMarkerSessionCards === 'function') renderShotMarkerSessionCards();
        }


        function refreshAddonsStatus() {
            const card = document.getElementById('addonsLoadedCard');
            if (!card) return;

            const anyAddons =
              (Array.isArray(shotMarkerAddons) && shotMarkerAddons.length) ||
              (Array.isArray(importedPictures) && importedPictures.length) ||
              (importedNotesText && importedNotesText.trim().length);

            if (anyAddons) card.classList.remove('hidden');
            else card.classList.add('hidden');

            renderPicsNotesSummaryCards();
        }


        function clearShotMarkerAddons() {
            shotMarkerAddons = [];
            renderAddonCards();
            if (typeof renderShotMarkerSessionCards === 'function') renderShotMarkerSessionCards();
}
        function handleAddonFile(kind, file) {
            if (!file) return;
            if (kind !== 'shotmarker') return; // Ballistic-X removed

            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const rawText = String((ev && ev.target && ev.target.result) ? ev.target.result : '');
                    const isShotslog = rawText.includes('ShotMarker Archived Data') || rawText.includes('Exported ') && rawText.includes(' strings ');
                    let addon = null;

                    if (isShotslog) {
                        const sessions = parseShotMarkerShotslog(rawText);
                        mapShotMarkerSessionsToChronoCharges(sessions);

                        // Aggregate XY across all sessions for a top-level ES/MR summary (optional)
                        const xs = [], ys = [];
                        sessions.forEach(s => {
                            (s.shots || []).forEach(sh => {
                                if (isFinite(sh.xMm) && isFinite(sh.yMm)) { xs.push(sh.xMm); ys.push(sh.yMm); }
                            });
                        });
                        const gm = _computeGroupMetricsFromXY(xs, ys);
                        const metrics = gm ? { shots: gm.shots, es: gm.es, mr: gm.mr } : null;

                        addon = {
                            filename: file.name,
                            rows: sessions.reduce((a,s)=>a + ((s.shots||[]).length), 0),
                            shots: sessions.reduce((a,s)=>a + ((s.shots||[]).length), 0),
                            metrics: metrics,
                            sessions: sessions,
                            rawText: rawText
                        };
                    } else {
                        const parsed = parseSimpleCsv(rawText);
                        const metrics = tryComputeGroupMetrics(parsed);
                        addon = {
                            filename: file.name,
                            rows: (parsed.rows || []).length,
                            shots: (metrics && metrics.shots) ? metrics.shots : (parsed.rows || []).length,
                            metrics: metrics,
                            sessions: [],
                            rawText: rawText
                        };
                    }

                    shotMarkerAddons = [addon];
                    renderAddonCards();
                    setCurrentStep(3);
                    refreshAddonsStatus();
                    showStatus('success', `Loaded ShotMarker add-on: ${file.name}`);
                } catch (err) {
                    showStatus('error', `Could not parse ${file.name}: ${err.message}`);
                }
            };
            reader.readAsText(file);
        }


function refreshPicturesStatus() {
            const picStatus = document.getElementById('picturesStatus');
            if (!picStatus) return;
            if (!importedPictures.length) {
                picStatus.textContent = 'No pictures selected';
            
            refreshAddonsStatus();
        } else {
                picStatus.textContent =
                    importedPictures.length + ' picture' + (importedPictures.length === 1 ? '' : 's') + ' queued';
            }
        }

        function refreshNotesStatus() {
            const notesStatus = document.getElementById('notesStatus');
            if (!notesStatus) return;
            if (!importedNotesText) {
                notesStatus.textContent = 'No notes added';
            
            refreshAddonsStatus();
        } else {
                const approxLines = importedNotesText.split(/\r?\n/).length;
                notesStatus.textContent = 'Notes added (' + approxLines + ' line' + (approxLines === 1 ? '' : 's') + ')';
            }
        }

        function handlePictureFile(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const dataUrl = ev.target.result;
                const m = /^data:(image\/[^;]+);base64,(.+)$/.exec(dataUrl);
                if (!m) {
                    showStatus('error', 'Could not read image file ' + file.name);
                    return;
                }
                const mime = m[1];
                const base64data = m[2];
                const type = (mime.split('/')[1] || 'jpeg').toLowerCase();

                const img = new Image();
                img.onload = () => {
                    const baseName = file.name.replace(/\.[^.]+$/, '');
                    importedPictures.push({
                        filename: file.name,
                        name: baseName,
                        type,
                        width: img.width || 0,
                        height: img.height || 0,
                        data: base64data
                    });
                    refreshPicturesStatus();
                    setCurrentStep(4);
                    showStatus('success', 'Added picture "' + file.name + '" to Imported Pictures tab.');
                };
                img.onerror = () => {
                    showStatus('error', 'Unable to read image dimensions for ' + file.name + ', picture skipped.');
                };
                img.src = dataUrl;
            };
            reader.onerror = () => {
                showStatus('error', 'Unable to read image file ' + file.name);
            };
            reader.readAsDataURL(file);
        }

        function handleNotesFile(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const content = ev.target.result || '';
                if (!content) {
                    showStatus('error', 'Note file "' + file.name + '" is empty.');
                    return;
                }
                const header = '===== ' + file.name + ' =====';
                if (importedNotesText) {
                    importedNotesText += '\n\n' + header + '\n' + content;
                } else {
                    importedNotesText = header + '\n' + content;
                }
                refreshNotesStatus();
                setCurrentStep(4);
                showStatus('success', 'Added notes from "' + file.name + '" to Imported Notes tab.');
            };
            reader.onerror = () => {
                showStatus('error', 'Unable to read notes file ' + file.name);
            };
            reader.readAsText(file);
        }

        (function initPicturesNotes() {
            const picInput = document.getElementById('pictureInput');
            const notesInput = document.getElementById('notesInput');
            const smInput = document.getElementById('shotMarkerInput');

            // ShotMarker CSV (add-on)
            if (smInput) {
                smInput.addEventListener('change', (e) => {
                    try {
                        const file = (e && e.target && e.target.files) ? e.target.files[0] : null;
                        if (!file) return;
                        handleAddonFile('shotmarker', file);
                    } finally {
                        // allow selecting the same file again
                        try { smInput.value = ''; } catch(_e) {}
                    }
                });
            }
if (picInput) {
                picInput.addEventListener('change', (e) => {
                    const files = Array.from(e.target.files || []);
                    if (!files.length) return;
                    files.forEach(handlePictureFile);
                });
            }
            if (notesInput) {
                notesInput.addEventListener('change', (e) => {
                    const files = Array.from(e.target.files || []);
                    if (!files.length) return;
                    files.forEach(handleNotesFile);
                });
            }

            if (smInput) {
                smInput.addEventListener('change', (e) => {
                    const file = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
                    if (!file) return;
                    handleAddonFile('shotmarker', file);
                    e.target.value = '';
                });
            }

            refreshPicturesStatus();
            refreshNotesStatus();
            renderAddonCards();
            })();

        // =======================
        // Drag-and-drop for chrono files
        // =======================
        (function initDropzone() {
            const dz = document.getElementById('multiFileDropzone');
            const input = document.getElementById('garminInput');
            if (!dz || !input) return;

            ['dragenter','dragover'].forEach(evt =>
                dz.addEventListener(evt, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dz.classList.add('border-[var(--grt-accent)]');
                })
            );

            ['dragleave','drop'].forEach(evt =>
                dz.addEventListener(evt, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dz.classList.remove('border-[var(--grt-accent)]');
                })
            );

            dz.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (!files || !files.length) return;
                input.files = files;
                const event = new Event('change', { bubbles: true });
                input.dispatchEvent(event);
            });
        })();

        // =======================
        // Standard (non-ladder) file handling
        // =======================
        document.getElementById('garminInput').addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (!files.length) return;

            if (mode === 'sessions') {
                handleSessionsFileSelection(files);
                return;
            }

            if (mode !== 'normal') return;

            setCurrentStep(4);
            showStatus('loading', 'Processing chronograph files and computing statistics‚Ä¶');
            const fileStatusList = document.getElementById('fileStatusList');
            if (fileStatusList) fileStatusList.innerHTML = '';

            allStats = [];
            let filesProcessed = 0;

            files.forEach((file) => {
                updateFileStatus(file.name, 'pending', 'Processing‚Ä¶');
                const isExcel = file.name.endsWith('.xls') || file.name.endsWith('.xlsx');
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        let stats;
                        if (isExcel) {
                            stats = (chronographType === 'athlon')
                                ? processAthlonExcel(ev.target.result)
                                : processExcel(ev.target.result);
                        } else {
                            stats = processCSV(ev.target.result);
                        }
                        allStats.push({
                            stats,
                            filename: file.name,
                            chargeIndex: null
                        });
                        filesProcessed++;
                        updateFileStatus(
                            file.name,
                            'ok',
                            `${stats.count} shots ‚Ä¢ AVG ${stats.mean.toFixed(1)} ${unitLabel()}`
                        );
                        if (filesProcessed === files.length) {
                            generateOutput();
                            showResults();
                            setCurrentStep(4);
                            showStatus('success', 'All files processed and merged into the GRT project.');
                        }
                    } catch (err) {
                        updateFileStatus(file.name, 'error', err.message);
                        showStatus('error', 'Error in file ' + file.name + ': ' + err.message);
                    }
                };
                if (isExcel) reader.readAsArrayBuffer(file);
                else reader.readAsText(file);
            });
        });

        // Ladder "Process" button
        (function initProcessLadder() {
            const processLadderBtn = document.getElementById('processLadderBtn');
            if (!processLadderBtn) return;
            processLadderBtn.addEventListener('click', () => {
                if (mode !== 'ladder' || ladderDisabled) return;

                const selected = ladderSlots
                    .map((slot, idx) => slot ? { ...slot, stats: slot.stats, filename: slot.filename, chargeIndex: idx + 1 } : null)
                    .filter(Boolean);

                if (selected.length < 2) {
                    showStatus(
                        'error',
                        'Ladder mode requires at least 2 charges with files selected before processing.'
                    );
                    return;
                }
                if (!grtBaseContent) {
                    showStatus(
                        'error',
                        'Ladder mode requires a base .grtload file so charges can be matched by ladder settings.'
                    );
                    return;
                }

                allStats = selected;
                generateOutput();
                showResults();
                setCurrentStep(4);
                showStatus(
                    'success',
                    'Imported ' + selected.length + ' ladder charges into a new ‚ÄúImported Ladder‚Äù tab in the GRT project.'
                );
            });
        })();

        // =======================
        // Chronograph parsing (Garmin Excel)
        // =======================
        
        // =======================
        // Garmin multi-sheet (Sessions) helpers
        // =======================
        function parseGarminRows(rows) {
            if (!rows || !rows.length) {
                throw new Error('Empty or unreadable sheet');
            }

            let headerRowIndex = -1;
            let velocityColIndex = 1;

            outer:
            for (let i = 0; i < Math.min(HEADER_SCAN_ROWS, rows.length); i++) {
                const row = rows[i];
                if (!row) continue;
                for (let c = 0; c < row.length; c++) {
                    const cell = String(row[c] || '').toLowerCase();
                    if (HEADER_PATTERNS.some(p => cell.includes(p))) {
                        headerRowIndex = i;
                        velocityColIndex = c;
                        break outer;
                    }
                }
            }

            if (headerRowIndex === -1) {
                velocityColIndex = 1;
                let firstNumericRow = -1;
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row) continue;
                    const num = parseNumber(row[1]);
                    if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                        firstNumericRow = i;
                        break;
                    }
                }
                if (firstNumericRow === -1) {
                    throw new Error('No valid velocity data found in column B');
                }
                headerRowIndex = Math.max(0, firstNumericRow - 1);
            }

            const headerRow = rows[headerRowIndex] || [];
            let pfColIndex = -1;
            let timeColIndex = -1;
            for (let c = 0; c < headerRow.length; c++) {
                const cell = String(headerRow[c] || '').toLowerCase();
                if (pfColIndex === -1 && (cell.includes('pf') || cell.includes('power factor'))) {
                    pfColIndex = c;
                }
                if (timeColIndex === -1 && (cell.includes('time') || cell.includes('timestamp') || cell.includes('date/time') || cell.includes('date time'))) {
                    timeColIndex = c;
                }
            }

            const velocities = [];
            const shotMeta = [];
            const garminStats = {
                avg: null,
                sd: null,
                es: null,
                min: null,
                max: null,
                powerFactorAvg: null,
                energyAvg: null
            };

            for (let i = headerRowIndex + 1; i < rows.length; i++) {
                const row = rows[i];
                if (!row) continue;

                const label = String(row[0] || '').toLowerCase().trim();
                const valueCell = row[velocityColIndex];
                const num = parseNumber(valueCell);

                const pfRaw = (pfColIndex >= 0 && pfColIndex < row.length) ? row[pfColIndex] : null;
                const pfVal = (pfRaw !== null && pfRaw !== undefined && pfRaw !== '') ? String(pfRaw).trim() : null;
                const timeRaw = (timeColIndex >= 0 && timeColIndex < row.length) ? row[timeColIndex] : null;
                const timeStr = (timeRaw !== null && timeRaw !== undefined && timeRaw !== '') ? String(timeRaw).trim() : null;

                if (label.includes('avg') || label.includes('average') || label.includes('mean')) {
                    garminStats.avg = num;
                    continue;
                }
                if (label.includes('sd') || label.includes('standard deviation')) {
                    garminStats.sd = num;
                    continue;
                }
                if (label.includes('es') || label.includes('extreme spread')) {
                    garminStats.es = num;
                    continue;
                }
                if (label.includes('min') && !label.includes('admin')) {
                    garminStats.min = num;
                    continue;
                }
                if (label.includes('max') && !label.includes('maxi')) {
                    garminStats.max = num;
                    continue;
                }
                if (label.includes('power factor')) {
                    garminStats.powerFactorAvg = String(valueCell || '').trim();
                    continue;
                }
                if (label.includes('energy')) {
                    garminStats.energyAvg = String(valueCell || '').trim();
                    continue;
                }

                if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                    velocities.push(num);
                    shotMeta.push({
                        pf: pfVal,
                        time: timeStr
                    });
                }
            }

            const stats = computeStats(velocities);

            
            xqaAugmentVelocityStats(stats, velocities);
if (!isValidNumber(garminStats.avg)) garminStats.avg = stats.mean;
            if (!isValidNumber(garminStats.sd))  garminStats.sd  = stats.sd;
            if (!isValidNumber(garminStats.es))  garminStats.es  = stats.es;
            if (!isValidNumber(garminStats.min)) garminStats.min = stats.min;
            if (!isValidNumber(garminStats.max)) garminStats.max = stats.max;

            return { ...stats, velocities, garminStats, shotMeta };
        }

        function processGarminSessionsWorkbook(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const results = [];

            workbook.SheetNames.forEach((sheetName, idx) => {
                const sheet = workbook.Sheets[sheetName];
                if (!sheet) return;

                const rows = XLSX.utils.sheet_to_json(sheet, {
                    header: 1,
                    raw: false,
                    defval: ''
                });
                if (!rows || !rows.length) return;

                try {
                    const stats = parseGarminRows(rows);
                    results.push({
                        stats,
                        filename: sheetName || `Session-${idx + 1}`,
                        sessionIndex: idx + 1
                    });
                } catch (e) {
                    console.warn('Bad session sheet', sheetName, e);
                }
            });

            return results;
        }

        function handleSessionsFileSelection(files) {
            const file = files && files[0];
            if (!file) return;

            const nameLower = file.name.toLowerCase();
            if (!nameLower.endsWith('.xls') && !nameLower.endsWith('.xlsx')) {
                showStatus('error', 'Select a Garmin .xls workbook');
                return;
            }

            if (chronographType !== 'garmin') {
                showStatus('error', 'Measurements Sessions mode supports Garmin only.');
                return;
            }

            setCurrentStep(4);
            showStatus('loading', 'Processing Garmin sessions workbook‚Ä¶');
            const fileStatusList = document.getElementById('fileStatusList');
            if (fileStatusList) fileStatusList.innerHTML = '';
            updateFileStatus(file.name, 'pending', 'Reading workbook‚Ä¶');

            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const sessions = processGarminSessionsWorkbook(ev.target.result) || [];
                    if (!sessions.length) {
                        updateFileStatus(file.name, 'error', 'No usable session sheets found.');
                        showStatus('error', 'No usable session sheets found in this workbook.');
                        return;
                    }

                    allStats = sessions.map((s) => ({
                        stats: s.stats,
                        filename: s.filename,
                        chargeIndex: null
                    }));

                    generateOutput();
                    showResults();
                    setCurrentStep(4);
                    updateFileStatus(file.name, 'ok', `${sessions.length} sessions imported`);
                    showStatus('success', `Imported ${sessions.length} Garmin sessions.`);
                } catch (err) {
                    updateFileStatus(file.name, 'error', err.message);
                    showStatus('error', 'Error processing Garmin sessions workbook: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

function processExcel(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(firstSheet, {
                header: 1,
                raw: false,
                defval: ''
            });

            if (!rows || !rows.length) {
                throw new Error('Empty or unreadable sheet');
            }

            // Garmin vs Athlon safeguard
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i] || [];
                const lower = row.map(v => String(v || '').trim().toLowerCase());
                if (lower[0].includes('shot #') && lower.some(c => c.includes('speed'))) {
                    throw new Error(
                        'File looks like an Athlon Rangecraft export (Shot # / Speed header), ' +
                        'but "Garmin Xero C1 Pro" is selected. Please change the Chronograph dropdown and try again.'
                    );
                }
            }

            let headerRowIndex = -1;
            let velocityColIndex = 1;

            outer:
            for (let i = 0; i < Math.min(HEADER_SCAN_ROWS, rows.length); i++) {
                const row = rows[i];
                if (!row) continue;
                for (let c = 0; c < row.length; c++) {
                    const cell = String(row[c] || '').toLowerCase();
                    if (HEADER_PATTERNS.some(p => cell.includes(p))) {
                        headerRowIndex = i;
                        velocityColIndex = c;
                        break outer;
                    }
                }
            }

            if (headerRowIndex === -1) {
                velocityColIndex = 1;
                let firstNumericRow = -1;
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (!row) continue;
                    const num = parseNumber(row[1]);
                    if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                        firstNumericRow = i;
                        break;
                    }
                }
                if (firstNumericRow === -1) {
                    throw new Error('No valid velocity data found in column B');
                }
                headerRowIndex = Math.max(0, firstNumericRow - 1);
            }

            const headerRow = rows[headerRowIndex] || [];
            let pfColIndex = -1;
            let timeColIndex = -1;
            for (let c = 0; c < headerRow.length; c++) {
                const cell = String(headerRow[c] || '').toLowerCase();
                if (pfColIndex === -1 && (cell.includes('pf') || cell.includes('power factor'))) {
                    pfColIndex = c;
                }
                if (timeColIndex === -1 && (cell.includes('time') || cell.includes('timestamp') || cell.includes('date/time') || cell.includes('date time'))) {
                    timeColIndex = c;
                }
            }

            const velocities = [];
            const shotMeta = [];
            const garminStats = {
                avg: null, sd: null, es: null, min: null, max: null,
                powerFactorAvg: null, energyAvg: null
            };

            for (let i = headerRowIndex + 1; i < rows.length; i++) {
                const row = rows[i];
                if (!row) continue;

                const label = String(row[0] || '').toLowerCase().trim();
                const valueCell = row[velocityColIndex];
                const num = parseNumber(valueCell);

                const pfRaw = (pfColIndex >= 0 && pfColIndex < row.length) ? row[pfColIndex] : null;
                const pfVal = (pfRaw !== null && pfRaw !== undefined && pfRaw !== '') ? String(pfRaw).trim() : null;
                const timeRaw = (timeColIndex >= 0 && timeColIndex < row.length) ? row[timeColIndex] : null;
                const timeStr = (timeRaw !== null && timeRaw !== undefined && timeRaw !== '') ? String(timeRaw).trim() : null;

                if (label.includes('avg') || label.includes('average') || label.includes('mean')) {
                    garminStats.avg = num;
                    continue;
                }
                if (label.includes('sd') || label.includes('standard deviation')) {
                    garminStats.sd = num;
                    continue;
                }
                if (label.includes('es') || label.includes('extreme spread')) {
                    garminStats.es = num;
                    continue;
                }
                if (label.includes('min') && !label.includes('admin')) {
                    garminStats.min = num;
                    continue;
                }
                if (label.includes('max') && !label.includes('maxi')) {
                    garminStats.max = num;
                    continue;
                }
                if (label.includes('power factor')) {
                    garminStats.powerFactorAvg = String(valueCell || '').trim();
                    continue;
                }
                if (label.includes('energy')) {
                    garminStats.energyAvg = String(valueCell || '').trim();
                    continue;
                }

                if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                    velocities.push(num);
                    shotMeta.push({
                        pf: pfVal,
                        time: timeStr
                    });
                }
            }

            const stats = computeStats(velocities);

            
            xqaAugmentVelocityStats(stats, velocities);
if (!isValidNumber(garminStats.avg)) garminStats.avg = stats.mean;
            if (!isValidNumber(garminStats.sd))  garminStats.sd  = stats.sd;
            if (!isValidNumber(garminStats.es))  garminStats.es  = stats.es;
            if (!isValidNumber(garminStats.min)) garminStats.min = stats.min;
            if (!isValidNumber(garminStats.max)) garminStats.max = stats.max;

            return { ...stats, velocities, garminStats, shotMeta };
        }

        // =======================
        // Athlon Excel
        // =======================
        function processAthlonExcel(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(firstSheet, {
                header: 1,
                raw: false,
                defval: ''
            });

            if (!rows || !rows.length) {
                throw new Error('Empty or unreadable Athlon sheet');
            }

            let headerRowIndex = -1;
            let speedColIndex = -1;

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i] || [];
                const lower = row.map(v => String(v || '').trim().toLowerCase());
                if (lower[0].includes('shot #') && lower.some(c => c.includes('speed'))) {
                    headerRowIndex = i;
                    speedColIndex = lower.findIndex(c => c.includes('speed'));
                    break;
                }
            }

            if (headerRowIndex === -1 || speedColIndex === -1) {
                throw new Error(
                    'File does not look like an Athlon Rangecraft export (no "Shot #"/"Speed" header found). ' +
                    'Check that "Athlon Rangecraft Velocity Pro" is selected and you picked the right file.'
                );
            }

            const headerRow = rows[headerRowIndex] || [];
            let pfColIndex = -1;
            let timeColIndex = -1;
            for (let c = 0; c < headerRow.length; c++) {
                const cell = String(headerRow[c] || '').toLowerCase();
                if (pfColIndex === -1 && (cell.includes('pf') || cell.includes('power factor'))) {
                    pfColIndex = c;
                }
                if (timeColIndex === -1 && (cell.includes('time') || cell.includes('timestamp') || cell.includes('date/time') || cell.includes('date time'))) {
                    timeColIndex = c;
                }
            }

            const velocities = [];
            const shotMeta = [];

            for (let i = headerRowIndex + 1; i < rows.length; i++) {
                const row = rows[i] || [];
                const first = String(row[0] || '').trim();
                if (!first) break;
                const shotNum = parseFloat(first.replace(',', '.'));
                if (isNaN(shotNum)) break;

                const cell = row[speedColIndex];
                const v = parseNumber(cell);
                if (!isNaN(v) && v > VELOCITY_MIN && v < VELOCITY_MAX) {
                    const pfRaw = (pfColIndex >= 0 && pfColIndex < row.length) ? row[pfColIndex] : null;
                    const pfVal = (pfRaw !== null && pfRaw !== undefined && pfRaw !== '') ? String(pfRaw).trim() : null;
                    const timeRaw = (timeColIndex >= 0 && timeColIndex < row.length) ? row[timeColIndex] : null;
                    const timeStr = (timeRaw !== null && timeRaw !== undefined && timeRaw !== '') ? String(timeRaw).trim() : null;

                    velocities.push(v);
                    shotMeta.push({
                        pf: pfVal,
                        time: timeStr
                    });
                }
            }

            if (!velocities.length) {
                throw new Error('No valid Athlon velocity data found');
            }

            const garminStats = {
                avg: null, sd: null, es: null, min: null, max: null,
                powerFactorAvg: null, energyAvg: null
            };

            function numFromText(text) {
                const cleaned = String(text || '')
                    .replace(/[^0-9,.\-]/g, '')
                    .replace(',', '.');
                const num = parseFloat(cleaned);
                return isNaN(num) ? null : num;
            }

            rows.forEach(row => {
                row = row || [];
                const label = String(row[0] || '').trim().toLowerCase();
                const val = row.length > 1 ? row[1] : '';
                if (!label) return;

                if (label.startsWith('average velocity')) {
                    garminStats.avg = numFromText(val);
                } else if (label.startsWith('minimum velocity')) {
                    garminStats.min = numFromText(val);
                } else if (label.startsWith('maximum velocity')) {
                    garminStats.max = numFromText(val);
                } else if (label.startsWith('standard deviation')) {
                    garminStats.sd = numFromText(val);
                } else if (label.startsWith('extreme spread')) {
                    garminStats.es = numFromText(val);
                } else if (label.startsWith('average power factor')) {
                    garminStats.powerFactorAvg = String(val || '').trim();
                } else if (label.startsWith('average kinetic energy')) {
                    garminStats.energyAvg = String(val || '').trim();
                }
            });

            const stats = computeStats(velocities);

            
            xqaAugmentVelocityStats(stats, velocities);
if (!isValidNumber(garminStats.avg)) garminStats.avg = stats.mean;
            if (!isValidNumber(garminStats.sd))  garminStats.sd  = stats.sd;
            if (!isValidNumber(garminStats.es))  garminStats.es  = stats.es;
            if (!isValidNumber(garminStats.min)) garminStats.min = stats.min;
            if (!isValidNumber(garminStats.max)) garminStats.max = stats.max;

            return { ...stats, velocities, garminStats, shotMeta };
        }

        // =======================
        // CSV
        // =======================
        function processCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (!lines.length) throw new Error('Empty or unreadable CSV');
            const firstLine = lines[0];
            const delimiter = firstLine.includes(';') ? ';' : ',';

            let headerLineIdx = -1;
            let velocityColIndex = 1;

            outer:
            for (let i = 0; i < Math.min(CSV_HEADER_SCAN_LINES, lines.length); i++) {
                const parts = lines[i].split(delimiter);
                for (let c = 0; c < parts.length; c++) {
                    const cell = parts[c].toLowerCase();
                    if (HEADER_PATTERNS.some(p => cell.includes(p))) {
                        headerLineIdx = i;
                        velocityColIndex = c;
                        break outer;
                    }
                }
            }

            if (headerLineIdx === -1) {
                let firstNumericLine = -1;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const values = line.split(delimiter);
                    if (values.length < 2) continue;
                    const num = parseNumber(values[1]);
                    if (!isNaN(num) && num > VELOCITY_MIN && num < VELOCITY_MAX) {
                        firstNumericLine = i;
                        break;
                    }
                }
                if (firstNumericLine === -1) {
                    throw new Error('No valid velocity data found');
                }
                headerLineIdx = Math.max(0, firstNumericLine - 1);
            }

            const headerValues = (lines[headerLineIdx] || '').split(delimiter);
            let pfColIndex = -1;
            let timeColIndex = -1;
            for (let c = 0; c < headerValues.length; c++) {
                const cell = headerValues[c].toLowerCase();
                if (pfColIndex === -1 && (cell.includes('pf') || cell.includes('power factor'))) {
                    pfColIndex = c;
                }
                if (timeColIndex === -1 && (cell.includes('time') || cell.includes('timestamp') || cell.includes('date/time') || cell.includes('date time'))) {
                    timeColIndex = c;
                }
            }

            const velocities = [];
            const shotMeta = [];
            const garminStats = { avg: null, sd: null, es: null, min: null, max: null };

            for (let i = headerLineIdx + 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const values = line.split(delimiter);
                const firstCol = values[0] ? values[0].toLowerCase().trim() : '';

                if (firstCol.includes('avg') || firstCol.includes('average') || firstCol.includes('mean')) {
                    garminStats.avg = parseNumber(values[1]);
                    continue;
                }
                if (firstCol.includes('sd')) {
                    garminStats.sd = parseNumber(values[1]);
                    continue;
                }
                if (firstCol.includes('es')) {
                    garminStats.es = parseNumber(values[1]);
                    continue;
                }
                if (firstCol.includes('min')) {
                    garminStats.min = parseNumber(values[1]);
                    continue;
                }
                if (firstCol.includes('max')) {
                    garminStats.max = parseNumber(values[1]);
                    continue;
                }

                const velocity = parseNumber(values[velocityColIndex]);
                if (!isNaN(velocity) && velocity > VELOCITY_MIN && velocity < VELOCITY_MAX) {
                    const pfRaw = (pfColIndex >= 0 && pfColIndex < values.length) ? values[pfColIndex] : null;
                    const pfVal = (pfRaw !== null && pfRaw !== undefined && pfRaw !== '') ? String(pfRaw).trim() : null;
                    const timeRaw = (timeColIndex >= 0 && timeColIndex < values.length) ? values[timeColIndex] : null;
                    const timeStr = (timeRaw !== null && timeRaw !== undefined && timeRaw !== '') ? String(timeRaw).trim() : null;

                    velocities.push(velocity);
                    shotMeta.push({
                        pf: pfVal,
                        time: timeStr
                    });
                }
            }

            const stats = computeStats(velocities);

            
            xqaAugmentVelocityStats(stats, velocities);
if (!isValidNumber(garminStats.avg)) garminStats.avg = stats.mean;
            if (!isValidNumber(garminStats.sd))  garminStats.sd  = stats.sd;
            if (!isValidNumber(garminStats.es))  garminStats.es  = stats.es;
            if (!isValidNumber(garminStats.min)) garminStats.min = stats.min;
            if (!isValidNumber(garminStats.max)) garminStats.max = stats.max;

            return { ...stats, velocities, garminStats, shotMeta };
        }

        // =======================
        // GRT XML generation helpers
        // =======================
        function getNextAppendixIndex(inner) {
            const re = /<(Measurement|gallery|note)\b[^>]*\bindex="(\d+)"/g;
            let max = 0;
            let m;
            while ((m = re.exec(inner)) !== null) {
                const val = parseInt(m[2], 10);
                if (!isNaN(val) && val > max) max = val;
            }
            return max + 1;
        }

        function stripExistingImportedMeasurement(inner, titleEncoded) {
            const re = new RegExp(
                `<Measurement[^>]*title="${titleEncoded}"[\s\S]*?<\/Measurement>`,
                'g'
            );
            return inner.replace(re, '');
        }

        function getUniqueImportedTitle(inner, baseTitleEncoded) {
            if (!inner || !baseTitleEncoded) return baseTitleEncoded || '';
            let suffix = 0;
            while (true) {
                const candidate = suffix === 0
                    ? baseTitleEncoded
                    : `${baseTitleEncoded}-${suffix}`;
                if (inner.indexOf(`title="${candidate}"`) === -1) {
                    return candidate;
                }
                suffix++;
                if (suffix > 99) {
                    // Fallback to a time-based suffix to avoid an infinite loop
                    return `${baseTitleEncoded}-${Date.now()}`;
                }
            }
        }


function stripExistingImportedGallery(inner) {
            const re = /<gallery[^>]*title="Imported Pictures"[\s\S]*?<\/gallery>/g;
            return inner.replace(re, '');
        }

        function stripExistingImportedNote(inner) {
            const re = /<note[^>]*title="Imported Notes"[^>]*\/>/g;
            return inner.replace(re, '');
        }

        function appendImportedPicturesAndNotes(inner) {
            let current = inner;

            if (importedPictures && importedPictures.length) {
                const galleryTitle = getUniqueImportedTitle(current, 'Imported Pictures');
                let idx = getNextAppendixIndex(current);
                let gallery = `      <gallery index="${idx}" hasfocus="false" showinreport="true" title="${galleryTitle}">\n`;
                importedPictures.forEach((pic) => {
                    const baseName = (pic.name || pic.filename || 'Picture')
                        .replace(/\.[^.]+$/, '')
                        .replace(/_/g, ' ');
                    const nameEncoded = encodeURIComponent(baseName);
                    const type = pic.type || 'jpeg';
                    const width = pic.width || 0;
                    const height = pic.height || 0;
                    gallery += `        <picture name="${nameEncoded}" type="${type}" width="${width}" height="${height}" data="${pic.data}" />\n`;
                });
                gallery += '      </gallery>\n';
                current += '\n' + gallery;
            }

            if (importedNotesText && importedNotesText.trim()) {
                const noteTitle = getUniqueImportedTitle(current, 'Imported Notes');
                let idx = getNextAppendixIndex(current);
                const encodedText = encodeURIComponent(importedNotesText);
                const note = `      <note index="${idx}" hasfocus="false" showinreport="true" reporttemplate="false" title="${noteTitle}" text="${encodedText}" selstart="0" sellength="0" scrollposition="0" config="${DEFAULT_NOTE_CONFIG}" />\n`;
                current += '\n' + note;
            }


            // Append ShotMarker as notes (appendix tabs)
            function buildAddonText(title, arr) {
                if (!Array.isArray(arr) || !arr.length) return '';
                const a = arr[0];
                const lines = [];
                lines.push(`${title} import`);
                lines.push(`File: ${a.filename || ''}`);
                lines.push(`Rows: ${a.rows || 0}`);
                if (a.metrics && isFinite(a.metrics.es)) lines.push(`Extreme spread (mm): ${a.metrics.es}`);
                if (a.metrics && isFinite(a.metrics.mr)) lines.push(`Mean radius (mm): ${a.metrics.mr}`);
                lines.push('');

                // ShotMarker shotslog: include the same "Best/Typical/Worst" summaries that appear in UI cards.
                if (title === 'ShotMarker' && Array.isArray(a.sessions) && a.sessions.length && typeof _pickSessionCards === 'function') {
                    const picks = _pickSessionCards(a.sessions);

                    const fmt = (v, d=3) => (v === null || !isFinite(v)) ? '‚Äì' : Number(v).toFixed(d);
                    const fmt1 = (v) => (v === null || !isFinite(v)) ? '‚Äì' : Number(v).toFixed(1);

                    const pushSession = (label, s) => {
                        if (!s) return;
                        const d = s.derived || {};
                        const m = s.meta || {};
                        lines.push(`${label}`);
                        if (m.date || m.relay || m.label) lines.push(`  Session: ${(m.date||'').trim()}${m.relay?` ‚Ä¢ ${m.relay}`:''}${m.label?` ‚Ä¢ ${m.label}`:''}`);
                        if (m.distanceYd) lines.push(`  Distance: ${m.distanceYd} yd`);
                        if (m.scoreText) lines.push(`  Score: ${m.scoreText}`);
                        const shots = (d.shots !== null && isFinite(d.shots)) ? d.shots : null;
                        if (shots !== null) lines.push(`  Shots: ${shots}`);
                        if (isFinite(d.mrMoa)) lines.push(`  MR: ${fmt(d.mrMoa)} MOA`);
                        if (isFinite(d.vertMoa)) lines.push(`  Vertical: ${fmt(d.vertMoa)} MOA`);
                        const pScore = isFinite(d.precisionScore) ? Math.round(d.precisionScore) : null;
                        const vScore = isFinite(d.verticalScore) ? Math.round(d.verticalScore) : null;
                        const cScore = isFinite(d.confidenceScore) ? Math.round(d.confidenceScore) : null;
                        if (pScore!==null || vScore!==null || cScore!==null) {
                            lines.push(`  Scores: MR ${pScore ?? '‚Äì'} ‚Ä¢ V ${vScore ?? '‚Äì'} ‚Ä¢ C ${cScore ?? '‚Äì'}`);
                        }
                        if (d.velocity && (isFinite(d.velocity.sd) || isFinite(d.velocity.es))) {
                            lines.push(`  Velocity: SD ${fmt1(d.velocity.sd)} ‚Ä¢ ES ${fmt1(d.velocity.es)} fps`);
                        }
                        lines.push('');
                    };

                    pushSession('Best precision', picks.best);
                    pushSession('Most typical', picks.typical);
                    pushSession('Worst control', picks.worst);
                }

                return lines.join('\n');
            }


            if (shotMarkerAddons && shotMarkerAddons.length) {
                const smTitle = getUniqueImportedTitle(current, 'ShotMarker');
                let idx = getNextAppendixIndex(current);
                const text = buildAddonText('ShotMarker', shotMarkerAddons);
                const encodedText = encodeURIComponent(text);

                // Persist ShotMarker manual mapping + scoring settings as XML attributes (hidden from note text)
                let _xqaSmMap = '';
                let _xqaSmSet = '';
                try { _xqaSmMap = btoa(JSON.stringify(shotMarkerManualMap || {})); } catch {}
                try { _xqaSmSet = btoa(JSON.stringify(shotMarkerScoreSettings || null)); } catch {}
                const note = `      <note index="${idx}" hasfocus="false" showinreport="true" reporttemplate="false" title="${smTitle}" text="${encodedText}" selstart="0" sellength="0" scrollposition="0" xqa_sm_manual_map="${_xqaSmMap}" xqa_sm_score_settings="${_xqaSmSet}" config="${DEFAULT_NOTE_CONFIG}" />\n`;
                current += '\n' + note;
            }

            


            if ((function(){ const cb=document.getElementById('exportAnalysisTab'); if(cb) return !!cb.checked; const saved=localStorage.getItem('xqa_exportAnalysisTab'); return saved===null ? false : (saved==='true'); })() && analysisNoteText && analysisNoteText.trim() && analysisNoteText !== 'No session data loaded yet.') {
                const analysisTitle = getUniqueImportedTitle(current, 'Analysis');
                let idx = getNextAppendixIndex(current);
                const encodedAnalysis = encodeURIComponent(analysisNoteText);
                const analysisNote = `      <note index="${idx}" hasfocus="false" showinreport="true" reporttemplate="false" title="${analysisTitle}" text="${encodedAnalysis}" selstart="0" sellength="0" scrollposition="0" config="${DEFAULT_NOTE_CONFIG}" />\n`;
                current += '\n' + analysisNote;
            }

            if (shouldExportChronoSimTab() && ensureChronoSimPngData()) {
                const chronoTitle = getUniqueImportedTitle(current, 'Chrono vs Sim');
                let idx = getNextAppendixIndex(current);
                const chronoGallery =
                    `      <gallery index="${idx}" hasfocus="false" showinreport="true" title="${chronoTitle}">\n` +
                    `        <picture name="Chrono vs Sim" type="png" width="${chronoSimImageWidth}" height="${chronoSimImageHeight}" data="${chronoSimPngData}" />\n` +
                    '      </gallery>\n';
                current += '\n' + chronoGallery;
            }

            return current;
        }

        function generateChargeXML(item, opts) {
            const s = item.stats;
            const chargeIndex = opts.chargeIndex || 1;
            const modeLocal = opts.mode || 'standard';

            const velocitiesSource = s.velocities || [];
            const shotMetaRaw = Array.isArray(s.shotMeta) ? s.shotMeta : null;

            const velocitiesMs = velocitiesSource.map(v =>
                unit === 'imperial' ? fpsToMps(v) : v
            );

            const avgFileUnit = isValidNumber(s.garminStats.avg) ? s.garminStats.avg : s.mean;
            const sdFileUnit  = isValidNumber(s.garminStats.sd)  ? s.garminStats.sd  : s.sd;
            const esFileUnit  = isValidNumber(s.garminStats.es)  ? s.garminStats.es  : s.es;
            const minFileUnit = isValidNumber(s.garminStats.min) ? s.garminStats.min : s.min;
            const maxFileUnit = isValidNumber(s.garminStats.max) ? s.garminStats.max : s.max;

            function fmt(x) {
                return (typeof x === 'number' && isFinite(x)) ? x.toFixed(1) : '';
            }

            const notes = [];
            const avgLabel = 'AVG-E=';
            if (isFinite(avgFileUnit)) notes.push(avgLabel + fmt(avgFileUnit));
            if (isFinite(sdFileUnit))  notes.push('SD=' + fmt(sdFileUnit));
                        try{ const _sd = xqaGetVelocitySD(s); notes.push('SD_SRC=' + String(_sd.src||'').replace(/\s+/g,'_')); }catch(_e){}
if (isFinite(esFileUnit))  notes.push('ES=' + fmt(esFileUnit));
            if (isFinite(minFileUnit)) notes.push('MIN=' + fmt(minFileUnit));
            if (isFinite(maxFileUnit)) notes.push('MAX=' + fmt(maxFileUnit));

            if (s.garminStats.powerFactorAvg) {
                notes.push('POWER%20FACTOR=' + String(s.garminStats.powerFactorAvg).replace(/\s+/g, '%20'));
            }
            if (s.garminStats.energyAvg) {
                notes.push('ENERGY=' + String(s.garminStats.energyAvg).replace(/\s+/g, '%20'));
            }
            notes.push('UNIT=' + (unit === 'imperial' ? 'ft/s' : 'm/s'));
            const noteAttr = notes.join('%20');

            const mcG = getMcG();
            let valueKg;

            if (modeLocal === 'ladder') {
                const totalSteps =
                    (typeof grtLadderSteps === 'number' && grtLadderSteps >= 2 && grtLadderSteps <= 10)
                        ? grtLadderSteps
                        : (ladderSteps || 10);

                const stepG = (typeof ladderStepMassG === 'number' && ladderStepMassG > 0)
                    ? ladderStepMassG
                    : 0;

                if (stepG > 0 && totalSteps >= 2) {
                    const massG = mcG - (totalSteps - chargeIndex) * stepG;
                    valueKg = massG / 1000;
                } else {
                    valueKg = mcG / 1000;
                }
            } else {
                valueKg = mcG / 1000;
            }

            if (!isFinite(valueKg) || valueKg <= 0) valueKg = 0.002;

            let chargeName;
            if (modeLocal === 'ladder') {
                if (ladderNameMode === 'charge') {
                    const label = 'Charge ' + chargeIndex;
                    chargeName = encodeURIComponent(label);
                } else {
                    const baseName = (item.filename || ('Charge ' + chargeIndex))
                        .replace(/\.(csv|xls|xlsx)$/i, '')
                        .replace(/_/g, ' ');
                    chargeName = encodeURIComponent(baseName);
                }
            } else {
                const baseName = (item.filename || 'Charge')
                    .replace(/\.(csv|xls|xlsx)$/i, '')
                    .replace(/_/g, ' ');
                chargeName = encodeURIComponent(baseName);
            }

            let xml = `        <charge name="${chargeName}" showinreport="true" expanded="true" expandedstats="true" note="${noteAttr}" value="${valueKg.toFixed(12)}" source="Chronograph%20Import">\n`;

            for (let i = 0; i < velocitiesMs.length; i++) {
                const vMs = velocitiesMs[i];
                if (!isFinite(vMs)) continue;
                const meta = shotMetaRaw && shotMetaRaw[i] ? shotMetaRaw[i] : {};
                const pf = meta.pf;
                const timeStr = meta.time;

                const notePieces = [];
                if (pf !== null && pf !== undefined && String(pf).trim() !== '') {
                    const pfClean = String(pf).trim().replace(/\s+/g, '%20');
                    notePieces.push('PF=' + pfClean);
                }

                let datePart = null;
                if (timeStr && /[\/-]/.test(timeStr)) {
                    const parsed = new Date(timeStr);
                    if (!isNaN(parsed.getTime())) {
                        const year = parsed.getFullYear();
                        const month = String(parsed.getMonth() + 1).padStart(2, '0');
                        const day = String(parsed.getDate()).padStart(2, '0');
                        datePart = `${year}-${month}-${day}`;
                    }
                }

                if (timeStr) {
                    const timeEncoded = encodeURIComponent(String(timeStr));
                    notePieces.push('TIME=' + timeEncoded);
                }
                if (datePart) {
                    const dateEncoded = encodeURIComponent(datePart);
                    notePieces.push('DATE=' + dateEncoded);
                }

                const shotNoteAttr = notePieces.length
                    ? ` note="${notePieces.join('%20')}"`
                    : '';

                xml += `          <shot name="" velocity="${vMs.toFixed(1)}" pressure="0"${shotNoteAttr} />\n`;
            }

            xml += '        </charge>\n';
            return xml;
        }

        function generateImportedMeasurementXML(inner) {
            const title = getUniqueImportedTitle(inner, 'Imported%20Measurement');
            const idx = getNextAppendixIndex(inner);
            let xml = `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
            allStats.forEach((item, i) => {
                xml += generateChargeXML(item, {
                    mode: 'standard',
                    chargeIndex: i + 1
                });
            });
            xml += '      </Measurement>\n';
            const updatedInner = inner + '\n' + xml;
            return appendImportedPicturesAndNotes(updatedInner);
        }


function generateImportedLadderXML(inner) {
            const title = getUniqueImportedTitle(inner, 'Imported%20Ladder');
            const idx = getNextAppendixIndex(inner);
            let xml = `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
            allStats.forEach((item) => {
                xml += generateChargeXML(item, {
                    mode: 'ladder',
                    chargeIndex: item.chargeIndex || 1
                });
            });
            xml += '      </Measurement>\n';
            const updatedInner = inner + '\n' + xml;
            return appendImportedPicturesAndNotes(updatedInner);
        }



        function generateImportedSessionsXML(inner) {
            let updated = inner;

            const layout = (typeof sessionsLayout === 'string') ? sessionsLayout : 'compact';

            if (!allStats || !allStats.length) {
                return appendImportedPicturesAndNotes(updated);
            }

            if (layout === 'legacy') {
                allStats.forEach((item, i) => {
                    const baseTitle = `Measurements Sessions-${i + 1}`;
                    const encoded = encodeURIComponent(baseTitle);
                    const title = getUniqueImportedTitle(updated, encoded);
                    const idx = getNextAppendixIndex(updated);

                    let xml = `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
                    xml += generateChargeXML(item, { mode: 'standard', chargeIndex: 1 });
                    xml += '      </Measurement>\n';
                    updated += '\n' + xml;
                });
            } else {
                const baseTitle = 'Measurements Sessions';
                const encoded = encodeURIComponent(baseTitle);
                const title = getUniqueImportedTitle(updated, encoded);
                const idx = getNextAppendixIndex(updated);

                let xml = `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
                allStats.forEach((item, i) => {
                    xml += generateChargeXML(item, { mode: 'standard', chargeIndex: i + 1 });
                });
                xml += '      </Measurement>\n';
                updated += '\n' + xml;
            }

            return appendImportedPicturesAndNotes(updated);
        }


function generateMinimalGRT() {
            const mcG = getMcG();
            let innerParts = '';
            let idx = 1;

            if (allStats && allStats.length) {
                if (mode === 'ladder') {
                    const title = 'Imported%20Ladder';
                    innerParts += `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
                    allStats.forEach((item, i) => {
                        innerParts += generateChargeXML(item, {
                            mode: 'ladder',
                            chargeIndex: item.chargeIndex || (i + 1)
                        });
                    });
                    innerParts += '      </Measurement>\n';
                    idx++;
                } else if (mode === 'sessions') {
                    const layout = (typeof sessionsLayout === 'string') ? sessionsLayout : 'compact';
                    if (layout === 'legacy') {
                        allStats.forEach((item, i) => {
                            const title = `Measurements%20Sessions-${i + 1}`;
                            innerParts += `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
                            innerParts += generateChargeXML(item, {
                                mode: 'standard',
                                chargeIndex: 1
                            });
                            innerParts += '      </Measurement>\n';
                            idx++;
                        });
                    } else {
                        const title = 'Measurements%20Sessions';
                        innerParts += `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
                        allStats.forEach((item, i) => {
                            innerParts += generateChargeXML(item, {
                                mode: 'standard',
                                chargeIndex: i + 1
                            });
                        });
                        innerParts += '      </Measurement>\n';
                        idx++;
                    }

                } else {
                    const title = 'Imported%20Measurement';
                    innerParts += `      <Measurement index="${idx}" showinreport="true" title="${title}">\n`;
                    allStats.forEach((item, i) => {
                        innerParts += generateChargeXML(item, {
                            mode: 'standard',
                            chargeIndex: item.chargeIndex || (i + 1)
                        });
                    });
                    innerParts += '      </Measurement>\n';
                    idx++;
                }
            }

            if ((importedPictures && importedPictures.length) ||
                (importedNotesText && importedNotesText.trim()) ||
                (analysisNoteText && analysisNoteText.trim() && analysisNoteText !== 'No session data loaded yet.') ||
                chronoSimPngData) {
                innerParts = appendImportedPicturesAndNotes(innerParts || '');
            }

            let xml = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>\n';
            xml += '<GordonsReloadingTool version="2021.2030-NIGHTLY">\n';
            xml += '  <InnerBallistikInput>\n';
            xml += '    <title>Chronograph%20Import</title>\n';
            xml += '    <caliber>\n      <input name="CaliberName" value="Generic" />\n    </caliber>\n';
            xml += '    <gun><input name="GunName" value="Generic" /></gun>\n';
            xml += '    <projectile><input name="ProjectileName" value="Generic" /></projectile>\n';
            xml += `    <propellant><input name="pname" value="Generic" /><input name="mc" value="${mcG.toString()}" unit="g" type="decimal" descr="propellant mass" /></propellant>\n`;
            xml += '    <appendix>\n';
            xml += innerParts || '';
            xml += '    </appendix>\n';
            xml += '  </InnerBallistikInput>\n';
            xml += '</GordonsReloadingTool>';
            return xml;
        }

        function generateOutput() {
            analysisNoteText = buildSessionSummaryText();
            try { renderChronoSimChart(); } catch (e) {}
            if (grtBaseContent) {
                const base = grtBaseContent;
                const openIdx = base.indexOf('<appendix>');
                const closeIdx = base.indexOf('</appendix>');
                if (openIdx !== -1 && closeIdx !== -1) {
                    const before = base.substring(0, openIdx);
                    const after = base.substring(closeIdx + '</appendix>'.length);
                    const inner = base.substring(openIdx + '<appendix>'.length, closeIdx);

                    let newInner;
                    if (mode === 'ladder') {
                        newInner = generateImportedLadderXML(inner);
                    } else if (mode === 'sessions') {
                        newInner = generateImportedSessionsXML(inner);
                    } else {
                        newInner = generateImportedMeasurementXML(inner);
                    }

                    outputXML = before + '<appendix>' + newInner + '</appendix>' + after;
                    return;
                }
            }
            outputXML = generateMinimalGRT();
        }

        // =======================
        // Micro-sparklines for per-file velocities
        // =======================
        function renderSparklines() {
            const cards = document.querySelectorAll('[data-velocities]');
            cards.forEach((el) => {
                const raw = el.getAttribute('data-velocities') || '';
                if (!raw) {
                    el.innerHTML = '';
                    return;
                }
                const parts = raw.split(',').map(v => parseFloat(v)).filter(v => !isNaN(v));
                if (!parts.length) {
                    el.innerHTML = '';
                    return;
                }
                const min = Math.min(...parts);
                const max = Math.max(...parts);
                const span = max - min || 1;

                const width = 120;
                const height = 24;
                const step = parts.length > 1 ? (width / (parts.length - 1)) : 0;

                const points = parts.map((v, idx) => {
                    const x = step * idx;
                    const norm = (v - min) / span;
                    const y = height - norm * (height - 4) - 2;
                    return `${x.toFixed(1)},${y.toFixed(1)}`;
                }).join(' ');

                const count = parts.length;
                const sum = parts.reduce((a, b) => a + b, 0);
                const mean = count ? (sum / count) : 0;
                const variance = count ? parts.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / count : 0;
                const sd = Math.sqrt(variance);
                const es = span;

                const titleText = `${count} shots ‚Ä¢ AVG ${mean.toFixed(1)} ‚Ä¢ SD ${sd.toFixed(1)} ‚Ä¢ ES ${es.toFixed(1)}`;

                el.innerHTML = `
                    <svg viewBox="0 0 ${width} ${height}" class="w-full h-6">
                        <polyline fill="none" stroke="currentColor" stroke-width="1.2"
                                  points="${points}">
                            <title>${titleText}</title>
                        </polyline>
                    </svg>
                `;
                el.classList.add('text-[var(--grt-accent)]');
            });
        }

        // =======================
        // Results UI & download
        // =======================
        
        
        
        function pickSdBand(sd) {
            if (typeof sd !== 'number' || isNaN(sd) || sd < 0) return null;
            if (!CONFIG || !Array.isArray(CONFIG.sdBands)) return null;
            for (let i = 0; i < CONFIG.sdBands.length; i++) {
                const band = CONFIG.sdBands[i];
                if (sd < band.max) return band;
            }
            return CONFIG.sdBands[CONFIG.sdBands.length - 1] || null;
        }

        function renderSdBadge(sd) {
            let label = 'N/A';
            let chipClass = 'bg-slate-900/80 text-slate-200 border-slate-500/60';
            let dotClass = 'bg-slate-400';
            let tooltip = 'SD not available for this string.';

            if (typeof sd === 'number' && !isNaN(sd)) {
                const band = pickSdBand(sd);
                if (band) {
                    label = band.label;
                    chipClass = band.chipClass;
                    dotClass = band.dotClass;
                    const u = unitLabel();
                    if (band.key === 'tight') {
                        tooltip = `Tight: SD < 10 ${u} (very consistent).`;
                    } else if (band.key === 'ok') {
                        tooltip = `OK: SD between 10 and 20 ${u}.`;
                    } else {
                        tooltip = `Wide: SD ‚â• 20 ${u} (looser spread).`;
                    }
                }
            }

            return `
                <span class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-full border text-[9px] md:text-[10px] font-semibold ${chipClass}" title="${tooltip}">
                    <span class="h-1.5 w-1.5 rounded-full ${dotClass}"></span>
                    <span>${label}</span>
                </span>
            `;
        }

function findBestNodeIndex() {
            if (!allStats.length) return -1;
            let bestIndex = -1;
            let bestScore = Infinity;

            const targetSD = typeof analysisConfig?.targetSD === 'number' ? analysisConfig.targetSD : 0;
            const targetES = typeof analysisConfig?.targetES === 'number' ? analysisConfig.targetES : 0;
            const modeKey = analysisConfig?.bestNodeMode || 'sd';

            allStats.forEach((item, i) => {
                const s = item.stats || {};
                const n = s.count || 0;
                if (n < 3) return;

                const sd = typeof s.sd === 'number' ? s.sd : NaN;
                const es = typeof s.es === 'number' ? s.es : NaN;
                if (!Number.isFinite(sd) || !Number.isFinite(es)) return;

                let sdScore = targetSD > 0 ? sd / targetSD : sd;
                let esScore = targetES > 0 ? es / targetES : es;

                let score;
                if (modeKey === 'es') {
                    score = esScore;
                } else if (modeKey === 'weighted') {
                    score = 0.7 * sdScore + 0.3 * esScore;
                } else {
                    score = sdScore;
                }

                // Mild penalty if outside targets
                let outside = false;
                if (targetSD > 0 && sd > targetSD) outside = true;
                if (targetES > 0 && es > targetES) outside = true;
                if (outside) {
                    score += 5;
                }

                if (score < bestScore) {
                    bestScore = score;
                    bestIndex = i;
                }
            });

            return bestIndex;
        }




                function updateSessionPill() {
            const pill = document.getElementById('sessionPill');
            if (!pill) return;

            const icon = (mode === 'ladder') ? 'üéØ' : (mode === 'sessions' ? 'üìö' : '‚öôÔ∏è');
            const unitLabelText = unit === 'imperial' ? 'ft/s' : 'm/s';

            if (mode === 'ladder') {
                const mapped = ladderSlots.filter(Boolean).length;
                const total =
                    (typeof grtLadderSteps === 'number' && grtLadderSteps >= 2 && grtLadderSteps <= 10)
                        ? grtLadderSteps
                        : (ladderSteps || 10);
                pill.textContent = `${icon} Ladder ‚Ä¢ ${mapped}/${total} charges mapped ‚Ä¢ ${unitLabelText}`;
            } else if (mode === 'sessions') {
                const sessionCount = allStats.length || 0;
                const label = sessionCount === 1 ? 'session' : 'sessions';
                pill.textContent = `${icon} Measurements Sessions ‚Ä¢ ${sessionCount} ${label} ‚Ä¢ ${unitLabelText}`;
            } else {
                const fileCount = allStats.length || 0;
                const label = fileCount === 1 ? 'file' : 'files';
                pill.textContent = `${icon} Standard ‚Ä¢ ${fileCount} chrono ${label} ‚Ä¢ ${unitLabelText}`;
            }
        }

        
        function renderChronoSimChart() {
            const canvas = document.getElementById('chronoSimChart');
            const checkbox = document.getElementById('ladderIncludeChronoSim');
            if (!canvas) {
                chronoSimPngData = '';
                return;
            }

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                chronoSimPngData = '';
                return;
            }

            // Determine drawing size (use on‚Äëscreen size as a hint, but force a nicer aspect ratio)
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            let width = rect.width || canvas.clientWidth || 800;
            let height = rect.height || (width * 0.6);
            // Make sure the exported PNG isn't a super‚Äëthin banner
            if (height < width * 0.45) {
                height = Math.round(width * 0.6);
            }
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            // Background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, '#020617');
            bgGrad.addColorStop(1, '#020617');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Build chrono mean points per string
            const points = [];
            allStats.forEach((item, idx) => {
                const s = item.stats || {};
                if (!s || typeof s.mean !== 'number' || !isFinite(s.mean)) return;
                const label = (mode === 'ladder')
                    ? (ladderNameMode === 'charge'
                        ? (`C${item.chargeIndex || (idx + 1)}`)
                        : (item.filename || (`C${idx + 1}`)))
                    : (item.filename || (`C${idx + 1}`));
                points.push({
                    index: idx,
                    label,
                    mean: s.mean
                });
            });

            if (!points.length) {
                chronoSimPngData = '';
                return;
            }

            // Simple linear regression of mean vs index to approximate simulated ladder V0
            const n = points.length;

// Prefer true Sim series from GRT JSON export when available
let simSeries = null;
if (Array.isArray(grtSimSeriesForChart) && grtSimSeriesForChart.length >= points.length) {
  simSeries = grtSimSeriesForChart.slice(0, points.length);
}

            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            points.forEach((p, i) => {
                const x = i;
                const y = p.mean;
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumXX += x * x;
            });
            const denom = (n * sumXX - sumX * sumX) || 1;
            const a = (n * sumXY - sumX * sumY) / denom;
            const b = (sumY - a * sumX) / n;

            const allY = [];
            points.forEach((p, i) => {
                allY.push(p.mean);
                allY.push(simSeries ? simSeries[i] : (a * i + b));
            });
            let minY = Math.min.apply(null, allY);
            let maxY = Math.max.apply(null, allY);
            const padding = (maxY - minY) * 0.1 || 10;
            minY -= padding;
            maxY += padding;

            // "Nice" tick spacing for Y axis
            function computeNiceTicks(minVal, maxVal, targetTicks) {
                const range = maxVal - minVal || 1;
                const roughStep = range / (targetTicks || 5);
                const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
                const residual = roughStep / magnitude;
                let niceStep;
                if (residual <= 1) niceStep = 1 * magnitude;
                else if (residual <= 2) niceStep = 2 * magnitude;
                else if (residual <= 5) niceStep = 5 * magnitude;
                else niceStep = 10 * magnitude;
                const niceMin = Math.floor(minVal / niceStep) * niceStep;
                const niceMax = Math.ceil(maxVal / niceStep) * niceStep;
                const ticks = [];
                for (let v = niceMin; v <= niceMax + 0.5 * niceStep; v += niceStep) {
                    ticks.push(v);
                }
                return { ticks, niceMin, niceMax };
            }

            const tickInfo = computeNiceTicks(minY, maxY, 5);
            const yTicks = tickInfo.ticks;
            minY = tickInfo.niceMin;
            maxY = tickInfo.niceMax;

            // Layout: extra top margin for title + legend
            const margin = { left: 60, right: 20, top: 60, bottom: 40 };
            const plotW = width - margin.left - margin.right;
            const plotH = height - margin.top - margin.bottom;

            function yToPx(v) {
                const t = (v - minY) / (maxY - minY || 1);
                return margin.top + plotH - t * plotH;
            }
            function xToPx(i) {
                if (points.length === 1) return margin.left + plotW / 2;
                const t = i / (points.length - 1);
                return margin.left + t * plotW;
            }

            // Grid lines and axes
            ctx.lineWidth = 1;

            // Horizontal grid for Y ticks
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.25)';
            yTicks.forEach((v) => {
                const y = yToPx(v);
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + plotW, y);
                ctx.stroke();
            });

            // Axes
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.6)';
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.stroke();

            // Y-axis labels
            ctx.fillStyle = '#e5e7eb';
            ctx.font = '10px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            yTicks.forEach((v) => {
                const y = yToPx(v);
                const text = v.toFixed(0);
                ctx.fillText(text, margin.left - 6, y);
            });

            // Y-axis title
            const unit = (typeof garminVelocityUnit === 'string') ? garminVelocityUnit : '';
            const unitLabel = (unit === 'mps' || unit === 'm/s') ? 'V‚ÇÄ (m/s)' : 'V‚ÇÄ (ft/s)';
            ctx.save();
            ctx.translate(18, margin.top + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(unitLabel, 0, 0);
            ctx.restore();

            // X-axis labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.font = '10px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            points.forEach((p, i) => {
                const x = xToPx(i);
                const y = margin.top + plotH + 6;
                ctx.fillText(p.label, x, y);
            });

            // Chrono line (solid)
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.strokeStyle = '#38bdf8';
            ctx.beginPath();
            points.forEach((p, i) => {
                const x = xToPx(i);
                const y = yToPx(p.mean);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Chrono markers
            ctx.fillStyle = '#38bdf8';
            points.forEach((p, i) => {
                const x = xToPx(i);
                const y = yToPx(p.mean);
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Sim line (dashed)
            ctx.strokeStyle = '#fb7185';
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            points.forEach((p, i) => {
                const x = xToPx(i);
                const y = yToPx(simSeries ? simSeries[i] : (a * i + b));
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.setLineDash([]);

            // Title
            ctx.fillStyle = '#e5e7eb';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.font = 'bold 14px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.fillText('Chrono vs Sim V‚ÇÄ', margin.left, 18);

            // Legend
            const legendY = 18;
            let legendX = margin.left + 180;

            // Chrono legend
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#38bdf8';
            ctx.beginPath();
            ctx.moveTo(legendX, legendY + 8);
            ctx.lineTo(legendX + 24, legendY + 8);
            ctx.stroke();
            ctx.fillText('Chrono avg', legendX + 32, legendY + 2);

            // Sim legend
            legendX += 130;
            ctx.strokeStyle = '#fb7185';
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY + 8);
            ctx.lineTo(legendX + 24, legendY + 8);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillText(simSeries ? 'Sim V‚ÇÄ (GRT)' : 'Sim V‚ÇÄ', legendX + 32, legendY + 2);

            // Subtitle on the right
            ctx.textAlign = 'right';
            ctx.font = '10px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.fillText('Solid = chrono average; dashed = simulated ladder V‚ÇÄ.', width - 10, legendY + 2);

            // Only store PNG when user wants to export (ladder + sessions)
            const shouldExport = ((mode === 'ladder' || mode === 'sessions') && checkbox && checkbox.checked);
            if (shouldExport) {
                const dataUrl = canvas.toDataURL('image/png');
                chronoSimPngData = dataUrl.replace(/^data:image\/png;base64,/, '');
                chronoSimImageWidth = Math.round(width);
                chronoSimImageHeight = Math.round(height);
            } else {
                chronoSimPngData = '';
            }
        }



function showResults() {
            document.getElementById('uploadArea').classList.add('hidden');
            document.getElementById('resultsArea').classList.remove('hidden');
            document.getElementById('fileCount').textContent = allStats.length;

            const uLabel = unitLabel();
            const resUnit = document.getElementById('resultsUnit');
            if (resUnit) resUnit.textContent = uLabel + ' (file)';

            const grid = document.getElementById('statsGrid');

            // Show/hide analysis dashboard and determine best node for highlighting
            const dash = document.getElementById('analysisDashboard');
            if (dash) {
                if (allStats.length) {
                    dash.classList.remove('hidden');
                } else {
                    dash.classList.add('hidden');
                }
            }

            bestNodeIndex = allStats.length ? findBestNodeIndex() : -1;
            if (mode === 'ladder') {
                // Preserve ladder-specific best node index for ladder export
                lastBestNodeIndex = bestNodeIndex;
            } else {
                lastBestNodeIndex = -1;
            }

            grid.innerHTML = allStats.map((item, i) => {
                const s = item.stats;
                const isBestNode = (bestNodeIndex === i);
                let title;
                if (mode === 'ladder') {
                    if (ladderNameMode === 'charge') {
                        title = `Charge ${item.chargeIndex || (i + 1)}`;
                    } else {
                        title = item.filename || `Charge ${item.chargeIndex || (i + 1)}`;
                    }
                } else {
                    title = item.filename || `Charge ${i + 1}`;
                }
                const velAttr = (s.velocities || []).join(',');
                const tSD = (analysisConfig && typeof analysisConfig.targetSD === 'number') ? analysisConfig.targetSD : 0;
                const tES = (analysisConfig && typeof analysisConfig.targetES === 'number') ? analysisConfig.targetES : 0;

                // Multiplier for "near target" band (blue). Tweak here if you want looser/tighter.
                const NEAR_RATIO = 1.2;

                                const _vSD = xqaGetVelocitySD(s);
                const vSD = _vSD.v;
                const vSDsrc = _vSD.src;

                const hasSDTarget = tSD > 0 && typeof vSD === "number" && !isNaN(vSD);
                const hasESTarget = tES > 0 && typeof s.es === 'number' && !isNaN(s.es);
                const sdRatio = hasSDTarget ? (vSD / tSD) : null;
                const esRatio = hasESTarget ? (s.es / tES) : null;

                
                const _xqaScoreHints = (function(){
                  const bits=[];
                  if(_vSD && _vSD.src) bits.push(`SD src: ${_vSD.src}`);
                  if(typeof vSD==='number' && hasSDTarget) bits.push(`SD ${vSD.toFixed(1)} / target ${tSD}`);
                  if(typeof s.es==='number' && hasESTarget) bits.push(`ES ${s.es.toFixed(1)} / target ${tES}`);
                  if(bits.length===0) bits.push('No velocity SD/ES available for scoring.');
                  return bits.join(' ‚Ä¢ ');
                })();                const _xqaScoreHintTitle = String(_xqaScoreHints||'').replace(/\"/g,'&quot;');

                const withinSD = hasSDTarget && sdRatio <= 1;
                const withinES = hasESTarget && esRatio <= 1;

                // Target-aware SD color (green / blue / rose), with sdBands fallback when no SD target is set
                let sdColorClass = 'text-grt-soft';
                if (typeof vSD === "number" && !isNaN(vSD)) {
                    if (hasSDTarget) {
                        if (sdRatio <= 1) {
                            sdColorClass = 'text-emerald-300'; // within target
                        } else if (sdRatio <= NEAR_RATIO) {
                            sdColorClass = 'text-sky-300';     // near target
                        } else {
                            sdColorClass = 'text-rose-300';    // outside / wide
                        }
                    } else {
                        const band = pickSdBand(vSD);
                        if (band) {
                            if (band.key === 'tight') {
                                sdColorClass = 'text-emerald-300';
                            } else if (band.key === 'ok') {
                                sdColorClass = 'text-amber-300';
                            } else {
                                sdColorClass = 'text-rose-300';
                            }
                        }
                    }
                }

                // Target-aware ES color (green / blue / rose), fallback to SD band color if no ES target
                let esColorClass = 'text-grt-soft';
                if (typeof s.es === 'number' && !isNaN(s.es)) {
                    if (hasESTarget) {
                        if (esRatio <= 1) {
                            esColorClass = 'text-emerald-300';
                        } else if (esRatio <= NEAR_RATIO) {
                            esColorClass = 'text-sky-300';
                        } else {
                            esColorClass = 'text-rose-300';
                        }
                    } else {
                        esColorClass = sdColorClass;
                    }
                } else {
                    esColorClass = sdColorClass;
                }

                const healthBadge = renderSdBadge(vSD);

                // Threshold-based status badge leveraging ratios (blue = "near node / partial hit")
                let statusLabel = '';
                let statusClass = '';

                if (hasSDTarget && hasESTarget) {
                    const bothWithin = withinSD && withinES;
                    const bothNear = !bothWithin && sdRatio !== null && esRatio !== null && sdRatio <= NEAR_RATIO && esRatio <= NEAR_RATIO;

                    if (bothWithin) {
                        statusLabel = 'Node candidate';
                        statusClass = 'bg-emerald-900/70 text-emerald-200 border-emerald-500/60';
                    } else if (bothNear) {
                        statusLabel = 'Near node';
                        statusClass = 'bg-sky-900/70 text-sky-200 border-sky-500/60';
                    } else if (withinSD && !withinES) {
                        statusLabel = 'SD OK / ES high';
                        statusClass = 'bg-sky-900/70 text-sky-200 border-sky-500/60';
                    } else if (!withinSD && withinES) {
                        statusLabel = 'ES OK / SD high';
                        statusClass = 'bg-sky-900/70 text-sky-200 border-sky-500/60';
                    } else {
                        statusLabel = 'Above targets';
                        statusClass = 'bg-rose-900/70 text-rose-200 border-rose-500/60';
                    }
                }
                
                const ext = s.extended || {};
                let extendedLines = '';
                if (analysisConfig && analysisConfig.show95Band && isValidNumber(ext.low95) && isValidNumber(ext.high95)) {
                    extendedLines += `<div class="flex justify-between">
                                <span class="text-grt-subtle">95% band:</span>
                                <span class="text-grt-soft font-semibold">${ext.low95.toFixed(1)} / ${ext.high95.toFixed(1)} ${uLabel}</span>
                            </div>`;
                }
                if (analysisConfig && analysisConfig.showMAD && typeof ext.mad === 'number') {
                    extendedLines += `<div class="flex justify-between">
                                <span class="text-grt-subtle">MAD:</span>
                                <span class="text-grt-soft font-semibold">${ext.mad.toFixed(1)} ${uLabel}</span>
                            </div>`;
                }
                if (analysisConfig && analysisConfig.showCV && typeof ext.cvPercent === 'number') {
                    extendedLines += `<div class="flex justify-between">
                                <span class="text-grt-subtle">CV%:</span>
                                <span class="text-grt-soft font-semibold">${ext.cvPercent.toFixed(2)} %</span>
                            </div>`;
                }
                if (analysisConfig && analysisConfig.showESD && typeof ext.esdFromEs === 'number') {
                    extendedLines += `<div class="flex justify-between">
                                <span class="text-grt-subtle">ESD (ES/4):</span>
                                <span class="text-grt-soft font-semibold">${ext.esdFromEs.toFixed(1)} ${uLabel}</span>
                            </div>`;
                }

                return `
                    <div class="bg-grt-panel-soft bg-[radial-gradient(circle_at_top,_rgba(148,163,184,0.06),_transparent_60%)] rounded-2xl border border-grt-frame/80 p-3 md:p-4 transition shadow-sm hover:shadow-md relative ${isBestNode ? 'ring-2 ring-emerald-400/80 shadow-[0_0_0_1px_rgba(16,185,129,0.4)]' : ''}">
                        <div class="flex items-center justify-between gap-2 mb-2">
                            <div class="flex items-center gap-2 min-w-0">
                                <h3 class="text-white font-bold text-xs md:text-sm truncate">${title}</h3>
                                ${statusLabel ? ('<span class="hidden md:inline-flex items-center px-2 py-0.5 rounded-full border text-[10px] ' + statusClass + '">' + statusLabel + '</span>') : ''}
                            </div>
                            ${healthBadge}
                        </div>
                        <div class="space-y-1 text-[11px] md:text-xs">
                            <div class="flex justify-between">
                                <span class="text-grt-subtle">Shots:</span>
                                <span class="text-white font-semibold">${s.count}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-grt-subtle">Average:</span>
                                <span class="text-grt-soft font-semibold">${s.mean.toFixed(1)} ${uLabel}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-grt-subtle" title="SD: standard deviation of velocity; lower means more consistent.">SD:</span>
                                <span class="flex items-center gap-1">
                                    <span class="${sdColorClass} font-semibold">${(vSDsrc==="insufficient") ? "‚ö† <3" : ((typeof vSD==="number" && !isNaN(vSD)) ? xqaFmtNum(vSD,1) : "‚Äî")} ${uLabel}</span>
                                    ${renderSdBadge(vSD)}
                                </span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-grt-subtle" title="ES: extreme spread (max - min); smaller usually indicates tighter performance.">ES:</span>
                                <span class="${esColorClass} font-semibold">${s.es.toFixed(1)} ${uLabel}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-grt-subtle">Min / Max:</span>
                                <span class="text-grt-soft font-semibold">${s.min.toFixed(1)} / ${s.max.toFixed(1)} ${uLabel}</span>
                            </div>
                            ${extendedLines}
                            <div class="mt-1 text-[10px] text-grt-subtle">
                                File unit: ${uLabel} ‚Ä¢ Imported to GRT as m/s
                            </div>
                        </div>
                        <div class="mt-2 h-6" data-velocities="${velAttr}"></div>
                    </div>
                `;
            }).join('');


            // Update run summary
            const aggregates = computeAggregates(allStats);
            const totalShots = aggregates ? aggregates.totalShots : 0;
            const sFiles = document.getElementById('summaryFiles');
            const sShots = document.getElementById('summaryShots');
            const sDevice = document.getElementById('summaryDevice');
            const sMode = document.getElementById('summaryMode');
            const sUnit = document.getElementById('summaryUnit');
            const sBase = document.getElementById('summaryBase');

            if (sFiles) sFiles.textContent = String(allStats.length);
            if (sShots) sShots.textContent = String(totalShots);
            if (sDevice) sDevice.textContent = chronographType === 'garmin' ? 'Garmin Xero C1 Pro' : 'Athlon Rangecraft';
            if (sMode) sMode.textContent = mode === 'ladder' ? 'Ladder' : (mode === 'sessions' ? 'Measurements Sessions' : 'Standard');
            if (sUnit) sUnit.textContent = unit === 'imperial' ? 'ft/s' : 'm/s';
            if (sBase) sBase.textContent = grtBaseContent ? 'Loaded' : 'Not loaded';

            // Update best node summary line (ladder only)
            const bestNodeEl = document.getElementById('summaryBestNode');
            if (bestNodeEl) {
                if (mode === 'ladder' && typeof bestNodeIndex === 'number' && bestNodeIndex >= 0 && allStats[bestNodeIndex]) {
                    const item = allStats[bestNodeIndex];
                    const s = item.stats || {};
                    const labelBase = (mode === 'ladder' && ladderNameMode === 'charge')
                        ? (`Charge ${item.chargeIndex || (bestNodeIndex + 1)}`)
                        : (item.filename || (`File ${bestNodeIndex + 1}`));
                    const avgText = (typeof s.mean === 'number' && !isNaN(s.mean)) ? (s.mean.toFixed(1) + ' ' + uLabel) : 'n/a';
                    const sdText = (typeof s.sd === 'number' && !isNaN(s.sd)) ? (s.sd.toFixed(2) + ' ' + uLabel) : 'n/a';
                    const esText = (typeof s.es === 'number' && !isNaN(s.es)) ? (s.es.toFixed(1) + ' ' + uLabel) : 'n/a';
                    bestNodeEl.innerHTML =
                        `‚≠ê Best node: <span class="font-semibold text-white">${labelBase}</span>` +
                        ` <span class="text-grt-subtle">‚Ä¢</span> SD <span class="font-semibold">${sdText}</span>` +
                        ` <span class="text-grt-subtle">‚Ä¢</span> ES <span class="font-semibold">${esText}</span>` +
                        ` <span class="text-grt-subtle">‚Ä¢</span> AVG <span class="font-semibold">${avgText}</span>`;
                } else {
                    bestNodeEl.innerHTML =
                        '‚≠ê Best node: <span class="text-grt-subtle">Not determined (use Ladder mode with ‚â• 2 mapped charges and ‚â• 5 shots per file).</span>';
                }
            }

            updateSessionPill();

            // Render micro-sparklines
            renderSparklines();

            // Update advanced diagnostics pane
// Session complete cue
            const sessionPillEl = document.getElementById('sessionPill');
            const topStepperEl = document.getElementById('topStepper');
            [sessionPillEl, topStepperEl].forEach((el) => {
                if (!el) return;
                el.classList.remove('session-pulse');
                void el.offsetWidth;
                el.classList.add('session-pulse');
                setTimeout(() => {
                    el.classList.remove('session-pulse');
                }, 450);
            });
        }


        
        function buildSessionSummaryText() {
            if (!allStats.length) {
                return 'No session data loaded yet.';
            }
            const uLabel = unitLabel();
            const deviceLabel = chronographType === 'garmin' ? 'Garmin Xero C1 Pro' : 'Athlon Rangecraft';
            const modeLabel = mode === 'ladder' ? 'Ladder' : (mode === 'sessions' ? 'Measurements Sessions' : 'Standard');
            const baseLabel = grtBaseContent ? 'Base .grtload: loaded' : 'Base .grtload: not loaded';

            const totalShots = allStats.reduce((sum, item) => sum + (item.stats.count || 0), 0);

            const lines = [];
            lines.push('Chrono ‚Üí GRT session');
            lines.push(`Mode: ${modeLabel}`);
            lines.push(`Device: ${deviceLabel}`);
            lines.push(`File unit: ${uLabel}`);
            lines.push(baseLabel);
            lines.push(`Files: ${allStats.length}, total shots: ${totalShots}`);

            const bestIndex = findBestNodeIndex();
            if (mode === 'ladder' && bestIndex >= 0 && allStats[bestIndex]) {
                const item = allStats[bestIndex];
                const s = item.stats || {};
                const labelBase = (ladderNameMode === 'charge')
                    ? (`Charge ${item.chargeIndex || (bestIndex + 1)}`)
                    : (item.filename || (`File ${bestIndex + 1}`));
                const sdText = (typeof s.sd === 'number' && !isNaN(s.sd)) ? (s.sd.toFixed(2) + ' ' + uLabel) : 'n/a';
                const esText = (typeof s.es === 'number' && !isNaN(s.es)) ? (s.es.toFixed(1) + ' ' + uLabel) : 'n/a';
                const avgText = (typeof s.mean === 'number' && !isNaN(s.mean)) ? (s.mean.toFixed(1) + ' ' + uLabel) : 'n/a';
                lines.push('');
                lines.push(`Best node (auto): ${labelBase} ‚Ä¢ SD ${sdText} ‚Ä¢ ES ${esText} ‚Ä¢ AVG ${avgText}`);
            }

            lines.push('');
            lines.push('Per-string stats:');
            allStats.forEach((item, idx) => {
                const s = item.stats || {};
                const label = (mode === 'ladder')
                    ? (ladderNameMode === 'charge'
                        ? (`Charge ${item.chargeIndex || (idx + 1)}`)
                        : (item.filename || (`File ${idx + 1}`)))
                    : (item.filename || (`File ${idx + 1}`));
                const avgText = (typeof s.mean === 'number' && !isNaN(s.mean)) ? (s.mean.toFixed(1) + ' ' + uLabel) : 'n/a';
                const sdText = (typeof s.sd === 'number' && !isNaN(s.sd)) ? (s.sd.toFixed(2) + ' ' + uLabel) : 'n/a';
                const esText = (typeof s.es === 'number' && !isNaN(s.es)) ? (s.es.toFixed(1) + ' ' + uLabel) : 'n/a';
                lines.push(
                    `‚Ä¢ ${label}: ${s.count || 0} shots ‚Ä¢ AVG ${avgText} ‚Ä¢ SD ${sdText} ‚Ä¢ ES ${esText}`
                );
            });

            // Extended metrics in the Analysis tab are optional; tie to the same toggle used for writing metrics into charge notes.
            const includeExtInAnalysis = !!(document.getElementById('analysisIncludeInNotes') && document.getElementById('analysisIncludeInNotes').checked);

            if (includeExtInAnalysis) {
            lines.push('');
            lines.push('Extended metrics:');
            allStats.forEach((item, idx) => {
                const s = item.stats || {};
                const ext = s.extended || {};
                if (!ext) return;
                const label = (mode === 'ladder')
                    ? (ladderNameMode === 'charge'
                        ? (`Charge ${item.chargeIndex || (idx + 1)}`)
                        : (item.filename || (`File ${idx + 1}`)))
                    : (item.filename || (`File ${idx + 1}`));
                const cvText = (typeof ext.cvPercent === 'number' && isFinite(ext.cvPercent))
                    ? (ext.cvPercent.toFixed(2) + ' %')
                    : 'n/a';
                const madText = (typeof ext.mad === 'number' && isFinite(ext.mad))
                    ? (ext.mad.toFixed(1) + ' ' + uLabel)
                    : 'n/a';
                const esdText = (typeof ext.esdFromEs === 'number' && isFinite(ext.esdFromEs))
                    ? (ext.esdFromEs.toFixed(2) + ' ' + uLabel)
                    : 'n/a';
                const bandText = (typeof ext.low95 === 'number' && typeof ext.high95 === 'number' &&
                    isFinite(ext.low95) && isFinite(ext.high95))
                    ? (ext.low95.toFixed(1) + '‚Äì' + ext.high95.toFixed(1) + ' ' + uLabel)
                    : 'n/a';
                lines.push(
                    `‚Ä¢ ${label}: CV% ${cvText} ‚Ä¢ MAD ${madText} ‚Ä¢ ESD ${esdText} ‚Ä¢ 95% band ${bandText}`
                );
            });

            }
            return lines.join('\n');
        }

        function fallbackCopyToClipboard(text) {
            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showStatus('success', 'Session summary copied to clipboard.');
            } catch (err) {
                showStatus('error', 'Unable to copy summary: ' + err.message);
            }
        }

        
function copySessionSummary() {
  try{
    if (!allStats || !allStats.length) {
      showStatus('error', 'No session stats yet. Load chronograph files first.');
      return;
    }
    const text = (typeof buildSessionSummaryText === 'function')
      ? buildSessionSummaryText()
      : JSON.stringify(allStats, null, 2);

    // Clipboard (modern) + fallback
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(()=>{
        showStatus('success', 'Session summary copied to clipboard.');
      }).catch((_e)=>{
        try{ fallbackCopyToClipboard(text); }catch(e){ showStatus('error','Unable to copy summary.'); }
      });
    } else {
      try{ fallbackCopyToClipboard(text); }catch(e){ showStatus('error','Unable to copy summary.'); }
    }
  }catch(e){
    console.error(e);
    try{ showStatus('error','Copy summary failed: ' + (e?.message || e)); }catch(_e){}
  }
}

// =======================
// Standalone session save/load (neutral JSON)
// =======================
function _xqaBuildStandalonePayload(){
  return {
    tool: 'GRT Importer Advanced',
    schemaVersion: 1,
    version: (document.title || '').replace(/\s+/g,' ').trim(),
    savedAtIso: new Date().toISOString(),
    state: {
      chronographType,
      unit,
      mode,
      sessionsLayout,
      ladderNameMode,
      ladderSteps,
      analysisConfig,
      smPhase3Config,
      shotMarkerManualMap,
      shotMarkerScoreSettings,
      shotMarkerAddons,
      allStats,
      importedPictures,
      importedNotesText
    }
  };
}

function exportStandaloneJson(){
  try{
    const nCharges = Array.isArray(allStats) ? allStats.length : 0;
    const nSM = Array.isArray(shotMarkerAddons) ? shotMarkerAddons.length : 0;

    // Never silently do nothing
    try{ showStatus('info', `Preparing session save‚Ä¶ (${nCharges} charge(s), ${nSM} ShotMarker file(s))`); }catch(_e){}

    if (!nCharges){
      try{ showStatus('error','Nothing to save yet ‚Äî import chronograph files first.'); }catch(_e){}
      return;
    }

    const payload = _xqaBuildStandalonePayload();
    const jsonText = JSON.stringify(payload, null, 2);
    const blob = new Blob([jsonText], {type:'application/json;charset=utf-8'});

    const ts = new Date();
    const y = ts.getFullYear();
    const mo = String(ts.getMonth()+1).padStart(2,'0');
    const d = String(ts.getDate()).padStart(2,'0');
    const hh = String(ts.getHours()).padStart(2,'0');
    const mm = String(ts.getMinutes()).padStart(2,'0');
    const ss = String(ts.getSeconds()).padStart(2,'0');
    const fname = `xqa_session_${y}${mo}${d}_${hh}${mm}${ss}.json`;

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fname;
    a.style.display = 'none';
    document.body.appendChild(a);

    // Attempt download
    a.click();

    // Download-only: no new tab preview

    setTimeout(()=>{
      try{ a.remove(); }catch(_e){}
      try{ URL.revokeObjectURL(url); }catch(_e){}
    }, 4000);

    try{ showStatus('success', `Saved session JSON: ${fname}`); }catch(_e){}
  }catch(e){
    console.error(e);
    try{ showStatus('error','Save session failed: ' + (e?.message || e)); }catch(_e){}
  }
}

// Ensure global access for inline handlers / cross-scope callbacks
try{ window.exportStandaloneJson = exportStandaloneJson; }catch(_e){}


function importStandaloneJsonFile(file){
  try{
    if(!file) return;
    const r = new FileReader();
    r.onload = ()=>{
      try{
        const obj = JSON.parse(String(r.result||'{}'));
        const schemaV = (obj && typeof obj.schemaVersion === 'number') ? obj.schemaVersion : 0;
        const st = obj && obj.state ? obj.state : null;
        if(!st || !Array.isArray(st.allStats)){
          showStatus('error','That JSON does not look like a saved session from this tool.');
          return;
        }
        if (schemaV > 1) {
          try{ showToast('Note: session schema v'+schemaV+' is newer; attempting best-effort load.','warn'); }catch(_e){}
        }

        // Restore state (best-effort)
        chronographType = st.chronographType || chronographType;
        unit = st.unit || unit;
        mode = st.mode || mode;
        sessionsLayout = st.sessionsLayout || sessionsLayout;
        ladderNameMode = st.ladderNameMode || ladderNameMode;
        ladderSteps = (typeof st.ladderSteps === 'number') ? st.ladderSteps : ladderSteps;

        analysisConfig = st.analysisConfig || analysisConfig;
        smPhase3Config = st.smPhase3Config || smPhase3Config;
        shotMarkerManualMap = st.shotMarkerManualMap || shotMarkerManualMap;
        shotMarkerScoreSettings = (st.shotMarkerScoreSettings !== undefined) ? st.shotMarkerScoreSettings : shotMarkerScoreSettings;

        shotMarkerAddons = st.shotMarkerAddons || shotMarkerAddons;
        allStats = st.allStats || allStats;

        importedPictures = st.importedPictures || importedPictures;
        importedNotesText = (st.importedNotesText !== undefined) ? st.importedNotesText : importedNotesText;

        // Sync UI controls
        try{ document.getElementById('deviceSelect').value = chronographType; }catch(_e){}
        try{ document.getElementById('unitSelect').value = unit; }catch(_e){}
        try{ document.getElementById('modeSelect').value = mode; }catch(_e){}
        try{
          const r1=document.querySelector('input[name="sessionsLayout"][value="sessions"]');
          const r2=document.querySelector('input[name="sessionsLayout"][value="files"]');
          if (sessionsLayout==='sessions' && r1) r1.checked=true;
          if (sessionsLayout==='files' && r2) r2.checked=true;
        }catch(_e){}
        try{ updateModeUI(); }catch(_e){}

        try{
          const c = document.getElementById('analysisTargetSD'); if(c) c.value = analysisConfig.targetSD;
          const e = document.getElementById('analysisTargetES'); if(e) e.value = analysisConfig.targetES;
        }catch(_e){}
        try{ updateSessionPill(); }catch(_e){}
        try{ setCurrentStep(4); }catch(_e){}

        // Re-render
        showResults();
        try{ renderShotMarkerInlineCards(); }catch(_e){}
        try{ renderShotMarkerSessionCards(); }catch(_e){}
        try{ updateRunSummary(); }catch(_e){}

        showStatus('success','Loaded saved session JSON.');
      }catch(e){
        console.error(e);
        showStatus('error','Load session failed: ' + (e?.message || e));
      }
    };
    r.readAsText(file);
  }catch(e){
    console.error(e);
    showStatus('error','Load session failed: ' + (e?.message || e));
  }
}

try{ window.importStandaloneJsonFile = importStandaloneJsonFile; }catch(_e){}

function downloadGRT() {
            setCurrentStep(4);
            const blob = new Blob([outputXML], { type: 'application/xml;charset=utf-8' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const now = new Date();
            const pad2 = (n)=>String(n).padStart(2,'0');
            const stamp = `${now.getFullYear()}${pad2(now.getMonth()+1)}${pad2(now.getDate())}_${pad2(now.getHours())}${pad2(now.getMinutes())}`; // YYYYMMDD_HHMM
            let baseStem = (grtBaseFilename || 'GRT_Import')
                .replace(/\.grtload$/i, '')
                .replace(/[^a-z0-9 _\-]+/gi, '')
                .trim()
                .replace(/\s+/g, '_');
            if (!baseStem) baseStem = 'GRT_Import';
            link.href = url;
            link.download = `${baseStem}_${stamp}.grtload`;
            link.click();
            URL.revokeObjectURL(url);
        }
    
        ;;


        (function initExtendedMetricsHelp() {
            const btn  = document.getElementById('extendedMetricsHelpBtn');
            const card = document.getElementById('extendedMetricsHelpCard');
            if (!btn || !card) return;

            let open = false;

            function setOpen(next) {
                open = next;
                if (open) {
                    card.classList.remove('hidden');
                } else {
                    card.classList.add('hidden');
                }
            }

            btn.addEventListener('click', (evt) => {
                evt.stopPropagation();
                setOpen(!open);
            });

            document.addEventListener('click', (evt) => {
                if (!open) return;
                if (card.contains(evt.target) || btn.contains(evt.target)) return;
                setOpen(false);
            });
        })();

// ========================
// How-to overlay helpers
// ========================
document.addEventListener('DOMContentLoaded', function setupHelpOverlay() {
    const btn = document.getElementById('helpOverlayButton');
    const overlay = document.getElementById('helpOverlay');
    const closeBtn = document.getElementById('helpOverlayClose');
    const dontShow = document.getElementById('helpOverlayDontShow');

    function openOverlay() {
        if (!overlay) return;
        overlay.classList.remove('hidden');
    }

    function closeOverlay() {
        if (!overlay) return;
        overlay.classList.add('hidden');
    }

    // Manual open/close
    if (btn) {
        btn.addEventListener('click', () => {
            openOverlay();
        });
    }

    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            closeOverlay();
        });
    }

    // Close on backdrop click
    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeOverlay();
            }
        });
    }

    // ESC key to close
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && overlay && !overlay.classList.contains('hidden')) {
            closeOverlay();
        }
    });

    // First-time auto-show
    try {
        const seen = localStorage.getItem('xqa_seen_help_overlay');
        if (!seen) {
            openOverlay();
        }
    } catch (err) {
        // ignore localStorage errors
    }

    // Remember "don't show again"
    if (dontShow) {
        dontShow.addEventListener('change', (e) => {
            try {
                if (e.target.checked) {
                    localStorage.setItem('xqa_seen_help_overlay', '1');
                } else {
                    localStorage.removeItem('xqa_seen_help_overlay');
                }
            } catch (err) {
                // ignore
            }
        });
    }

    // GRT Simulation Export (JSON) wiring (event delegation so it works if the Ladder ‚Üí Advanced panel is rendered later)
    function handleGRTSimJsonFileInput(file) {
        if (!file) {
            grtSimLadderRows = null;
            grtSimSeriesForChart = null;
            grtSimPressurePsi = null;
            grtSimBarrelTimeMs = null;
            grtSimOptimalBTMs = null;
            updateSimStatus('No file loaded. Requires GRT export with ‚ÄúLoading ladder complete (all charges)‚Äù.', false);
            return;
        }
        (async () => {
            try {
                const txt = await file.text();
                const obj = JSON.parse(txt);
                const norm = normalizeSimJson(obj);
                if (!norm || !norm.length) {
                    grtSimLadderRows = null;
                    grtSimSeriesForChart = null;
                    updateSimStatus('Sim JSON loaded but no ladder[] data found. Export with ‚ÄúLoading ladder complete (all charges)‚Äù.', false);
                    return;
                }
                grtSimLadderRows = norm;
                grtSimSeriesForChart = norm.map(r => fpsToChart(r.mvFps));
                grtSimPressurePsi = norm.map(r => r.peakPsi);
                grtSimBarrelTimeMs = norm.map(r => r.btMs);
                grtSimOptimalBTMs = norm.map(r => r.obtMs);
                const minC = (norm[0].chargeGr ?? 0).toFixed(2);
                const maxC = (norm[norm.length - 1].chargeGr ?? 0).toFixed(2);
                updateSimStatus(`Loaded ladder: ${norm.length} steps (${minC}‚Äì${maxC} gr).`, true);
            } catch (err) {
                grtSimLadderRows = null;
                grtSimSeriesForChart = null;
                updateSimStatus('Failed to parse JSON. Make sure you exported JSON (raw data) from GRT.', false);
                console.error(err);
            }
        })();
    }

    document.addEventListener('change', (e) => {
        const t = e.target;
        if (!t || t.id !== 'grtSimJsonInput') return;
        const f = t.files && t.files[0];
        handleGRTSimJsonFileInput(f);
    });


});
;


// =======================

    // =======================
    // Output refresh helper (for toggles changed after processing)
    // =======================
    function refreshOutputIfReady() {
      try {
        const resultsArea = document.getElementById('resultsArea');
        const resultsVisible = resultsArea && !resultsArea.classList.contains('hidden');
        if (!resultsVisible) return;
        if (!grtBaseContent) return;
        generateOutput(); // rebuild outputXML with latest toggle states
      } catch (e) { /* no-op */ }
    }

// Export toggles
// =======================
(function initExportToggles() {
  try {
    const analysisTabCb = document.getElementById('exportAnalysisTab');
    if (analysisTabCb) {
      const saved = localStorage.getItem('xqa_exportAnalysisTab');
      analysisTabCb.checked = (saved === null) ? false : (saved === 'true');
      analysisTabCb.addEventListener('change', () => {
        try { localStorage.setItem('xqa_exportAnalysisTab', String(!!analysisTabCb.checked)); } catch (e) {}
        refreshOutputIfReady();
      });
    }

    // Also refresh output if the "write metrics into notes" toggle changes after processing.
    const includeNotesCb = document.getElementById('analysisIncludeInNotes');
    if (includeNotesCb) {
      includeNotesCb.addEventListener('change', () => {
        refreshOutputIfReady();
      });
    }
  } catch (e) {}
})();
// ==============================
// Phase 2.1 (UI) + Phase 2.0 rank
// ==============================

// --- math helpers ---
function _smConfFromN(n){ n = Number(n||0); if (!isFinite(n)||n<=0) return 0; const k=7.5; return 1-Math.exp(-n/k); }



// score scaling: raw composite -> 0‚Äì100 rating (higher is better)
function _smClamp(v, lo, hi){ v=Number(v); if(!isFinite(v)) return lo; return Math.max(lo, Math.min(hi, v)); }
function _smGetScoreK(){
  try{
    const k = Number(localStorage.getItem('grt_sm_score_k'));
    return (isFinite(k) && k>0) ? k : 0.447;
  }catch(_e){ return 0.447; }
}
function _smSetScoreK(k){
  k = Number(k);
  if(!isFinite(k) || k<=0) return false;
  try{ localStorage.setItem('grt_sm_score_k', String(k)); }catch(_e){}
  return true;
}
// Suggest k from currently loaded data so that P75 raw score maps to ~80.
// Uses your real imported sessions (scoring shots only).
function _smSuggestScoreKFromData(targetRating){
  targetRating = Number.isFinite(targetRating) ? targetRating : 80;
  try{
    const rows = (window.__xqaSmPhase2Rows||[]);
    const raws = rows.map(r => Number(r?.s?.derived?.rank2?.rawScore)).filter(x=>isFinite(x) && x>=0).sort((a,b)=>a-b);
    if(raws.length < 5) return null;
    const p75 = raws[Math.floor(0.75*(raws.length-1))];
    if(!isFinite(p75) || p75<=0) return null;
    const y = _smClamp(targetRating/100, 0.01, 0.99); // avoid inf
    // rating = 100*(1-exp(-k*raw))  =>  k = -ln(1-y)/raw
    const k = -Math.log(1 - y) / p75;
    return (isFinite(k) && k>0) ? k : null;
  }catch(_e){ return null; }
}

function _smOnCalibrateClick(ev){
  try{
    const k = _smSuggestScoreKFromData(80);
    if(k == null){
      try{ if(typeof showToast==='function') showToast('Not enough sessions to calibrate (need ~5+ rows).','warn'); }catch(_e){}
      try{ if(typeof showToast!=='function') alert('Not enough sessions to calibrate. Load more sessions.'); }catch(_e){}
      return;
    }
    _smSetScoreK(k);
    const msg = `Calibrated score scale (k=${k.toFixed(3)}; P75 raw ‚âà 80).`;
    try{ if(typeof showToast==='function') showToast(msg,'ok'); else alert(msg); }catch(_e){ try{ alert(msg);}catch(__){} }
    try{ renderShotMarkerSessionCards(); }catch(_e){}
    try{
      const p = document.getElementById('smSanityPanel');
      if(p && !p.classList.contains('hidden')) _smToggleSanityPanel(true);
    }catch(_e){}
  }catch(e){
    console.error(e);
    try{ if(typeof showToast==='function') showToast('Calibrate failed: '+(e?.message||e),'error'); else alert('Calibrate failed.'); }catch(_e){}
  }
}

function _smScoreTo100(raw){
  raw = Number(raw);
  if(!isFinite(raw)) return null;
  // Map raw>=0 to 0..100 using a smooth saturating curve.
  // k is user-tuneable (stored in localStorage as 'grt_sm_score_k').
  const k = _smGetScoreK();
  const rating = 100 * (1 - Math.exp(-k * Math.max(0, raw)));
  return _smClamp(rating, 0, 100);
}


function _smLogPhase2SanityTable(force){
  try{
    const rows = (window.__xqaSmPhase2Rows||[]);
    if(!rows.length){ console.warn('No ShotMarker Phase 2 rows available.'); return; }
    if(!force && window.__SM_SANITY_PRINTED__){ return (window.__SM_SANITY_ROWS__||null); }
    window.__SM_SANITY_PRINTED__ = true;

    function _smChronoStatsForCharge(ci){
      try{
        if(!Number.isFinite(ci)) return null;
        const idx = Number(ci) - 1; // charges are 1-based in UI
        const a = (window.allStats || allStats || []);
        const item = (Array.isArray(a) && a[idx]) ? a[idx] : null;
        const st = item && item.stats ? item.stats : null;
        return st && typeof st === 'object' ? st : null;
      }catch(_e){ return null; }
    }

    const out = rows.map((x,i)=>{
      const s=x.s||{};
      const d=s.derived||{};
      const r=d.rank2||{};
      const meta=s.meta||{};

      // ShotMarker model-fit velocity (target-derived)
      const modelVsd = (d.velocityDiag && Number.isFinite(d.velocityDiag.vSD)) ? d.velocityDiag.vSD : null;
      const modelVes = (d.velocityDiag && Number.isFinite(d.velocityDiag.vES)) ? d.velocityDiag.vES : null;

      // Chrono-linked velocity SD (if linked to a charge)
      const ci = (Number.isFinite(r.chargeIndex) ? r.chargeIndex : (Number.isFinite(x.ci) ? x.ci : null));
      const chronoStats = _smChronoStatsForCharge(ci);
      const chronoV = (typeof xqaGetVelocitySD === 'function') ? xqaGetVelocitySD(chronoStats) : {v:null, src:'missing'};
      const chronoVsd = Number.isFinite(chronoV.v) ? chronoV.v : null;
      const chronoSrc = chronoV && chronoV.src ? chronoV.src : (chronoVsd!=null ? 'computed' : 'missing');

      // prefer a single "SD for sanity" display:
      // - if model-fit exists, call it model-fit
      // - else if chrono SD exists, show that with its src
      // - else missing/insufficient per chronoSrc
      let sdDisplay = null;
      let sdSource = 'missing';
      if (Number.isFinite(modelVsd)) {
        sdDisplay = modelVsd;
        sdSource = 'model-fit';
      } else if (Number.isFinite(chronoVsd)) {
        sdDisplay = chronoVsd;
        sdSource = chronoSrc;
      } else {
        sdDisplay = null;
        sdSource = chronoSrc || 'missing';
      }

      const raw =
        (Number.isFinite(r.rawScore) ? r.rawScore :
         (Number.isFinite(r.raw) ? r.raw : null));

      const score100 =
        (Number.isFinite(r.score100) ? r.score100 :
         (Number.isFinite(r.score) ? r.score : null));

      const flags = (d.velocityDiag && d.velocityDiag.flags) ? d.velocityDiag.flags : {};
      const hasAnyVelocity = Number.isFinite(modelVsd) || Number.isFinite(chronoVsd);
      const why = (r.reasons && r.reasons.length) ? r.reasons.join(' ‚Ä¢ ') : (hasAnyVelocity ? '' : 'target-only (no velocity)');

      return {
        idx:i,
        charge: (Number.isFinite(ci)?('Charge '+ci):'Unlinked'),
        session: (meta.sessionKey||x.key||'').split('|')[1]|| (meta.sessionKey||x.key||''),
        totalShots: (Number.isFinite(d.totalShots)?d.totalShots:null),
        sighterShots: (Number.isFinite(d.sighterShots)?d.sighterShots:null),
        scoringShots: (Number.isFinite(d.scoringShots)?d.scoringShots:null),
        nShots: (Number.isFinite(d.scoringShots)?d.scoringShots:(Number.isFinite(r.nShots)?r.nShots:null)),
        mrMOA: (Number.isFinite(d.mrMoa)? +d.mrMoa.toFixed(3): null),
        vertMOA: (Number.isFinite(d.vertMoa)? +d.vertMoa.toFixed(3): null),

        // new fields
        modelVsdFPS: (modelVsd==null ? null : +modelVsd.toFixed(1)),
        modelVesFPS: (modelVes==null ? null : +modelVes.toFixed(1)),
        chronoVsdFPS: (chronoVsd==null ? null : +chronoVsd.toFixed(1)),
        chronoVsdSource: chronoSrc,
        sdFPS: (sdDisplay==null ? null : +sdDisplay.toFixed(1)),
        sdSource: sdSource,
        why: why,
        flags: flags,

        raw: (raw==null ? null : +raw.toFixed(3)),
        score100: (score100==null ? null : +score100.toFixed(1))
      };
    });

    console.table(out);
    window.__SM_SANITY_ROWS__ = out;
    return out;
  }catch(e){ console.error(e); return null; }
}



function _smEscHtml(s){
  return String(s==null?'':s)
    .replace(/&/g,'&amp;').replace(/</g,'&lt;')
    .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
}

function _smRenderSanityPanelRows(rows){
  if(!Array.isArray(rows) || !rows.length){
    return '<div class="text-[11px] text-grt-subtle">No rows available yet. Load ShotMarker data, then open this panel again.</div>';
  }
  const head = ['Charge','Session','Shots (SC)','MR (MOA)','Vert (MOA)','SD (fps)','SD source','Model SD','Chrono SD','Chrono src','Why','Score'];
  const ths = head.map(h=>`<th class="py-1 px-2 text-[10px] uppercase tracking-wide text-grt-subtle whitespace-nowrap">${_smEscHtml(h)}</th>`).join('');
  const pill = (txt, cls)=>`<span class="inline-flex items-center px-2 py-0.5 rounded-full border ${cls} text-[10px] whitespace-nowrap">${_smEscHtml(txt)}</span>`;
  const srcPill = (src)=>{
    const s = String(src||'missing').toLowerCase();
    if(s==='model-fit') return pill('model-fit','border-sky-400/40 bg-sky-500/10 text-sky-200');
    if(s==='computed' || s==='measured') return pill(s,'border-emerald-400/40 bg-emerald-500/10 text-emerald-200');
    if(s==='insufficient') return pill('insufficient','border-amber-400/40 bg-amber-500/10 text-amber-200');
    if(s==='missing') return pill('missing','border-slate-400/30 bg-slate-500/10 text-slate-200');
    return pill(s,'border-slate-400/30 bg-slate-500/10 text-slate-200');
  };

  const trs = rows.map(r=>{
    const sd = (r.sdFPS==null) ? '‚Äî' : r.sdFPS;
    const modelSd = (r.modelVsdFPS==null) ? '‚Äî' : r.modelVsdFPS;
    const chronoSd = (r.chronoVsdFPS==null) ? '‚Äî' : r.chronoVsdFPS;
    const why = r.why || '';
    return `<tr class="border-t border-grt-frame/40 align-top">
      <td class="py-1 px-2 text-[11px] text-white/90 whitespace-nowrap">${_smEscHtml(r.charge)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80 whitespace-nowrap">${_smEscHtml(r.session)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80 text-right" title="${Number.isFinite(r.totalShots)?(`Total: ${r.totalShots} ‚Ä¢ Sighters: ${r.sighterShots||0}`):``}">${_smEscHtml(r.nShots)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80 text-right">${_smEscHtml(r.mrMOA)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80 text-right">${_smEscHtml(r.vertMOA)}</td>
      <td class="py-1 px-2 text-[11px] text-white/90 text-right font-semibold">${_smEscHtml(sd)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80">${srcPill(r.sdSource)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80 text-right">${_smEscHtml(modelSd)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80 text-right">${_smEscHtml(chronoSd)}</td>
      <td class="py-1 px-2 text-[11px] text-white/80">${srcPill(r.chronoVsdSource)}</td>
      <td class="py-1 px-2 text-[11px] text-white/70 max-w-[260px]">${_smEscHtml(why)}</td>
      <td class="py-1 px-2 text-[11px] text-white/90 text-right font-semibold">${_smEscHtml(r.score100)}</td>
    </tr>`;
  }).join('');
  return `<div class="text-[10px] text-grt-subtle mb-2">
    SD (fps) prefers <span class="text-white/80">model-fit</span> when available; otherwise uses linked chrono SD (computed/insufficient/missing).
  </div>
  <table class="min-w-full text-left">
    <thead><tr class="border-b border-grt-frame/60">${ths}</tr></thead>
    <tbody>${trs}</tbody>
  </table>`;
}

function _smToggleSanityPanel(force, hide){
  try{
    const panel = document.getElementById('smSanityPanel');
    const body = document.getElementById('smSanityPanelBody');
    if(!panel || !body){
      console.warn('Sanity panel DOM not found (render ShotMarker Ranking first).');
      // still allow console logging
      return _smLogPhase2SanityTable(!!force);
    }
    if(hide){
      panel.classList.add('hidden');
      return;
    }
    // toggle visibility
    const willShow = panel.classList.contains('hidden');
    if(willShow){
      panel.classList.remove('hidden');
    }
    const rows = _smLogPhase2SanityTable(true);
    body.innerHTML = _smRenderSanityPanelRows(rows||[]);
    return rows;
  }catch(e){ console.error(e); return null; }
}


// --- Current Tune + Improvement helpers (v0.89) ---
function _smParseDateISOFromMeta(meta){
  try{
    const dt = (meta && meta.dateText) ? String(meta.dateText) : '';
    if(!dt) return null;
    const first = dt.split('|')[0].trim(); // e.g. "Sep 25 2025"
    if(!first) return null;

    // Prefer Date.parse for portability; fall back to manual month parse.
    let t = Date.parse(first);
    if(!isFinite(t)){
      const m = /^([A-Za-z]{3,})\s+(\d{1,2})\s+(\d{4})$/.exec(first);
      if(m){
        const mon = m[1].slice(0,3).toLowerCase();
        const map = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11};
        const mm = map[mon];
        if(mm!=null){
          const dd = Number(m[2]), yy = Number(m[3]);
          const d = new Date(yy, mm, dd);
          t = d.getTime();
        }
      }
    }
    if(!isFinite(t)) return null;

    const d = new Date(t);
    if(!isFinite(d.getTime())) return null;
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return yyyy + '-' + mm + '-' + dd;
  }catch(e){ return null; }
}

function _smDecayWeight(ageDays, halfLifeDays=14, floor=0.15){
  ageDays = Number(ageDays||0);
  if(!isFinite(ageDays) || ageDays<0) ageDays = 0;
  const w = Math.pow(0.5, ageDays / halfLifeDays);
  return Math.max(floor, w);
}
function _smShotConfWeight(shots){
  shots = Number(shots||0);
  if(!isFinite(shots) || shots < 10) return 0;
  const extra = Math.floor((shots - 10) / 5);
  return Math.min(1.0, 0.8 + extra * 0.1); // 10‚Üí0.8, 15‚Üí0.9, 20‚Üí1.0
}
function _smVertSeverity1000(vMoa){
  if(!isFinite(vMoa)) return null;
  if(vMoa <= 0.80) return 'GREEN';
  if(vMoa <= 1.05) return 'YELLOW';
  if(vMoa <= 1.30) return 'ORANGE';
  return 'RED';
}
function _smCurrentTuneVertical(sessions, nowDate){
  const now = nowDate || new Date();
  const elig = (Array.isArray(sessions)?sessions:[]).filter(s=>{
    const m=s?.meta||{}; const d=s?.derived||{};
    const dist = (m.distanceYd && isFinite(m.distanceYd)) ? Number(m.distanceYd) : 1000;
    const shots = Number.isFinite(d.scoringShots) ? Number(d.scoringShots)
                 : (Number.isFinite(d.shots) ? Number(d.shots) : Number(m.shots||0));
    const v = Number.isFinite(d.vertMoa)?Number(d.vertMoa):null;
    return (Math.abs(dist-1000) <= 2) && shots>=10 && isFinite(v);
  });
  if(!elig.length) return null;
  let num=0, den=0;
  for(const s of elig){
    const m=s?.meta||{}; const d=s?.derived||{};
    const shots = Number.isFinite(d.scoringShots) ? Number(d.scoringShots)
                 : (Number.isFinite(d.shots) ? Number(d.shots) : Number(m.shots||0));
    const v = Number(d.vertMoa);
    const iso=_smParseDateISOFromMeta(m);
    const dt = iso ? new Date(iso) : null;
    const ageDays = dt ? ((now - dt)/(1000*60*60*24)) : 0;
    const w = _smDecayWeight(ageDays) * _smShotConfWeight(shots);
    num += w * v; den += w;
  }
  return den>0 ? (num/den) : null;
}

function _smSupportScore(sessions, nowDate){
  const now = nowDate || new Date();
  let support = 0;
  for(const s of (Array.isArray(sessions)?sessions:[])){
    const m=s?.meta||{}; const d=s?.derived||{};
    const dist = (m.distanceYd && isFinite(m.distanceYd)) ? Number(m.distanceYd) : 1000;
    const shots = Number.isFinite(d.scoringShots) ? Number(d.scoringShots)
                 : (Number.isFinite(d.shots) ? Number(d.shots) : Number(m.shots||0));
    const v = Number.isFinite(d.vertMoa)?Number(d.vertMoa):null;
    if(Math.abs(dist-1000) > 2 || shots<10 || !isFinite(v)) continue;
    const iso=_smParseDateISOFromMeta(m);
    const dt = iso ? new Date(iso) : null;
    const ageDays = dt ? ((now - dt)/(1000*60*60*24)) : 0;
    support += _smDecayWeight(ageDays) * _smShotConfWeight(shots);
  }
  return support;
}

function _smImprovementForCharge(chargeSessions, nowDate){
  const now = nowDate || new Date();
  const recentWindowDays = 14;
  const priorWindowDays = 60;

  const recent = (Array.isArray(chargeSessions)?chargeSessions:[]).filter(s=>{
    const iso=_smParseDateISOFromMeta(s?.meta||{});
    const dt = iso ? new Date(iso) : null;
    const age = dt ? ((now - dt)/(1000*60*60*24)) : 9999;
    return age <= recentWindowDays;
  });
  const prior = (Array.isArray(chargeSessions)?chargeSessions:[]).filter(s=>{
    const iso=_smParseDateISOFromMeta(s?.meta||{});
    const dt = iso ? new Date(iso) : null;
    const age = dt ? ((now - dt)/(1000*60*60*24)) : 9999;
    return age > recentWindowDays && age <= priorWindowDays;
  });

  const vRecent = _smCurrentTuneVertical(recent, now);
  const vPrior  = _smCurrentTuneVertical(prior, now);
  if(!isFinite(vRecent) || !isFinite(vPrior)) return null;

  if(_smSupportScore(recent, now) < 1.0) return null;

  const delta = vPrior - vRecent; // positive = improvement
  const sevRecent = _smVertSeverity1000(vRecent);
  const sevPrior  = _smVertSeverity1000(vPrior);

  const severityImproved =
    (sevPrior==='RED'    && (sevRecent==='ORANGE'||sevRecent==='YELLOW'||sevRecent==='GREEN')) ||
    (sevPrior==='ORANGE' && (sevRecent==='YELLOW'||sevRecent==='GREEN')) ||
    (sevPrior==='YELLOW' && sevRecent==='GREEN');

  const moaImproved = (delta >= 0.15);

  if(!(severityImproved || moaImproved)) return null;

  return {
    deltaMOA: delta,
    label: 'Vertical improved vs prior tune',
    detail: 'Œî ‚àí' + __fmtNum(delta,2) + ' MOA (recent ' + recentWindowDays + 'd vs prior ' + priorWindowDays + 'd)'
  };
}
function _smImprovementsByCharge(strings){
  const sessions = Array.isArray(strings)?strings:[];
  const by = {};
  for(const s of sessions){
    const ci = _smGetLinkedChargeIndex(s);
    if(ci==null || !isFinite(ci)) continue;
    (by[ci] ||= []).push(s);
  }
  const out = {};
  for(const k of Object.keys(by)){
    const imp = _smImprovementForCharge(by[k], new Date());
    if(imp) out[String(k)] = imp;
  }
  return out;
}
function _smImprovementIconHtml(ci){
  const imp = (window.__xqaSmImprovementsByCharge||{})[String(ci)];
  if(!imp) return '';
  const tip = (imp.detail||imp.label||'Improved');
  return ' <span title="' + tip.replace(/"/g,'&quot;') + '" class="ml-1 inline-flex items-center justify-center w-5 h-5 rounded-full bg-emerald-500/15 border border-emerald-400/25 text-emerald-200 text-[11px]">‚Üë</span>';
}
function _smImprovementPillHtml(ci){
  const imp = (window.__xqaSmImprovementsByCharge||{})[String(ci)];
  if(!imp) return '';
  const tip = (imp.detail||imp.label||'Improved').replace(/"/g,'&quot;');
  const lab = (imp.label||'Improved');
  return '<div class="mt-2 inline-flex items-center gap-2 px-2 py-1 rounded-full bg-emerald-500/10 border border-emerald-400/20 text-emerald-200 text-[11px]" title="' + tip + '"><span class="text-[12px]">‚Üë</span><span>' + lab + '</span></div>';
}

function _smPearson(x,y){
  const n=x.length; if(n<2) return null;
  const mx=x.reduce((a,v)=>a+v,0)/n, my=y.reduce((a,v)=>a+v,0)/n;
  let num=0, dx2=0, dy2=0;
  for(let i=0;i<n;i++){ const dx=x[i]-mx, dy=y[i]-my; num+=dx*dy; dx2+=dx*dx; dy2+=dy*dy; }
  const den=Math.sqrt(dx2*dy2); if(!den) return null;
  return num/den;
}
function _smLinReg(v,y){
  const n=v.length; if(n<2) return null;
  const mv=v.reduce((a,x)=>a+x,0)/n, my=y.reduce((a,x)=>a+x,0)/n;
  let sVV=0, sVY=0;
  for(let i=0;i<n;i++){ const dv=v[i]-mv; sVV+=dv*dv; sVY+=dv*(y[i]-my); }
  if(!sVV) return null;
  const b=sVY/sVV; // mm per fps
  const a=my-b*mv; // mm
  return {a,b};
}

function _smComputeVelocityModelMm(shots){
  const valid = (shots||[]).filter(s=> Number.isFinite(s.v) && Number.isFinite(s.y));
  const n=valid.length;
  if(n<4) return {n, a:null,b:null, rmseMm:null, predictedSpanMm:null, corr:null, r2:null, vSD:null, vES:null};

  const v=valid.map(s=>Number(s.v));
  const y=valid.map(s=>Number(s.y));

  // basic velocity stats
  const vMin=Math.min(...v), vMax=Math.max(...v);
  const vES=vMax-vMin;
  const vMean=v.reduce((a,x)=>a+x,0)/n;
  const vVar=v.reduce((a,x)=>a+(x-vMean)*(x-vMean),0)/(n-1);
  const vSD=Math.sqrt(vVar);

  const corr=_smPearson(v,y);
  const r2=(corr==null)?null:(corr*corr);

  const fit=_smLinReg(v,y);
  if(!fit) return {n,a:null,b:null, rmseMm:null, predictedSpanMm:null, corr, r2, vSD, vES};

  const resid = v.map((x,i)=> y[i] - (fit.a + fit.b*x));
  const rmseMm = Math.sqrt(resid.reduce((a,e)=>a+e*e,0)/n);
  const predictedSpanMm = Math.abs(fit.b) * vES;

  let minR=Infinity,maxR=-Infinity,sumAbs=0;
  for(const r of resid){ if(r<minR)minR=r; if(r>maxR)maxR=r; sumAbs+=Math.abs(r); }
  const residualVerticalESmm = maxR-minR;
  const residualMeanAbsMm = sumAbs/n;

  return {
    n,
    a: fit.a,
    b: fit.b,
    slopeMmPerFps: fit.b,
    rmseMm,
    predictedSpanMm,
    corr,
    r2,
    vSD,
    vES,
    residualVerticalESmm,
    residualMeanAbsMm
  };
}

function _smDiagFlagsFromModel(model, vertMm){
  const flags={weirdSign:false, velocityDominated:false, windDominated:false, mixed:false};
  const corr=Number.isFinite(model?.corr)?model.corr:null;
  const r2=Number.isFinite(model?.r2)?model.r2:null;
  const resid=Number.isFinite(model?.residualVerticalESmm)?model.residualVerticalESmm:null;

  if(corr!=null && corr<=-0.35) flags.weirdSign=true;

  if(!Number.isFinite(vertMm) || resid==null || r2==null){
    flags.mixed=true; return flags;
  }
  const share = resid/(vertMm||1e-9);
  if(r2>=0.45 && share<=0.55) flags.velocityDominated=true;
  else if(r2<=0.15 && share>=0.80) flags.windDominated=true;
  else flags.mixed=true;

  return flags;
}

// attach Phase1-ish derived velocity fields to session (mm native)
function _smEnsureVelocityDerived(session){
  if(!session) return;
  session.derived = session.derived || {};
  // already computed?
  if(session.derived.velocityModel && session.derived.velocityResidual && session.derived.velocityDiag) return;

  const shots = Array.isArray(session.shots) ? session.shots : [];
  // normalize shots fields we expect: {x,y,v}
  const model=_smComputeVelocityModelMm(shots);
  session.derived.velocityModel = {
    n: model.n,
    slopeMmPerFps: Number.isFinite(model.slopeMmPerFps)?model.slopeMmPerFps:null,
    rmseMm: Number.isFinite(model.rmseMm)?model.rmseMm:null,
    predictedSpanMm: Number.isFinite(model.predictedSpanMm)?model.predictedSpanMm:null
  };
  session.derived.velocityResidual = {
    n: model.n,
    residualVerticalESmm: Number.isFinite(model.residualVerticalESmm)?model.residualVerticalESmm:null,
    residualMeanAbsMm: Number.isFinite(model.residualMeanAbsMm)?model.residualMeanAbsMm:null
  };
  const vertMm = Number.isFinite(session.derived.vertMm) ? session.derived.vertMm : null;
  const flags=_smDiagFlagsFromModel(model, vertMm);
  session.derived.velocityDiag = {
    source: "model-fit",
    n: model.n,
    corr: Number.isFinite(model.corr)?model.corr:null,
    r2: Number.isFinite(model.r2)?model.r2:null,
    vSD: Number.isFinite(model.vSD)?model.vSD:null,
    vES: Number.isFinite(model.vES)?model.vES:null,
    flags
  };
}

// Phase 2.0 rank (headless)
// Return the linked charge index for a ShotMarker session (manual map first, then derived match)
function _smGetLinkedChargeIndex(session){
  try{
    const d = (session && session.derived) ? session.derived : {};
    if (Number.isFinite(d.manualChargeIndex)) return Number(d.manualChargeIndex);
    const cm = d.chargeMatch;
    if (cm && Number.isFinite(cm.chargeIndex)) return Number(cm.chargeIndex);
    const key = (session && session.meta && session.meta.sessionKey) ? session.meta.sessionKey : (typeof _smSessionKey === 'function' ? _smSessionKey(session) : '');
    if (key && typeof shotMarkerManualMap === 'object' && shotMarkerManualMap && Object.prototype.hasOwnProperty.call(shotMarkerManualMap, key)) {
      const v = Number(shotMarkerManualMap[key]);
      if (Number.isFinite(v)) return v;
    }
  }catch(e){}
  return null;
}

function _smRank2ForSession(session){
  if(!session) return {score:null, label:'mixed', reasons:[]};
  _smEnsureVelocityDerived(session);

  const d=session.derived||{};
  const meta=session.meta||{};
  const distanceYd = (meta.distanceYd && Number.isFinite(meta.distanceYd)) ? meta.distanceYd : 1000;

  const nShots = Number.isFinite(d.shots)?Number(d.shots):(Array.isArray(session.shots)?session.shots.length:0);
  const conf=_smConfFromN(nShots);

  const vertMoa = Number.isFinite(d.vertMoa) ? d.vertMoa : (Number.isFinite(d.vertMm)? _mmToMoa(d.vertMm, distanceYd): null);
  const mrMoa   = Number.isFinite(d.mrMoa) ? d.mrMoa : (Number.isFinite(d.mrMm)? _mmToMoa(d.mrMm, distanceYd): null);

  const residVertMm = (d.velocityResidual && Number.isFinite(d.velocityResidual.residualVerticalESmm)) ? d.velocityResidual.residualVerticalESmm : null;
  const residVertMoa = (residVertMm!=null) ? _mmToMoa(residVertMm, distanceYd) : null;

  const r2 = (d.velocityDiag && Number.isFinite(d.velocityDiag.r2)) ? d.velocityDiag.r2 : null;
  const vSD_src = (d.velocityDiag && typeof d.velocityDiag.source==='string') ? d.velocityDiag.source : ((d.velocityDiag && typeof d.velocityDiag.vSDSource==='string') ? d.velocityDiag.vSDSource : null);
  let vSD = (d.velocityDiag && Number.isFinite(d.velocityDiag.vSD)) ? d.velocityDiag.vSD : null;
  // Score gating: only allow velocity SD to influence score when it has an explicit, trustworthy source.
  // (model-fit from ShotMarker OR chrono-computed/measured if you ever feed it in)
  if(vSD != null){
    const okSrc = (vSD_src === 'model-fit' || vSD_src === 'computed' || vSD_src === 'measured');
    if(!okSrc) vSD = null;
  }


  // weights (simple + tunable later)
  const wResid=1.6, wVert=1.0, wMR=0.6, wVel=0.35;

  // smaller is better -> convert to points
  const cResid = Number.isFinite(residVertMoa) ? (wResid * (1/(residVertMoa+0.05))) : 0;
  const cVert  = Number.isFinite(vertMoa) ? (wVert * (1/(vertMoa+0.05))) : 0;
  const cMR    = Number.isFinite(mrMoa) ? (wMR * (1/(mrMoa+0.03))) : 0;

  const r2Eff = Number.isFinite(r2)?Math.max(0,Math.min(1,r2)):0;
  const cVel = (Number.isFinite(vSD) && vSD>0) ? (wVel * (1/(vSD+1)) * (0.5+0.5*r2Eff)) : 0;

  let score = cResid + cVert + cMR + cVel;
  score *= (0.35 + 0.65*conf);

  const flags = d.velocityDiag?.flags || {};
  if(flags.velocityDominated) score *= 1.05;
  if(flags.windDominated) score *= 0.85;
  if(flags.weirdSign) score *= 0.10;

    const rawScore = score;
  const score100 = _smScoreTo100(rawScore);
  score = (score100==null? null : score100);

const reasons=[];
  if(Number.isFinite(residVertMoa)) reasons.push(`residualV ${residVertMoa.toFixed(2)} MOA`);
  else if(Number.isFinite(vertMoa)) reasons.push(`vert ${vertMoa.toFixed(2)} MOA`);
  if(Number.isFinite(vSD)) reasons.push(`SD ${vSD.toFixed(1)}`);
  if(Number.isFinite(r2)) reasons.push(`r¬≤ ${r2.toFixed(2)}`);

  let label='mixed';
  if(flags.weirdSign) label='weird';
  else if(flags.velocityDominated) label='velocity';
  else if(flags.windDominated) label='wind';

  return { score, rawScore, label, reasons, confidence: conf, nShots };
}

function computeShotMarkerPhase2(strings){
  const sessions = Array.isArray(strings)?strings:[];
  sessions.forEach(s=>{
    if(!s) return;
    s.derived = s.derived || {};
    // Phase 3: geometry diagnostics
    s.derived.phase3 = _smPhase3ForSession(s);
    s.derived.rank2 = _smRank2ForSession(s);
    const ci = _smGetLinkedChargeIndex(s);
    if(Number.isFinite(ci)) s.derived.rank2.chargeIndex = ci;
  });
  const chargeRollups = computeShotMarkerChargeRollups(sessions);
  window.__xqaSmPhase2 = { updatedAt:new Date().toISOString(), sessionCount:sessions.length, chargeRollups };

// =============================
// Phase 3.0: Session diagnostics (geometry + outliers)
// =============================
function _smPhase3ForSession(session){
  try{
    if(!session) return { badges:[], notes:[] };
    const d = session.derived || (session.derived = {});
    const meta = session.meta || {};
    const distanceYd = (meta.distanceYd && Number.isFinite(meta.distanceYd)) ? meta.distanceYd : 1000;

    // Gather XY in mm from shot list
    const shots = Array.isArray(session.shots) ? session.shots : (Array.isArray(d.shotList)?d.shotList:[]);
    const xs=[], ys=[];
    for(const sh of shots){
      if(sh && Number.isFinite(sh.xMm) && Number.isFinite(sh.yMm)){
        xs.push(Number(sh.xMm)); ys.push(Number(sh.yMm));
      }
    }
    if(xs.length < 3){
      const hasVel = Number.isFinite(d.velocityDiag?.vSD) || Number.isFinite(d.velocityDiag?.corr);
      const badges = hasVel ? [] : [{ key:'targetOnly', icon:'üìÑ', label:'target-only', sev:'info', detail:'No per-shot velocity in this file.' }];
      return { badges, notes:[] };
    }

    const gm = _computeGroupMetricsFromXY(xs, ys);
    if(!gm) return { badges:[], notes:[] };

    const vertMm = Number.isFinite(d.vertMm) ? d.vertMm : gm.vert;
    const horizMm = Number.isFinite(d.horizMm) ? d.horizMm : gm.horiz;
    const esMm = Number.isFinite(d.esMm) ? d.esMm : gm.es;
    const mrMm = Number.isFinite(d.mrMm) ? d.mrMm : gm.mr;

    const vertMoa = _mmToMoa(vertMm, distanceYd);
    const horizMoa = _mmToMoa(horizMm, distanceYd);
    const mrMoa = _mmToMoa(mrMm, distanceYd);

    const badges=[];
    const notes=[];

    // Target-only badge (if no velocity fields)
    const hasVel = Number.isFinite(d.velocityDiag?.vSD) || Number.isFinite(d.velocityDiag?.corr) || Number.isFinite(d.velocityDiag?.r2);
    if(!hasVel) badges.push({ key:'targetOnly', icon:'üìÑ', label:'target-only', sev:'info', detail:'No per-shot velocity in this file.' });

    // Vertical / horizontal stringing
    const ratioVH = (horizMm>0) ? (vertMm/horizMm) : null;
    const ratioHV = (vertMm>0) ? (horizMm/vertMm) : null;

    if(ratioVH!=null && ratioVH >= smPhase3Config.ratioDom && vertMoa >= smPhase3Config.stringMoaMin){
      badges.push({ key:'verticalString', icon:'‚¨ÜÔ∏è', label:'vertical string', sev:'warn', detail:`Vertical dominates horizontal (${ratioVH.toFixed(2)}√ó).`});
      notes.push('Vertical stringing often tracks velocity/temperature or elevation/hold consistency.');
    } else if(ratioHV!=null && ratioHV >= smPhase3Config.ratioDom && horizMoa >= smPhase3Config.stringMoaMin){
      badges.push({ key:'horizontalString', icon:'‚û°Ô∏è', label:'horizontal string', sev:'warn', detail:`Horizontal dominates vertical (${ratioHV.toFixed(2)}√ó).`});
      notes.push('Horizontal stringing often tracks wind, tracking, or aiming drift.');
    }

    
    // If neither vertical nor horizontal dominates, tag the overall shape as "round/neutral"
    if(!badges.some(b => b.key==='verticalString' || b.key==='horizontalString')){
      if(ratioVH!=null){
        badges.push({ key:'roundGroup', icon:'‚≠ï', label:'round', sev:'ok', detail:`Aspect V/H ${ratioVH.toFixed(2)}√ó.`});
      } else {
        badges.push({ key:'roundGroup', icon:'‚≠ï', label:'round', sev:'ok', detail:'No dominant axis detected.'});
      }
    }

    // "Tight" badge (helps when everything is clean and other heuristics stay quiet)
    if(mrMoa != null && vertMoa != null && mrMoa <= 0.25 && vertMoa <= 0.75){
      badges.push({ key:'tightGroup', icon:'üü¢', label:'tight', sev:'ok', detail:`MR ${mrMoa.toFixed(2)} MOA ‚Ä¢ Vert ${vertMoa.toFixed(2)} MOA.`});
    }

// Tight-but-off-center (centroid far from origin relative to group size)
    const cDistMm = Math.sqrt(gm.cx*gm.cx + gm.cy*gm.cy);
    const cDistMoa = _mmToMoa(cDistMm, distanceYd);
    if(mrMoa <= 0.25 && cDistMoa >= 0.35){
      badges.push({ key:'offCenter', icon:'üéØ', label:'tight but off-center', sev:'info', detail:`Centroid offset ${cDistMoa.toFixed(2)} MOA.`});
      notes.push('Tight group but displaced: confirm zero or aimpoint reference.');
    }

    // Outlier-driven ES
    const radii = Array.isArray(gm.r) ? gm.r.slice().sort((a,b)=>a-b) : [];
    if(radii.length >= 5){
      const med = radii[Math.floor(radii.length*0.5)];
      const r95 = radii[Math.floor(radii.length*0.95)];
      const rMax = radii[radii.length-1];
      if(med>0 && rMax >= 2.8*med && (rMax - r95) >= 0.15*esMm){
        badges.push({ key:'outlier', icon:'‚ö†Ô∏è', label:'outlier-driven', sev:'warn', detail:'One/few shots are inflating ES.'});
        notes.push('Consider calling/factoring obvious outliers (wind break, shooter error) when evaluating load.');
      }
    }

    // Double-group suspicion (1D gap test on Y then X)
    function _largestGap(arr){
      const a = arr.slice().sort((x,y)=>x-y);
      let maxGap=0, idx=-1;
      for(let i=0;i<a.length-1;i++){
        const g = a[i+1]-a[i];
        if(g>maxGap){ maxGap=g; idx=i; }
      }
      return { maxGap, idx, sorted:a };
    }
    const gy=_largestGap(ys);
    const spanY = Math.max(...ys) - Math.min(...ys);
    if(spanY>0 && gy.maxGap >= 0.35*spanY){
      const left = gy.idx+1;
      const right = ys.length-left;
      if(left>=3 && right>=3){
        badges.push({ key:'doubleGroupY', icon:'üß∑', label:'double-group?', sev:'warn', detail:'Bimodal vertical spacing detected.'});
        notes.push('Double-group patterns can indicate bedding/torque, bag/shoulder pressure shifts, or condition swings.');
      }
    } else {
      const gx=_largestGap(xs);
      const spanX = Math.max(...xs) - Math.min(...xs);
      if(spanX>0 && gx.maxGap >= 0.35*spanX){
        const left = gx.idx+1;
        const right = xs.length-left;
        if(left>=3 && right>=3){
          badges.push({ key:'doubleGroupX', icon:'üß∑', label:'double-group?', sev:'warn', detail:'Bimodal horizontal spacing detected.'});
          notes.push('Double-group horizontal can be wind shifts, tracking changes, or position inconsistency.');
        }
      }
    }

    d.phase3 = { badges, notes };
    return d.phase3;
  } catch(e){
    return { badges:[], notes:[] };
  }
}

function _smPhase3BadgePills(badges){
  const b = Array.isArray(badges)?badges:[];
  if(!b.length) return '<span class="text-grt-subtle text-[11px]">‚Äî</span>';
  return b.slice(0,4).map(x=>{
    const tip = String(x.detail || x.label || '').replace(/"/g,'&quot;');
    return `
      <span title="${tip}" class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full border border-grt-frame bg-grt-panel-soft/50 text-[10px] text-white/85">
        <span>${x.icon||'‚Ä¢'}</span><span>${x.label||''}</span>
      </span>
    `;
  }).join(' ');
}
window._smPhase3BadgePills = _smPhase3BadgePills;
}


// =============================
// Phase 2.2: Charge rollups
// =============================
function _smMedian(arr){
  const a = (arr||[]).filter(Number.isFinite).slice().sort((x,y)=>x-y);
  const n=a.length; if(!n) return null;
  const mid = Math.floor(n/2);
  return (n%2)? a[mid] : (a[mid-1]+a[mid])/2;
}
function _smMin(arr){ const a=(arr||[]).filter(Number.isFinite); return a.length?Math.min(...a):null; }
function _smMax(arr){ const a=(arr||[]).filter(Number.isFinite); return a.length?Math.max(...a):null; }

function _smChargeConfidence(nShotsTotal, nSessions, velocityCoverage){
  const confShots = _smConfFromN(nShotsTotal);
  const confSess = 1 - Math.exp(-(Number(nSessions||0))/3);
  const cov = Number.isFinite(velocityCoverage) ? velocityCoverage : 0;
  return confShots * confSess * (0.7 + 0.3*cov);
}

function computeShotMarkerChargeRollups(sessions){
  const list = Array.isArray(sessions)?sessions:[];
  const by = new Map();
  list.forEach(s=>{
    const ci = s?.derived?.rank2?.chargeIndex;
    if(!Number.isFinite(ci)) return;
    if(!by.has(ci)) by.set(ci, []);
    by.get(ci).push(s);
  });

  const rollups = [];
  for(const [ci, arr] of by.entries()){
    const scores = arr.map(s=>s?.derived?.rank2?.score);
    const vertMoa = arr.map(s=>_smGetSessionVertMoa(s));
    const mrMoa   = arr.map(s=>_smGetSessionMrMoa(s));
    const residMoa = arr.map(s=>{
      const mm = s?.derived?.velocityResidual?.residualVerticalESmm;
      const yd = _smGetSessionDistanceYd(s);
      return Number.isFinite(mm) ? _mmToMoa(mm, yd) : null;
    });

    const withVel = arr.filter(s=> Number.isFinite(s?.derived?.velocityDiag?.vSD) || Number.isFinite(s?.derived?.velocityDiag?.vES)).length;
    const velocityCoverage = arr.length ? (withVel / arr.length) : 0;

    const nShotsTotal = arr.reduce((a,s)=> a + Number(s?.meta?.shotCount || s?.meta?.shots || s?.shots?.length || 0), 0);
    const bestScore = _smMax(scores);
    const medianScore = _smMedian(scores);

    // best session = lowest score
    let bestSession = null;
    arr.forEach(s=>{
      const sc = s?.derived?.rank2?.score;
      if(!Number.isFinite(sc)) return;
      if(!bestSession || sc < bestSession.score){
        bestSession = { key: s?.meta?.sessionKey || '', title: s?.meta?.matchStr || s?.name || 'Session', score: sc, session: s };
      }
    });

    rollups.push({
      chargeIndex: Number(ci),
      nSessions: arr.length,
      nShotsTotal,
      velocityCoverage,
      bestScore,
      medianScore,
      medianVerticalMoa: _smMedian(vertMoa),
      medianMeanRadiusMoa: _smMedian(mrMoa),
      medianResidualVerticalMoa: _smMedian(residMoa),
      chargeConfidence: _smChargeConfidence(nShotsTotal, arr.length, velocityCoverage),
      bestSessionKey: bestSession?.key || '',
      sessions: arr
    });
  }

  // sort: best medianScore descending (fallback to bestScore)
  rollups.sort((a,b)=>{
    const am = Number.isFinite(a.medianScore) ? a.medianScore : a.bestScore;
    const bm = Number.isFinite(b.medianScore) ? b.medianScore : b.bestScore;
    if(Number.isFinite(am) && Number.isFinite(bm)) return bm - am;
    if(Number.isFinite(am)) return -1;
    if(Number.isFinite(bm)) return 1;
    return a.chargeIndex - b.chargeIndex;
  });

  return rollups;
}

function _smGetSessionDistanceYd(s){
  const yd = s?.meta?.distanceYd;
  return Number.isFinite(yd) ? yd : 1000;
}
function _smGetSessionVertMoa(s){
  const d = s?.derived || {};
  const yd = _smGetSessionDistanceYd(s);
  if(Number.isFinite(d.vertMoa)) return d.vertMoa;
  if(Number.isFinite(d.vertMm)) return _mmToMoa(d.vertMm, yd);
  return null;
}
function _smGetSessionMrMoa(s){
  const d = s?.derived || {};
  const yd = _smGetSessionDistanceYd(s);
  if(Number.isFinite(d.mrMoa)) return d.mrMoa;
  if(Number.isFinite(d.mrMm)) return _mmToMoa(d.mrMm, yd);
  return null;
}


// UI table
function _smRankIcon(label){
  if(label==='velocity') return '‚õΩ';
  if(label==='wind') return 'üå¨Ô∏è';
  if(label==='weird') return '‚ö†Ô∏è';
  return 'üéØ';
}


// v0.89: session verification baseline + tightened Phase 3 confidence
function _smConfBars(label){
  const l = String(label||'').toLowerCase();
  const n = (l==='high')?3:((l==='medium')?2:((l==='low')?1:0));
  const on = '‚ñÆ', off='‚óª';
  return (n>=1?on:off) + (n>=2?on:off) + (n>=3?on:off);
}
function _smDiagIconChar(type){
  if(type==='vertical') return '‚¨ç';
  if(type==='horizontal') return '‚áÑ';
  if(type==='scatter') return '‚úñ';
  return '‚Äî';
}
function _smDiagOpacity(label){
  const l = String(label||'').toLowerCase();
  if(l==='high') return 1.0;
  if(l==='medium') return 0.7;
  if(l==='low') return 0.4;
  return 0.45;
}
function _smDominantDiagHtml(dd){
  if(!dd || !dd.type) return '';
  const confLabel = dd?.conf?.label || 'Low';
  const domPct = Number.isFinite(dd.dominance) ? Math.round(dd.dominance*100) : null;
  const icon = _smDiagIconChar(dd.type);
  const op = _smDiagOpacity(confLabel);
  const name = (dd.type==='vertical')?'Vertical dispersion':(dd.type==='horizontal')?'Horizontal dispersion':'Scatter / instability';
  const tip = `${name} ‚Äî ${confLabel} confidence${domPct!=null?` (${domPct}% axis dominance)`:''}`;
  return `<span class="inline-flex items-center justify-center w-5" style="opacity:${op}" title="${tip}">${icon}</span>`;
}
function _smDominantDiagSummaryHtml(dd){
  if(!dd || !dd.type) return '';
  const confLabel = dd?.conf?.label || 'Low';
  const domPct = Number.isFinite(dd.dominance) ? Math.round(dd.dominance*100) : null;
  const name = (dd.type==='vertical')?'Vertical dispersion':(dd.type==='horizontal')?'Horizontal dispersion':'Scatter / instability';
  return `<div class="mt-2 text-[11px] text-grt-subtle">Dominant: <span class="text-white/90">${name}</span> <span class="ml-1 font-mono">${_smConfBars(confLabel)}</span> <span class="ml-1">${confLabel}</span>${domPct!=null?` <span class="ml-1">(${domPct}% axis)</span>`:''}</div>`;
}


function _shotMarkerPhase2RankingTableHtml(strings){
  const sessions = Array.isArray(strings)?strings:[];
  const improvements = _smImprovementsByCharge(sessions);
  window.__xqaSmImprovementsByCharge = improvements;
  const rows = sessions
    .map(s=>{
      const key = s?.meta?.sessionKey || '';
      const r = s?.derived?.rank2 || {};
      const score = Number.isFinite(r.score)?Number(r.score):null;
      const ci = _smGetLinkedChargeIndex(s);
      return {s,key,r,score,ci};
    })
    .filter(x=>x.key && x.score!=null)
    .sort((a,b)=>b.score-a.score);

  if(!rows.length) return '';

  const body = rows.map((x,i)=>`
    <tr class="border-t border-grt-frame/60 hover:bg-white/5 cursor-pointer" onclick="openSmDrilldown(${i})">
      <td class=\"py-2 px-2 text-[12px]\">${(((x.s?.derived?.velocityDiag && (Number.isFinite(x.s.derived.velocityDiag.vSD)||Number.isFinite(x.s.derived.velocityDiag.vES)||Number.isFinite(x.s.derived.velocityDiag.r2)||Number.isFinite(x.s.derived.velocityDiag.corr))) ? _smRankIcon(x.r.label) : 'üìÑ') + _smDominantDiagHtml(x.s?.derived?.dominantDiag))}</td>
      <td class="py-2 px-3 text-[11px] text-white/90">${((x.ci!=null && Number.isFinite(x.ci)) ? ("Charge "+x.ci) : "Unlinked") + _smImprovementIconHtml(x.ci)}</td>
      <td class=\"py-2 px-3 text-[11px] text-grt-subtle\">${_smPhase3BadgePills(x.s?.derived?.phase3?.badges)}<div class="mt-1">${(x.r.reasons && x.r.reasons.length)? x.r.reasons.join(' ‚Ä¢ ') : (((x.s?.derived?.velocityDiag && (Number.isFinite(x.s.derived.velocityDiag.vSD)||Number.isFinite(x.s.derived.velocityDiag.vES)||Number.isFinite(x.s.derived.velocityDiag.r2)||Number.isFinite(x.s.derived.velocityDiag.corr))) ? '' : 'target-only (no velocity)'))}</div></td>
      <td class="py-2 px-3 text-[11px] text-white/90">${x.score.toFixed(1)}</td>
    </tr>`).join('');

  // stash table rows for drilldown
  window.__xqaSmPhase2Rows = rows;

  return `
    <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-2xl p-3 mb-3">
      <div class="flex items-center justify-between gap-3 mb-2">
        <div class="text-white text-sm font-semibold">üèÅ ShotMarker Ranking (Phase 2.1)</div>
        <div class="flex items-center gap-3">
          <button class="text-[10px] text-white/70 hover:text-white underline decoration-white/20 hover:decoration-white/40"
            title="Show a side-by-side sanity table (MR, Vertical, SD, raw score, 0‚Äì100 score)."
            onclick="event.stopPropagation(); try{ _smToggleSanityPanel(true); }catch(e){ console.error(e);}">
            Sanity</button>
          <button class="text-[10px] text-white/70 hover:text-white underline decoration-white/20 hover:decoration-white/40"
            title="Auto-tunes the 0‚Äì100 score scale using your currently loaded data (sets k so P75 raw ‚âà 80)."
            onclick="event.stopPropagation(); try{ _smOnCalibrateClick(event); }catch(e){ console.error(e);} ">Calibrate</button>
          <div class="text-grt-subtle text-[10px]">Click a row to expand details</div>
        </div>
      </div>
      <div id="smSanityPanel" class="hidden mt-2 mb-2 bg-black/20 border border-grt-frame/60 rounded-xl p-2">
        <div class="flex items-center justify-between gap-2 mb-2">
          <div class="text-[11px] text-white/90 font-semibold">Sanity output</div>
          <div class="flex items-center gap-3">
            <button class="text-[10px] text-white/70 hover:text-white underline decoration-white/20 hover:decoration-white/40"
              title="Refresh the sanity table from current Phase 2 rows."
              onclick="event.stopPropagation(); try{ _smToggleSanityPanel(true); }catch(e){ console.error(e);}">Refresh</button>
            <button class="text-[10px] text-white/70 hover:text-white underline decoration-white/20 hover:decoration-white/40"
              title="Hide this panel."
              onclick="event.stopPropagation(); try{ _smToggleSanityPanel(false,true); }catch(e){ console.error(e);}">Hide</button>
          </div>
        </div>
        <div id="smSanityPanelBody" class="overflow-x-auto"></div>
      </div>
      <div class="overflow-x-auto">
        <table class="w-full text-left">
          <thead>
            <tr class="text-grt-subtle text-[10px] uppercase tracking-wide">
              <th class="py-2 px-2"> </th>
              <th class="py-2 px-3">Link</th>
              <th class="py-2 px-3">Why</th>
              <th class="py-2 px-3" title="Composite 0‚Äì100 (higher is better). Mean-radius score √ó vertical & velocity penalties (sighters excluded).">Score</th>
            </tr>
          </thead>
          <tbody>${body}</tbody>
        </table>
      </div>
    </div>`;
}


function __fmtNum(v,d){ return Number.isFinite(v) ? Number(v).toFixed(d) : '‚Äî'; }

// =============================
// Phase 2.2 UI: Charge leaderboard + drilldown
// =============================
function _smChargeIcon(ru){
  const cov = Number.isFinite(ru?.velocityCoverage) ? ru.velocityCoverage : 0;
  if(cov >= 0.6) return '‚õΩ';
  if(cov <= 0.05) return 'üìÑ';
  return 'üéØ';
}

function _shotMarkerChargeLeaderboardHtml(){
  const rollups = window.__xqaSmPhase2?.chargeRollups || [];
  if(!rollups.length) return '';

  const rows = rollups.map((ru, idx)=>{
    const ci = ru.chargeIndex;
    const best = Number.isFinite(ru.bestScore) ? ru.bestScore.toFixed(1) : '‚Äî';
    const med  = Number.isFinite(ru.medianScore) ? ru.medianScore.toFixed(1) : '‚Äî';
    const conf = Number.isFinite(ru.chargeConfidence) ? ru.chargeConfidence.toFixed(2) : '‚Äî';
    const nSess = ru.nSessions || 0;
    const cov = Number.isFinite(ru.velocityCoverage) ? Math.round(ru.velocityCoverage*100) : 0;

    const medVert = Number.isFinite(ru.medianVerticalMoa) ? ru.medianVerticalMoa.toFixed(3) : '‚Äî';
    const medMR   = Number.isFinite(ru.medianMeanRadiusMoa) ? ru.medianMeanRadiusMoa.toFixed(3) : '‚Äî';
    const medResid= Number.isFinite(ru.medianResidualVerticalMoa) ? ru.medianResidualVerticalMoa.toFixed(3) : '‚Äî';

    return `
      <tr class="border-t border-white/5 hover:bg-white/5 cursor-pointer" onclick="openSmChargeDrilldown(${ci})">
        <td class="py-2 px-2 text-[12px]">${_smChargeIcon(ru)}</td>
        <td class="py-2 px-3 text-[12px] text-white/90 font-medium">Charge ${ci}</td>
        <td class="py-2 px-3 text-[11px] text-white/90">${best}</td>
        <td class="py-2 px-3 text-[11px] text-white/90">${med}</td>
        <td class="py-2 px-3 text-[11px] text-white/70">${medResid}</td>
        <td class="py-2 px-3 text-[11px] text-white/70">${medVert}</td>
        <td class="py-2 px-3 text-[11px] text-white/70">${medMR}</td>
        <td class="py-2 px-3 text-[11px] text-white/70">${nSess}</td>
        <td class="py-2 px-3 text-[11px] text-white/70">${cov}%</td>
        <td class="py-2 px-3 text-[11px] text-white/90">${conf}</td>
      </tr>`;
  }).join('');

  return `
    <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-2xl p-3 mb-3">
      <div class="flex items-center justify-between gap-3 mb-2">
        <div class="text-white text-sm font-semibold">üèÅ Charge Leaderboard (Phase 2.2)</div>
        <div class="text-grt-subtle text-[10px]">Click a charge row to drill down</div>
      </div>
      <div class="overflow-x-auto">
        <table class="w-full text-left">
          <thead>
            <tr class="text-grt-subtle text-[10px] uppercase tracking-wide">
              <th class="py-2 px-2"> </th>
              <th class="py-2 px-3">Charge</th>
              <th class="py-2 px-3">Best</th>
              <th class="py-2 px-3">Median</th>
              <th class="py-2 px-3">Med Resid</th>
              <th class="py-2 px-3">Med Vert</th>
              <th class="py-2 px-3">Med MR</th>
              <th class="py-2 px-3">Sessions</th>
              <th class="py-2 px-3">Vel Cov</th>
              <th class="py-2 px-3">Conf</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
    </div>
  
    ${_shotMarkerChargeLeaderboardHtml()}
  `;
}

function openSmChargeDrilldown(chargeIndex){
  try{
  const rollups = window.__xqaSmPhase2?.chargeRollups || [];
  const ru = rollups.find(x => Number(x.chargeIndex) === Number(chargeIndex));
  if(!ru) return;

  const sessions = ru.sessions || [];
  const list = sessions
    .slice()
    .sort((a,b)=>{
      const as = a?.derived?.rank2?.score;
      const bs = b?.derived?.rank2?.score;
      if(Number.isFinite(as) && Number.isFinite(bs)) return as - bs;
      if(Number.isFinite(as)) return -1;
      if(Number.isFinite(bs)) return 1;
      return 0;
    })
    .map(s=>{
      const key = s?.meta?.sessionKey || '';
      const title = s?.meta?.relayStr ? `${s.meta.relayStr}` : (s?.name || 'Session');
      const sc = s?.derived?.rank2?.score;
      const scTxt = Number.isFinite(sc) ? sc.toFixed(3) : '‚Äî';
      return `<div class="flex items-center justify-between gap-3 py-2 border-t border-white/5">
        <div class="text-white/85 text-sm truncate">${key || title}</div>
        <div class="flex items-center gap-2">
          <div class="text-white/90 text-xs tabular-nums">${scTxt}</div>
          <button class="px-2 py-1 rounded-lg border border-white/10 text-[11px] text-white/80 hover:bg-white/5"
            onclick="event.stopPropagation(); openSmDrilldownBySessionKey(${JSON.stringify(key)})">View</button>
        </div>
      </div>`;
    }).join('');

  const cov = Number.isFinite(ru.velocityCoverage) ? Math.round(ru.velocityCoverage*100) : 0;
  const html = `
    <div class="flex items-start justify-between gap-3">
      <div>
        <div class="text-white text-xl font-semibold">Charge ${ru.chargeIndex}</div>
        <div class="text-grt-subtle text-[12px]">Sessions: ${ru.nSessions} ‚Ä¢ Shots: ${ru.nShotsTotal} ‚Ä¢ Velocity coverage: ${cov}%</div>
      </div>
      <button class="h-10 w-10 rounded-xl border border-white/10 hover:bg-white/5 text-white/80" onclick="closeSmDrilldown()">‚úï</button>
    </div>

    <div class="grid grid-cols-2 gap-3 mt-4">
      <div class="rounded-2xl border border-white/10 bg-white/5 p-3">
        <div class="text-grt-subtle text-[11px] uppercase tracking-wide">Median Rank2</div>
        <div class="text-white text-2xl font-semibold mt-1">${Number.isFinite(ru.medianScore)?ru.medianScore.toFixed(1):'‚Äî'}</div>
      </div>
      <div class="rounded-2xl border border-white/10 bg-white/5 p-3">
        <div class="text-grt-subtle text-[11px] uppercase tracking-wide">Confidence</div>
        <div class="text-white text-2xl font-semibold mt-1">${Number.isFinite(ru.chargeConfidence)?ru.chargeConfidence.toFixed(2):'‚Äî'}</div>
      </div>
      <div class="rounded-2xl border border-white/10 bg-white/5 p-3">
        <div class="text-grt-subtle text-[11px] uppercase tracking-wide">Median Residual Vertical</div>
        <div class="text-white text-2xl font-semibold mt-1">${Number.isFinite(ru.medianResidualVerticalMoa)?ru.medianResidualVerticalMoa.toFixed(3)+' MOA':'‚Äî'}</div>
      </div>
      <div class="rounded-2xl border border-white/10 bg-white/5 p-3">
        <div class="text-grt-subtle text-[11px] uppercase tracking-wide">Median Vertical</div>
        <div class="text-white text-2xl font-semibold mt-1">${Number.isFinite(ru.medianVerticalMoa)?ru.medianVerticalMoa.toFixed(3)+' MOA':'‚Äî'}</div>
      </div>
    </div>

    <div class="rounded-2xl border border-white/10 bg-white/5 p-3 mt-4">
      <div class="text-white text-base font-semibold mb-1">Sessions in this charge</div>
      <div class="text-grt-subtle text-[11px] mb-2">Click ‚ÄúView‚Äù to open the session drilldown</div>
      <div>${list || '<div class="text-grt-subtle text-sm">No sessions linked.</div>'}</div>
    </div>
  `;

  const overlay=document.getElementById('smDrilldownOverlay');
  const panel=document.getElementById('smDrilldownPanel');
  if(!overlay||!panel) return;
  panel.innerHTML=html;
  overlay.classList.remove('hidden');

  }catch(e){
    console.error(e);
    try{ showStatus('error','ShotMarker drilldown failed: '+(e?.message||e)); }catch(_e){}
  }
}

function openSmDrilldownBySessionKey(sessionKey){
  const rows = window.__xqaSmPhase2Rows || [];
  const idx = rows.findIndex(r => r && r.key === sessionKey);
  if(idx >= 0) openSmDrilldown(idx);
}


function openSmDrilldown(rowIndex){
  try{
  const rows = window.__xqaSmPhase2Rows || [];
  const x = rows[rowIndex];
  if(!x) return;

  const s = x.s;
  const d = s?.derived || {};
  const meta = s?.meta || {};
  const distanceYd = (meta.distanceYd && isFinite(meta.distanceYd)) ? meta.distanceYd : 1000;

  const vertMoa = Number.isFinite(d.vertMoa) ? d.vertMoa : (Number.isFinite(d.vertMm)? _mmToMoa(d.vertMm, distanceYd): null);
  const mrMoa   = Number.isFinite(d.mrMoa) ? d.mrMoa : (Number.isFinite(d.mrMm)? _mmToMoa(d.mrMm, distanceYd): null);

  const residMm = d?.velocityResidual?.residualVerticalESmm;
  const residMoa = Number.isFinite(residMm) ? _mmToMoa(residMm, distanceYd) : null;

  const vSD_model = d?.velocityDiag?.vSD;
  const vES_model = d?.velocityDiag?.vES;
  const r2  = d?.velocityDiag?.r2;
  const corr = d?.velocityDiag?.corr;
  const flags = d?.velocityDiag?.flags || {};

  // If we don't have per-shot velocity (target-only ShotMarker), we can still show chrono-linked SD/ES
  const vSD_chrono = d?.velocity?.sd;
  const vES_chrono = d?.velocity?.es;

  const vSD = Number.isFinite(vSD_model) ? vSD_model : (Number.isFinite(vSD_chrono) ? vSD_chrono : null);
  const vES = Number.isFinite(vES_model) ? vES_model : (Number.isFinite(vES_chrono) ? vES_chrono : null);

  const hasModelVel = Number.isFinite(vSD_model) || Number.isFinite(vES_model) || Number.isFinite(r2) || Number.isFinite(corr);
  const hasAnyVel = Number.isFinite(vSD) || Number.isFinite(vES);

  const velLabel = hasModelVel ? (d?.rank2?.label || 'mixed') : (hasAnyVel ? 'linked-chrono' : 'target-only');

// Chrono-linked SD details (from the matched charge stats, if available)
const chronoChargeIndex = Number.isFinite(x?.ci) ? Number(x.ci) : null;
const chronoRow = (chronoChargeIndex !== null && Array.isArray(allStats)) ? allStats[chronoChargeIndex] : null;
const chronoSD = chronoRow && Number.isFinite(chronoRow.velocitySD) ? chronoRow.velocitySD : null;
const chronoSDSource = chronoRow && chronoRow.velocitySDSource ? chronoRow.velocitySDSource : null;
const chronoSDShots = chronoRow && Number.isFinite(chronoRow.velocityShotCount) ? chronoRow.velocityShotCount : null;
const chronoSDExcluded = chronoRow && Number.isFinite(chronoRow.velocityExcludedCount) ? chronoRow.velocityExcludedCount : null;
  const velIcon  = hasModelVel ? _smRankIcon(velLabel) : (hasAnyVel ? '‚õ≠' : 'üìÑ');


  const html = `
    <div class="flex items-start justify-between gap-3">
      <div>
        <div class="text-white font-semibold text-base">${meta.targetName || 'ShotMarker Session'}</div>
        <div class="text-grt-subtle text-[11px] mt-1">${meta.sessionKey || ''}</div>
                <div class="text-grt-subtle text-[11px] mt-1">Shots: <span class="text-white/90">${Number.isFinite(d.totalShots)?d.totalShots:'‚Äî'}</span> (<span class="text-white/90">${Number.isFinite(d.scoringShots)?d.scoringShots:'‚Äî'}</span> scoring, <span class="text-white/90">${Number.isFinite(d.sighterShots)?d.sighterShots:'‚Äî'}</span> sighters excluded)</div>
        ${_smDominantDiagSummaryHtml(d.dominantDiag)}
${_smImprovementPillHtml(x.ci)}
      </div>
      <button class="px-2 py-1 rounded-lg border border-grt-frame bg-grt-panel-soft text-white/80 hover:bg-white/10" onclick="closeSmDrilldown()">‚úï</button>
    </div>

    <div class="mt-4 grid grid-cols-2 gap-3 text-sm">
      <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
        <div class="text-grt-subtle text-[10px] uppercase">Residual Vertical</div>
        <div class="text-white text-lg font-semibold mt-1">${hasModelVel && Number.isFinite(residMoa) ? (__fmtNum(residMoa,3)+' MOA') : '‚Äî'}</div>
      </div>
      <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
        <div class="text-grt-subtle text-[10px] uppercase">Vertical ES</div>
        <div class="text-white text-lg font-semibold mt-1">${isFinite(vertMoa)?__fmtNum(vertMoa,3):'‚Äî'} MOA</div>
      </div>

      <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
        <div class="text-grt-subtle text-[10px] uppercase">Mean Radius</div>
        <div class="text-white text-lg font-semibold mt-1">${isFinite(mrMoa)?__fmtNum(mrMoa,3):'‚Äî'} MOA</div>
      </div>
      <div class="bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
        <div class="text-grt-subtle text-[10px] uppercase">Confidence</div>
        <div class="text-white text-lg font-semibold mt-1">${isFinite(d?.rank2?.confidence)?__fmtNum(d.rank2.confidence,2):'‚Äî'}</div>
      </div>
    </div>


    <div class="mt-4 bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
      <div class="flex items-center justify-between">
        <div class="text-white font-semibold">Diagnostics</div>
        <div class="text-grt-subtle text-[11px]">Phase 3</div>
      </div>
      <div class="mt-2 flex flex-wrap gap-2">${_smPhase3BadgePills((d.phase3 && d.phase3.badges) ? d.phase3.badges : [])}</div>
      <div class="mt-3 text-[12px] text-grt-subtle space-y-1">
        ${(d.phase3 && Array.isArray(d.phase3.notes) && d.phase3.notes.length) ? d.phase3.notes.slice(0,3).map(n=>`<div>‚Ä¢ ${n}</div>`).join('') : '<div>‚Ä¢ ‚Äî</div>'}
      </div>
    </div>

    <div class="mt-4 bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
      <div class="flex items-center justify-between">
        <div class="text-white font-semibold">Velocity ‚Üî Vertical</div>
        <div class="text-grt-subtle text-[11px]">${velIcon} ${velLabel}</div>
      </div>
      <div class="mt-2 text-sm text-white/90">
        SD: <span class="text-white">${isFinite(vSD)?__fmtNum(vSD,1):'‚Äî'}</span> fps ‚Ä¢
        ES: <span class="text-white">${isFinite(vES)?__fmtNum(vES,0):'‚Äî'}</span> fps ‚Ä¢
        r¬≤: <span class="text-white">${isFinite(r2)?__fmtNum(r2,2):'‚Äî'}</span> ‚Ä¢
        corr: <span class="text-white">${isFinite(corr)?__fmtNum(corr,2):'‚Äî'}</span>
      </div>
      <div class="mt-2 text-[12px] text-grt-subtle">
  SD source: <span class="text-white/90">${
    hasModelVel && Number.isFinite(vSD_model) ? 'model-fit'
      : (chronoSDSource ? ('chrono-'+chronoSDSource) : (hasAnyVel ? 'linked-chrono' : 'missing'))
  }</span>${
    (chronoSDShots!==null) ? (' ‚Ä¢ shots used: <span class="text-white/90">'+chronoSDShots+'</span>') : ''
  }${
    (chronoSDExcluded!==null) ? (' ‚Ä¢ excluded: <span class="text-white/90">'+chronoSDExcluded+'</span>') : ''
  }
</div>
<div class="mt-2 text-[12px] text-grt-subtle">
        Flags: ${hasModelVel ? (flags.weirdSign?'‚ö† weirdSign ':'')+(flags.velocityDominated?'‚õΩ velocityDominated ':'')+(flags.windDominated?'üå¨ windDominated ':'')+(flags.mixed?'üéØ mixed':'') : (hasAnyVel ? '‚õ≠ linked chrono (no per-shot)' : 'üìÑ target-only (no velocity)')}
      </div>
    </div>

    <div class="mt-4 bg-grt-panel-soft/40 border border-grt-frame rounded-xl p-3">
      <div class="text-grt-subtle text-[10px] uppercase">Rank2</div>
      <div class="text-white text-lg font-semibold mt-1">${isFinite(d?.rank2?.score)?__fmtNum(d.rank2.score,4):'‚Äî'}</div>
      <div class="mt-2 text-[12px] text-grt-subtle">${(d?.rank2?.reasons||[]).join(' ‚Ä¢ ')}</div>
    </div>
  `;

  const overlay=document.getElementById('smDrilldownOverlay');
  const panel=document.getElementById('smDrilldownPanel');
  if(!overlay||!panel) return;
  panel.innerHTML=html;
  overlay.classList.remove('hidden');

  }catch(e){
    console.error(e);
    try{ showStatus('error','ShotMarker drilldown failed: '+(e?.message||e)); }catch(_e){}
  }
}
function closeSmDrilldown(){
  const overlay=document.getElementById('smDrilldownOverlay');
  if(overlay) overlay.classList.add('hidden');
}


// --- v0.89: ShotMarker sanity button (delegated binding, survives re-renders) ---
(function(){
  try{
    if(window.__smSanityDelegated) return;
    window.__smSanityDelegated = true;
    document.addEventListener('click', function(e){
      const btn = e.target && e.target.closest ? e.target.closest('[data-sm-sanity]') : null;
      if(!btn) return;
      e.preventDefault();
      e.stopPropagation();
      try{
        if(typeof _smLogPhase2SanityTable === 'function'){
          _smLogPhase2SanityTable(true);
        }else{
          console.warn('Sanity check function not available.');
        }
      }catch(err){
        console.error(err);
      }
    }, true);
  }catch(_e){}
})();



// --- Standalone Save/Load button wiring (no inline onclick dependency) ---
try{
  const _saveBtn = document.getElementById('saveSessionBtn');
  if(_saveBtn) _saveBtn.addEventListener('click', (e)=>{ e.preventDefault(); try{ window.exportStandaloneJson && window.exportStandaloneJson(); }catch(err){ console.error(err); try{ showStatus('error','Save session failed: ' + (err?.message||err)); }catch(_e){} }});
  const _loadBtn = document.getElementById('loadSessionBtn');
  if(_loadBtn) _loadBtn.addEventListener('click', (e)=>{ e.preventDefault(); try{ window.importStandaloneJson && window.importStandaloneJson(); }catch(err){ console.error(err); try{ showStatus('error','Load session failed: ' + (err?.message||err)); }catch(_e){} }});
}catch(_e){}


// Ensure standalone save/load functions are globally accessible for inline onclick handlers
try{ window.exportStandaloneJson = exportStandaloneJson; }catch(_e){}
try{ window.importStandaloneJson = importStandaloneJson; }catch(_e){}
</script>

<!-- How-to overlay -->
<div id="helpOverlay"
     class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
  <div class="bg-grt-panel-soft rounded-2xl border border-grt-frame max-w-xl w-[90%] p-4 md:p-6 shadow-2xl relative">
    <button id="helpOverlayClose"
            class="absolute top-2 right-2 text-grt-subtle text-xs hover:text-grt-soft">
      ‚úï
    </button>

    <h2 class="text-white text-lg md:text-xl font-semibold mb-2">
      How to use GRT Chrono Importer
    </h2>
    <p class="text-grt-subtle text-xs md:text-sm mb-4">
      This is a quick start for your first run. You can ignore advanced options until you‚Äôre comfortable.
    </p>

    <ol class="space-y-3 text-[11px] md:text-xs text-grt-soft list-decimal list-inside">
      <li>
        <span class="font-semibold text-grt-soft">Step 1 ‚Äì Load base <code class="bg-slate-800/70 px-1 rounded">.grtload</code> (optional)</span><br />
        Open an existing GRT project if you want imported data to land inside it. If you skip this, the importer creates a fresh GRT file.
      </li>
      <li>
        <span class="font-semibold text-grt-soft">Step 2 ‚Äì Pick an import mode</span><br />
        <strong>Standard</strong>: chrono files ‚Üí one ‚ÄúImported Measurement‚Äù tab.<br />
        <strong>Ladder</strong>: chrono files per charge ‚Üí one ‚ÄúImported Ladder‚Äù tab.<br />
        <strong>Sessions</strong>: Garmin multi-session workbook ‚Üí ‚ÄúImported Sessions‚Äù tabs (Garmin only).
      </li>
      <li>
        <span class="font-semibold text-grt-soft">Step 3 ‚Äì Load chrono files</span><br />
        Drop your CSV/TSV/Excel files into the file area. Check that units and device match (Garmin/Athlon).
      </li>
      <li>
        <span class="font-semibold text-grt-soft">Step 4 ‚Äì Export to GRT</span><br />
        Click <strong>Generate GRT file</strong>, then open the downloaded <code class="bg-slate-800/70 px-1 rounded">.grtload</code> in GRT. Look for
        ‚ÄúImported Measurement‚Äù, ‚ÄúImported Ladder‚Äù, ‚ÄúImported Sessions‚Äù, and optional ‚ÄúChrono vs Sim‚Äù in the measurement tabs.
      </li>
    </ol>

    <div class="mt-4 border-t border-grt-frame/50 pt-3 text-[11px] md:text-xs text-grt-subtle space-y-1">
      <p>
        <span class="font-semibold text-grt-soft">Not ready for the advanced stuff?</span><br />
        Leave <em>Extended metrics</em> and <em>Chrono vs Sim</em> OFF at first. Standard mode + SD/ES is plenty to get started.
      </p>
      <label class="inline-flex items-center gap-2 mt-1">
        <input id="helpOverlayDontShow" type="checkbox"
               class="rounded border-grt-frame bg-grt-panel-soft" />
        <span>Don‚Äôt show this automatically next time.</span>
      </label>
    </div>
  </div>
</div>


<!-- Hidden canvas used to generate the optional "Chrono vs Sim" PNG for .grtload export -->
<canvas id="chronoSimChart" style="display:none"></canvas>


<!-- ShotMarker drilldown overlay (Phase 2.1) -->
<div id="smDrilldownOverlay" class="hidden fixed inset-0 z-[80]">
  <div class="absolute inset-0 bg-black/70" onclick="closeSmDrilldown()"></div>
  <div class="absolute right-0 top-0 h-full w-full sm:w-[520px] bg-grt-panel border-l border-grt-frame p-4 overflow-y-auto shadow-2xl">
    <div id="smDrilldownPanel"></div>
  </div>
</div>

</body>
</html>
